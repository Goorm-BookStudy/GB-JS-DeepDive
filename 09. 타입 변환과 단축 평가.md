## 9.1 타입 변환이란?

- 자바스크립트의 모든 값에는 값이 있다.
- 명시적 타입 변환(=타입 캐스팅): 개발자가 의도적으로 값의 타입을 변환하는 것
- 암묵적 타입 변환(=타입 강제 변환): 개발자의 의도와는 상관 없이  표현식을 평가하는 도중에 자바스크립트 엔진에의해 암묵적으로 타입이 자동 변환
- 암묵적 타입 변환은 기존 변수 값을 재할당하여 변경하는 것이 아니라, 피연산자의 값을 암묵적으로 타입 변환해 새로운 타입의 값을 만들어 단 한 번 사용하고 버림.
- 암묵적 타입 변환 발생하지 않도록 하는것도 좋지 않다. → 명시적 타입 변환보다 가독성 측면에서 더 좋을 수 있음
    - ex) `(10).toString()` vs `10+’’`
- 코드를 예측할 수 있어야 한다.(내 코드, 동료 코드) → 타입 변환 동작 이해 필요!

## 9.2 암묵적 타입 변환

- `‘10’+1` → ‘102’ / `5*’10’` → 50 / `!0` → true
- 위와 같이 코드 문맥에 부합하지 않는 상황에서 에러를 발생시키지 않도록 암묵적 타입 변환이 발생해 **문자열**, **숫자**, **불리언**과 같은 **원시 타입** 중 하나로 타입 자동 변환
1. 문자열 타입으로 변환
    - '+' 연산자는 피연산자 중 하나 이상이 문자열이면 문자열 연결 연산자로 동작 → 피연산자 중 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환
    - 템플릭 리터럴의 표현식 삽입은 평가 결과를 문자열 타입으로 암묵적 타입 변환
    
      ```jsx
      1 + '2' // '12' 
      `1 + 1 = ${1 + 1}` // '1 + 1 = 2'
      
      // 숫자 타입
      0 + '' // '0'
      -0 + '' // '0'
      1 + '' // '1'
      -1 + '' // '-1'
      NaN + '' // 'NaN'
      Infinity + '' // 'Infinity'
      -Infinity + '' // '-Infinity'
      
      // 불리언 타입
      true + '' // 'true'
      false + '' // 'false'
      
      // null 타입
      null + '' // null
      
      // undefined 타입
      undefined + '' // undefined
      
      // 심벌 타입
      (Symbol()) + '' // TypeError
      
      // 객체 타입
      ({}) + ''           // '[object Object]'
      Math + ''           // '[object Math]'
      [] + ''             // ''
      [10, 20] + ''       // '10, 20'
      (function(){}) + '' // 'function(){}'
      Array + ''          // 'function Array() { [native code] }'
      ```
    
2. 숫자 타입으로 변환
    
    > 피연산자를 숫자 타입으로 암묵적 타입 변환 → 변환 못하면 표현식의 평가 결과 NaN
    > 
    - 산술 연산자
    
    ```jsx
    1 - '1'   // 0
    1 * '10'  // 10
    1 / 'one' // NaN
    ```
    
    - 비교 연산자
    
    ```jsx
    '1' > 0 // true
    ```
    
    - '+' 단항연산자
    
    ```jsx
    // 문자열 타입
    +''       // 0
    +'0'      // 0
    +'1'      // 1
    +'string' // NaN
    
    // 불리언 타입
    +true // 1
    +false // 0
    
    // null 타입
    +null // 0
    
    // undefined 타입
    +undefined // NaN
    
    // 심벌 타입
    +Symbold() // TypeError
    
    // 객체 타입
    +{}             // NaN
    +[]             // 0
    +[10, 20]       // NaN
    +(function(){}) // NaN
    ```
    
    - 빈 문자열(’’), 빈 매열([]), null, false → 0 / true → 1
    - 객체, 빈 배열이 아닌 배열, undefined → NaN
3. 불리언 타입으로 변환
    - 제어문(if문, for문), 삼항 조건 연산자의 조건식
    - 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy값(거짓으로 평가되는 값)으로 구분 → Truthy 값은 true, Falsy값은 false로 암묵적 타입 변환
    - Falsy: false, undefined, null, -0, 0, NaN, ‘(빈 문자열)
    - Truthy: Falsy 이외의 값 ex) true, ‘0’, {}, []
    
    ```jsx
    if ('') {} // Falsy
    if (false) {} // Falsy
    if (0) // Falsy
    ```
    

## 9.3 명시적 타입 변환

- 방법: 표준 빌트인 생성자 함수(String, Number, Boolean)를 new 연산자 없이 호출하는 방법, 빌트인 메서드를 사용하는 방법, 암묵적 타입 변환을 이용하는 방법
1. 문자열 타입으로 변환
    - String 생성자 함수를 new 연산자 없이 호출하는 방법
    - Object.prototype.toString 메서드를 사용하는 방법
    - 문자열 연결 연산자를 이용하는 방법
    
    ```jsx
    // 1. String 생성자 함수를 new 연산자 없이 호출하는 방법
    // 숫자 타입 -> 문자열 타입
    String(1);        // '1'
    String(NaN);      // 'NaN'
    String(Infinity); // 'Infinity'
    // 불리언 타입 -> 문자열 타입
    String(true);  // 'true'
    String(false); // 'false'
    
    // 2. Object.prototype.toString 메서드를 사용하는 방법
    // 숫자 타입 -> 문자열 타입
    (1).toString(); // '1'
    (NaN).toString(); // 'NaN'
    // 불리언 타입 -> 문자열 타입
    (true).toString(); // 'true'
    (false).toString(); // 'false'
    
    // 3. 문자열 연결 연산자를 이용하는 방법
    // 숫자 타입 -> 문자열 타입
    1 + ''; // '1'
    NaN + ''; // 'NaN'
    Infinity + ''; // 'Infinity'
    // 불리언 타입 -> 문자열 타입
    true + ''; // 'true'
    false + ''; // 'false'
    ```
    
2. 숫자 타입으로 변환
    - Number 생성자 함수를 new 연산자 없이 호출하는 방법
    - parseInt, parseFloat 함수를 사용하는 방법(문자열 숫자 타입으로 변환 가능)
    - +단항 산술 연산자를 이용하는 방법
    - *산술 연산자를 이용하는 방법
    
    ```jsx
    // 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법
    // 문자열 타입 -> 숫자 타입
    Number('0'); // 0
    Number('-1'); // -1
    Number('10.53'); // 10.53
    // 불리언 타입 -> 숫자 타입
    Number(true); // 1
    Number(false); // 0
    
    // 2. parseInt, parseFloat 함수를 사용하는 방법(문자열 숫자 타입으로 변환 가능)
    // 문자열 타입 -> 숫자 타입
    parseInt('0'); // 0
    parseFloat('10.53'); // 10.53
    
    // 3. +단항 산술 연산자를 이용하는 방법
    +'0'; // 0
    +true; // 1
    
    // 4. *산술 연산자를 이용하는 방법
    '0' * 1; // 0
    true * 1; // 1
    ```
    
3. 불리언 타입으로 변환
    - Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
    - ! 부정 논리 연산자를 두 번 사용하는 방법
    
    ```jsx
    // 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
    Boolean('x'); // true
    Boolean(''); // false
    Boolean('false'); // true
    Boolean(0); // false
    Boolean(1); // true
    Boolean(NaN); // false
    Boolean(Infinity); // true
    Boolean(null); // false
    Boolean(undefined); // false
    Boolean({}); // true
    Boolean([]); // true
    
    // 2. ! 부정 논리 연산자를 두 번 사용하는 방법
    !!'x'; // true
    ```
    

### 9.4 단축 평가

1. 논리 연산자를 사용한 단축 평가
    - 논리합(||) 또는 논리곱(&&) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. → 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.
    
    ```jsx
    'Cat' && 'Dog' // Dog
    'Cat' || 'Dog' // Cat
    ```
    
    - 좌항에서 우항으로 평가 진행. → 논리 연산의 결과를 결정한 피연산자를 타입 변환하지 않고 그대로 반환
    - 단축평가: 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것
        
        
        | 단축 평가 표현식 | 평가 결과 |
        | --- | --- |
        | true || anything | true |
        | false || anything | anything |
        | true && anything | anything |
        | false && anything | false |
    - if문 대체 가능
        - 조건이 Truthy값 일 떄 논리곱(&&) 연산자 표현식으로 if 문 대체
        - 조건이 Falsy값 일 때 논리합(||) 연산자 표현식으로 if 문 대체
        
        ```jsx
        if (done) message = '완료'; // 조건이 true 일 때
        message = done && '완료';
        
        if (!done) message = '미완료'; // 조건이 false 일 때
        message = done || '미완료';
        ```
        
    - 유용하게 사용되는 상황
        - 객체를 가키기리를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때
        
        ```jsx
        var elem = null;
        // var value = elem.value; // TypeError
        var value = elem && elem.value; // null
        ```
        
        - 함수 매개변수에 기본값을 설정할 때
        
        ```jsx
        // 함수 호출 시 인수 전달하지 않으면 매개변수에 undefined 할당되는데, 이 때문에 발생하는 에러 방지
        function getStringLength(str) { // (str = '') 과 동일
        	str = str || '';
        	return str.length;
        }
        getStringLength(); // 0
        getStringLength('hi'); // 2
        ```
        
2. 옵셔널 체이닝 연산자(?.)
    - 좌항의 피연산자가 null 또는 undefined인 경우 undefined 반환, 그렇지 않으면 우항의 프로퍼티 참조
    - 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌자 확인하고 프로퍼티 참조 시 유용
    - 도입 이전에는 && 사용한 단축평가를 통해 변수가 null, undefined 인지 확인
    - ?. 는 좌항의 피연산자가 Falsy값이라도 null, undefined 가 아니면 우항 프로퍼티 참조
    
    ```jsx
    var elem = null;
    var value = elem?.value; // undefined
    //var value = elem && elem.value // null
    
    var str = '';
    // var length = str && str.length; // ''
    var length = str?.length; // 0
    ```
    
3. null 병합 연산자(??)
    - 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환, 그렇지 않으면 좌항의 피연산자 반환
    - 변수에 기본값 설정 시 유용
    - 도입 이전 || 사용한 단축평가를 통해 변수 기본값 설정
    - ?? 는 좌항의 피연산자가 Falsy값이라도 null, undefined 가 아니면 좌항 피연산자 그대로 반환
    
    ```jsx
    var foo = null ?? 'default string'; // 'default string'
    var foo = '' || 'default string'; // 'default string'
    var foo = '' ?? 'default string'; // ''
    ```