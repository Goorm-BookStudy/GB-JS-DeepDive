# ✏️ 27장 배열

## 📌 27.9 배열 고차 함수

- 고차 함수란 함수를 인수로 전달 받거나 함수를 반환하는 함수를 말한다.
- JS의 함수는 일급 객체이므로 함수를 값처럼 인수로 전달할 수도, 반환할 수도 있다.
- 고차 함수는 외부 상태의 환경이나 가변 데이터를 피하고, 불변성을 지향하는 함수형 프로그래밍 기반이다.
  - 함수형 프로그래밍은 순수 함수와 보조 함수의 조합으로 로직 내 존재하는 조건문과 반복문을 제거해 복잡성을 해결, 변수의 사용을 억제해 상태 변경을 피하려는 프로그래밍 패러다임이다.
  - 조건문이나 반복문은 가독성을 해치고, 변수는 언제든 변경될 수 있어 오류의 근원이 될 수 있다.
  - 따라서 함수형 프로그래밍은 순수 함수로 부수 효과를 최대한 억제해 프로그램의 안정성을 높이고자 한다.
  - 순수 함수는 동일한 인수에 대해 항상 동일한 값을 반환, 함수 외부 상태를 변경하지 않아 언제나 예측 가능한 결과를 반환한다.
  - 보조 함수는 주요 기능을 수행하는 메인 함수를 보조하거나 코드의 가독성을 높이기 위해 사용된다.

#### 1. Array.prototype.sort

- 배열의 요소를 오름차순으로 정렬한 후 그 배열을 반환한다.
- 원본 배열을 직접 변경한다.
- 내림차순으로 요소를 정렬하려면 오름차순으로 정렬 후 reverse 메서드로 순서를 뒤집는다.

```
const fruits = ['Banana', 'Orange', 'Apple'];

fruits.sort();
console.log(fruits); // ['Apple', 'Banana', 'Orange']

fruits.reverse();
console.log(fruits); // ['Orange', 'Banana', 'Apple']
```

- 문자열 요소로 이루어진 배열의 정렬과 달리, 숫자로 이루어진 배열은 정렬 시 주의가 필요하다.
  - 유니코드 코드 포인트의 순서를 따르기 때문에 2와 10이 있을 때 10을 먼저 정렬하게 된다.
  - 숫자 요소를 정렬할 때는 정렬 순서를 정의하는 비교 함수를 인수로 전달해야 한다.
  - 비교 함수의 반환값이 0보다 작으면 비교 함수의 첫 번째 인수를 우선으로 정렬하고, 0이면 정렬하지 않으며, 0보다 크면 두 번째 인수를 우선하여 정렬한다.

```
const points = [40, 100, 1, 5, 2, 25, 10];

points.sort();
console.log(points); // [1, 10, 100, 2, 25, 40, 5]

// 비교 함수의 반환값이 0보다 작으면 a를 우선 정렬
points.sort((a, b) => a - b);
console.log(points); // [1, 2, 5, 10, 25, 40, 100]

points.sort((a, b) => b - a);
console.log(points); // [100, 40, 25, 10, 5, 2, 1]
```

- 객체를 요소로 갖는 배열의 정렬은 아래와 같다.

```
const todos = [
    { id: 4, content: 'JS' },
    { id: 1, content: 'HTML'},
    { id: 2, content: 'CSS'}
];

function compare(key) {
    return (a, b) => (a[key] > b[key] ? 1 : (a[key] < b[key] ? -1 : 0));
}

todos.sort(compare('id'));
console.log(todos);

/*
[
    { id: 1, content: 'HTML'},
    { id: 2, content: 'CSS'},
    { id: 4, content: 'JS' }
]
*/

todos.sort(compare('content'));
/*
[
    { id: 2, content: 'CSS'},
    { id: 1, content: 'HTML'},
    { id: 4, content: 'JS' }
]
*/
```

- sort 메서드에 quicksort 알고리즘을 사용했다가 ES10부터 timsort 알고리즘을 사용하게 되었다.
  - quicksort: 하나의 배열을 피봇을 기준으로 2개의 하위 배열로 분할한 후 재귀적으로 호출해 정렬하고 다시 결합하는 분할 정복 방법 기반
  - timsort: 합병 정렬과 삽입 정렬이 혼용된 하이브리드 정렬 알고리즘으로 Python, JAVA에서 사용한다.
  - https://d2.naver.com/helloworld/0315536

#### 2. Array.prototype.forEach

- for문을 대체할 수 있는 고차함수로 내부에서 반복문을 실행한다.
- 즉 내부에서 반복문을 통해 자신을 호출한 배열을 순회하면서 수행해야 할 처리를 **콜백 함수**로 전달 받아 반복 호출한다.

```
const numbers = [1, 2, 3];
const pows = [];

numbers.forEach(item => pows.push(item **2));
console.log(pows); // [1, 4, 9]
```

- forEach 메서드의 콜백 함수는 forEach 메서드를 호출한 배열의 요소값과 인덱스, forEach 메서드를 호출한 배열 자체, 즉 this를 순차적으로 전달받을 수 있다.

```
[1, 2, 3].forEach((item, index, arr) => {
    console.log(`요소값: ${item}, 인덱스: ${index}, this: ${JSON.stringify(arr)}`);
});
```

- 원본 배열을 변경하지는 않지만 콜백 함수로 원본 배열을 변경할 수는 있다.

```
const numbers = [1, 2, 3];

numbers.forEach((item, index, arr) => { arr[index] = item ** 2; });
console.log(numbers); // [1, 4, 9]
```

- forEach 메서드의 반환값은 언제나 undefined다.

```
const result = [1, 2, 3].forEach(console.log);
console.log(result); // undefined
```

- forEach 메서드의 두 번째 인수로 forEach 메서드의 콜백 함수 내부에서 this로 사용할 객체를 전달할 수 있는데, 화살표 함수를 사용하면 this를 가독성 좋게 일치시킬 수 있다.
- forEach 메서드의 콜백 함수는 일반 함수로 호출되기에 함수 내부의 this는 undefined를 가리킨다. (암묵적인 엄격 모드 적용) 따라서 this로 사용할 객체를 전달하거나 화살표 함수를 사용해 this를 참조한다.

```
// this 전달
const obj = {
  name: 'John',
  hobbies: ['programming', 'reading', 'swimming'],
  printHobbies: function() {
    this.hobbies.forEach(function(hobby) {
      console.log(`${this.name} likes ${hobby}`);
    }, this); // 두 번째 인자로 'this'로 사용할 객체를 전달
  }
};

obj.printHobbies();

// 화살표 함수 사용
const obj = {
  name: 'John',
  hobbies: ['programming', 'reading', 'swimming'],
  printHobbies: function() {
    this.hobbies.forEach((hobby) => { // 화살표 함수를 사용하여 'this' 일치
      console.log(`${this.name} likes ${hobby}`);
    });
  }
};

obj.printHobbies();

```

- forEach 메서드의 폴리필을 보면 forEach 메서드 내부에서도 for문을 통해 배열을 순회함을 알 수 있다. 단 반복문을 메서드 내부로 은닉해 복잡성을 해결한다.
- 따라서 forEach 메서드는 breack, continue문을 사용할 수 없다. (= 중간에 순회 중단 불가)
- 희소 배열의 경우 존재하지 않는 요소는 순회 대상에서 제외된다.
- for문에 비해 서능이 좋지는 않지만 가독성은 훨씬 좋기 때문에 요소가 대단히 많은 배열을 순회하거나 복잡한 코드가 아니라면 forEach 메서드 사용을 권장한다.

#### 3. Array.prototype.map

- 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출한 후 콜백 함수의 반환값들로 구성된 새로운 배열을 반환한다.
- 원본 배열은 변경되지 않는다.

```
const numbers = [1, 4, 9];

const roots = numbers.map(item => Math.sqrt(item));
console.log(roots); // [1, 2, 3]
console.log(numbers); // [1, 4, 9]
```

- forEach 메서드와 공통점은 **자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달 받은 콜백 함수를 반복 호출한다**는 것이다.
- 하지만 forEach 메서드는 언제나 undefined를 반환하고, map 메서드는 새로운 배열을 반환하는 차이가 있다.
- 즉 forEach 메서드가 단순히 반복문을 대체하는 고차 함수라면 map 메서드는 요소를 다른 값으로 매핑한 새로운 배열을 생성하는 고차 함수다.
- 그렇기 때문에 map 메서드가 생성해 반환하는 새로운 배열의 length 프로퍼티 값은 map 메서드를 호출한 배열의 length 프로퍼티 값과 반드시 일치한다. (1:1 매핑)

- map 메서드의 콜백 함수는 map 메서드를 호출한 배열의 요소값과 인덱스, map 메서드를 호출한 배열 자체, 즉 this를 순차적으로 전달 받을 수 있다.
- forEach 메서드와 동일하게 map 메서드의 두 번째 인수로 map 메서드의 콜백 함수 내부에서 this로 사용할 객체를 전달할 수 있다.
- 이를 화살표 함수로 가독성 좋게 일치시킬 수 있다.

#### 4. Array.prototype.fillter

- 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출한 후 콜백 함수의 반환값이 true인 요소로만 구성된 새로운 배열을 반환한다.
- 원본 배열은 변경되지 않는다.

```
const numbers = [1, 2, 3, 4, 5];
const odds = numbers.filter(item => item % 2);

console.log(odds); // [1, 3, 5]
```

- forEach, map 메서드와 동일하게 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출하지만 filter 메서드는 콜백 함수의 반환값이 true인 요소로만 추출된 새로운 배열을 반환한다.
- 특정 요소를 제거할 때, 특정 요소가 중복되어 있다면 중복된 요소가 모두 제거된다. 따라서 하나만 제거하려면 indexOf 메서드로 특정 요소의 인덱스를 취득한 후 splice 메서드를 사용한다.
- filter 메서드는 특정 조건을 만족하는 요소만 추출하기 때문에 새로 반환된 배열의 length 프로퍼티 값은 filter 메서드를 호출한 배열의 length 프로퍼티 값과 같거나 작다.

- filter 메서드의 콜백 함수는 filter 메서드를 호출한 배열의 요소값과 인덱스, filter 메서드를 호출한 배열 자체, 즉 this를 순차적으로 전달 받을 수 있다.
- forEach, map 메서드와 동일하게 filter 메서드의 두 번째 인수로 filter 메서드의 콜백 함수 내부에서 this로 사용할 객체를 전달할 수 있다.
- 이를 화살표 함수로 가독성 좋게 일치시킬 수 있다.

#### 5. Array.prototype.reduce

- 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출한다. 그리고 콜백 함수의 반환값을 다음 순회 시 콜백 함수의 첫 번째 인수로 전달하면서 콜백 함수를 호출해 하나의 결과값을 만들어 반환한다.
- 원본 배열은 변경되지 않는다.
- reduce 메서드는 첫 번째 인수로 콜백 함수, 두 번째 인수로 초기값을 전달 받는다.
- reduce 메서드의 콜백 함수는 4개의 인수, 초기값 또는 콜백 함수 이전 반환값, reduce 메서드를 호출한 배열의 요소값과 인덱스, reduce 메서드를 호출한 배열 자체, 즉 this가 전달된다.

```
const sum = [1, 2, 3, 4].reduce((acc, cur, index, arr) => acc + cur, 0);
console.log(sum); // 10
```

- 평균 구하기, 최대값 구하기(Math.max 사용 권장), 요소의 중복 횟수 구하기, 중첩 배열 평탄화(flat 메서드 사용 권장), 중복 요소 제거(filter & Set 사용 권장) 등 다양하게 사용할 수 있다.

```
// 요소의 중복 횟수 구하기
const fruits = ['banana', 'apple', 'orange', 'orange', 'apple'];

const count = fruits.reduce((acc, cur) => {
    acc[cur] = (acc[cur]) || 0) + 1;
    return acc;
}, {});

console.log(count);
```

- reduce 메서드의 두 번째 인수로 전달하는 초기값은 생략할 수 있지만, 언제나 전달하는 것이 안전하다.
- 빈 배열로 호출하면 에러가 발생하기 때문이다.
- 또한 객체의 특정 프로퍼티 값을 합산하는 경우에 계산이 달라지기 때문이다.

```
// 초기값 전달하지 않기
const sum = [].reduce((acc, cur) => acc + cur);
console.log(sum); // 타입 에러

// 초기값 전달
const sum = [].reduce((acc, cur) => acc + cur, 0);
console.log(sum); // 0
```

```
const products = [
    { id: 1, price: 100},
    { id: 2, price: 200},
    { id: 3, price: 300}
];

// 초기값 전달하지 않기
// acc가 300이지 acc.price는 undefined이기 때문
const priceSum = products.reduce((acc, cur) => acc.price + cur.price);
console.log(priceSum); // NaN

// 초기값 전달
const priceSum = products.reduce((acc, cur) => acc + cur.price, 0);
console.log(priceSum); // 600
```

#### 6. Array.prototype.some

- 자신을 호출한 배열의 요소를 순호하면서 인수로 전달된 콜백 함수를 호출한다. 이때 some 메서드는 콜백 함수의 반환값이 단 한번이라도 참이면 true, 모두 거짓이면 false를 반환한다.
- 즉 배열의 요소 중 콜백 함수를 통해 정의한 조건을 만족하는 요소가 1개 이상 존재하는지 확인해 결과를 불리언 타입으로 반환한다.
- some 메서드를 호출한 배열이 빈 배열인 경우 언제나 false를 반환하니 주의해야 한다.
- 이전의 고차 함수들과 마찬가지로 메서드를 호출한 요소값과 인덱스, some 메서드를 호출한 배열 자체, 즉 this를 순차적으로 전달 받을 수 있다.
- 이전의 고차 함수들과 마찬가지로 두 번째 인수로 콜백 함수 내부에서 this로 사용할 객체를 전달할 수 있으며, 화살표 함수를 사용하는 것이 가독성 면에서 더 좋다.

```
[5, 10, 15].some(item => item > 10); // true
[5, 10, 15].some(item => item < 0); // false
['apple', 'banana', 'orange'].some(item => item === 'banana'); // true;
[].some(item => item > 3); // false
```

#### 7. Array.prototype.every

- 자신을 호출한 배열의 요소를 순회하면서 인수로 전달된 콜백 함수를 호출한다. 이때 every 메서드는 콜백 함수의 반환값이 모두 참이면 true, 한번이라도 거짓이면 false를 반환한다.
- 즉 배열의 모든 요소가 콜백 함수를 통해 정의한 조건을 모두 만족하는지 확인해 그 결과를 불리언 타입으로 반환한다.
- 단 every 메서드를 호출한 배열이 빈 배열인 경우 언제나 true를 반환하니 주의해야 한다.
- 이전의 고차 함수들과 마찬가지로 메서드를 호출한 요소값과 인덱스, every 메서드를 호출한 배열 자체, 즉 this를 순차적으로 전달 받을 수 있다.
- 이전의 고차 함수들과 마찬가지로 두 번째 인수로 콜백 함수 내부에서 this로 사용할 객체를 전달할 수 있으며, 화살표 함수를 사용하는 것이 가독성 면에서 더 좋다.

```
[5, 10, 15].every(item => item > 3); // true
[5, 10, 15].every(item => item > 10); // false
[].every(item => item > 3); // true
```

#### 8. Array.prototype.find

- 자신을 호출한 배열의 요소를 순회하면서 인수로 전달된 콜백 함수를 호출해 반환값이 true인 첫 번째 요소를 반환한다.
- 콜백 함수의 반환값이 true인 요소가 존재하지 않는다면 undefined를 반환한다.
- 이전의 고차 함수들과 마찬가지로 메서드를 호출한 요소값과 인덱스, every 메서드를 호출한 배열 자체, 즉 this를 순차적으로 전달 받을 수 있다.
- 이전의 고차 함수들과 마찬가지로 두 번째 인수로 콜백 함수 내부에서 this로 사용할 객체를 전달할 수 있으며, 화살표 함수를 사용하는 것이 가독성 면에서 더 좋다.
- filter 메서드가 조건에 맞는 요소들만 추출해 새로운 배열을 반환하는 것과 달리, find 메서드는 콜백 함수의 반환값이 true인 첫 번째 요소만 반환하므로 항상 해당 요소값을 반환한다.

```
[1, 2, 2, 3].filter(item => item === 2); // [2, 2]
[1, 2, 2, 3].find(item => item === 2); // 2
```

#### 9. Array.prototype.findIndex

- ES6에서 도입된 findeIndex 메서드는 자신을 호출한 배열의 요소를 순회하면서 인수로 전달된 콜백 함수를 호출해 반환값이 true인 첫 번째 요소의 인덱스를 반환한다.
- 콜백 함수의 반환값이 true인 요소가 존재하지 않는다면 -1을 반환한다.
- 이전의 고차 함수들과 마찬가지로 메서드를 호출한 요소값과 인덱스, every 메서드를 호출한 배열 자체, 즉 this를 순차적으로 전달 받을 수 있다.
- 이전의 고차 함수들과 마찬가지로 두 번째 인수로 콜백 함수 내부에서 this로 사용할 객체를 전달할 수 있으며, 화살표 함수를 사용하는 것이 가독성 면에서 더 좋다.

```
const users = [
    { id: 1, name: 'Lee' },
    { id: 2, name: 'Kim' },
    { id: 3, name: 'Choi' },
    { id: 4, name: 'Park' },
];

users.findIndex(user => user.id === 2); // 1
users.findIndex(user => user.name === 'Park'); // 3
```

#### 10. Array.prototype.flatMap

- ES10에서 도입된 flatMap 메서드는 map 메서드를 통해 생성된 새로운 배열을 평탄화한다.
- 즉 map 메서드와 flat 메서드를 순차적으로 실행한다.
- 단 flat 메서드처럼 인수를 전달해 평탄화 깊이를 지정할 수 없고, 1단계만 평탄화 한다.

```
const arr = ['hello', 'world'];
arr.flatMap(x => x.split('')); // ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd']

arr.flatMap((str, index) => [index, [str, str.length]]);
// [[0, ['hello', 5]], [1, ['world', 5]]] => [0, ['hello', 5], 1, ['world', 5]]
```
