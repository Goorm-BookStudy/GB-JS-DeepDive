📍 원시 타입의 값 - 변경 불가능한 값 ( 원시 값을 변수에 할당 시 실제 값 저장 )
- 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달 -> 값에 의한 전달
- 읽기 전용 값으로 변경 불가능하다.
- 데이터의 신뢰성 보장!
- 값의 변경(상태 변경) 추적에 유리하다.

<br/>

> 📌 상수와 변경 불가능한 값은 다르다.
- 상수는 재할당이 금지된 변수일 뿐, 원시 값은 값 변경은 불가능하지만 변수는 변경 가능하다.

<br/>

### 불변성
- 재할당 하게되면 메모리의 값이 변한다. -> 불변성을 갖는 원시값을 변경 불가능하기 때문에

<br/>

#### 문자열의 불변성
- 문자열은 유사 배열이다.
- 재할당은 가능하지만 문자열은 변경 불가능한 값으로 변경사항이 반영되지 않는다.
 
```
var str = 'string';

str[0] = 'S';

console.log(str); // string (값 변경 x)
```

##### 값에 의한 전달
```
var score = 80;

var copy = score;

console.log(score, copy); // 80 80
console.log(score === copy); // true
```
- 80이라는 값을 가진다는 것은 동일하지만 다른 메모리 공간에 저장된 별개의 값이다.

<br/>

> 💡 변수에 원시 값을 갖는 변수를 할당하는 시점에는 두 변수가 같은 원시 값을 참조하다가 어느 한쪽의 변수에 재할당이 이뤄졌을 때 비로소 새로운 메모리 공간에 재할당된 값을 저장하도록 동작할 수도 있다.

```
var score = 80;  
var copy = score; // 이 시점에는 같은 주소를 참조하고 있을 수도 있다.

score = 100; // 다른 주소 참조
```


<br/>


> 📌 식별자 === 메모리 주소에 붙인 이름
- 값에 의한 전달도 사실은 값을 전달하는 것이 아닌 메모리 주소를 전달한다.
- 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.

<br/>
<br/>


📍 ***객체(참조) 타입의 값*** - 변경 가능한 값 ( 객체를 변수에 할당 시 참조 값이 저장 )
- 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달 -> 참조에 의한 전달
- 동적으로 추가 및 삭제가 가능함
- 복잡한 방식(불확실하고 일정하지 않은 크기)으로 비용이 많이 든다. -> 메모리의 효율적 소비가 어렵고 성능이 나빠진다.
- 원시 값을 할당한 변수를 참조하면 메모리에 저장되어 있는 원시 값에 접근한다. 하지만 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근한다.
- ⭐️여러 개의 식별자가 하나의 객체를 공유할 수 있다⭐️ -> 원시 값은 새롭게 생성하지만 객체는 아니다.

<br/>

> #### 얕은 복사(shallow copy) vs 깊은 복사(deep copy)
***얕은 복사***
- **객체의 최상위 수준만 복사**하므로 중첩된 객체가 변경될 경우 원본도 영향을 X

```
const obj1 = {
  a: 1,
  b: { c: 2 }
};

const obj2 = { ...obj1 };  // 얕은 복사

obj2.b.c = 3;

console.log(obj1.b.c);  // 출력: 3
```

<br/>

💡 최상위 수준이란? 
객체 안에 중첩된 객체나 배열이 없는 첫 번째 레벨의 속성들을 지칭

예를 들어, 
```
const obj = {
  a: 1,
  b: "text",
  c: {
    d: 2,
    e: [3, 4],
    f: {
      g: 5
    }
  }
};
```
여기서 a, b, c는 obj의 최상위 수준의 속성이고 d, e, f는 c 속성 내의 중첩된 속성이므로 최상위 수준의 속성이 아니다.

얕은 복사를 할 경우 a와 b 속성은 원본 객체와 복사본 객체에서 독립적이게 됩니다. 그러나 c는 참조형 데이터이기 때문에 얕은 복사를 통해 복사된 객체에서 c를 수정하면 원본 객체의 c 속성도 변경됩니다.

<br/>

***깊은 복사***
- 객체의 모든 수준을 복사하여 원본과 복사본이 독립적 복사본의 변경이 원본에 영향을 주지 않는다.

```
const obj1 = {
  a: 1,
  b: { c: 2 }
};

const obj2 = JSON.parse(JSON.stringify(obj1));  // 깊은 복사

obj2.b.c = 3;

console.log(obj1.b.c);  // 출력: 2

```

### 참조에 의한 전달
- 여러 개의 식별자가 하나의 객체를 공유하면 한 식별자의 값이 추가, 삭제 등의 변경이 있을 때 다른 식별자 또한 영향을 받게 된다.
- **값에 의한 전달**과 **참조에 의한 전달**은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달하는 면에서 동일하다. 그러나 변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이만 있을 뿐이다.

📌 따라서 JS에는 참조에 의한 전달은 존재하지 않고 값에 의한 전달만 존재한다고 말할 수 있다.

