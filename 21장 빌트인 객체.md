## 자바스크립트 객체의 분류
1. 표준 빌트인 객체
- ECMAScript 사양에 정의되어 있지 않지만 JS 실행환경에서 제공하는 객체
- ECMAScript 사양에 정의된 객체이므로 JS 실행 환경과 관계 없이 언제나 사용 가능
- 전역 객체의 프로퍼티로서 제공 별도의 선언 없이 전역 변수처럼 언제나 참조 가능
-  Object, String, Number, Boolean, Symbol, Date, Math, RegExp, Array, Map/Set, WeakMap/WeakSet, Function, Promise, Reflect, Proxy, JSON, Error 등 40여 개

<br/>

2. 호스트 객체
- ECMAScript 사양에 정의되어 있지 않지만 JS 실행환경에서 제공하는 객체
- 브라우저 환경에서는 DOM, BOM, Canvas, XMLHTTPRequest, fetch 등과 같은 클라이언트 사이드 Web API를 호스트 객체로 제공

3. 사용자 정의 객체
- 기본 제공되는 객체가 아닌 사용자가 직접 정의한 객체

<br/>

## 표준 빌트인 객체
- Object, String, Number, Boolean, Symbol, Date, Math, RegExp, Array, Map/Set, WeakMap/WeakSet, Function, Promise, Reflect, Proxy, JSON, Error 등 40여 개
- Math, Reflect, JSON은 제외한 표준 빌트인 객체는 모두 인스턴스를 생성 가능한 생성자 함수 객체다.
- 프로토타입 메서드와 정적 메서드를 제공하고 생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메서드 제공

<br/>

### 표준 빌트인 객체는 생성자 함수로 호출하여 인스턴스 생성 가능
```
// String 생성자 함수에 의한 String 객체 생성
const strObj = new String('Lee');
console.log(strObj);        // [String: 'Lee']
console.log(typeof strObj); // object
 
// Number 생성자 함수에 의한 Number 객체 생성
const numObj = new Number(123);
console.log(numObj);        // [Number: 123]
console.log(typeof numObj); // object
 
// Boolean 생성자 함수에 의한 Boolean 객체 생성
const boolObj = new Boolean(true);
console.log(boolObj);        // [Boolean: true]
console.log(typeof boolObj); // object
 
// Function 생성자 함수에 의한 Function 객체(함수) 생성
const func = new Function('x', 'return x * x');
console.log(func);          // [Function: anonymous]
console.log(typeof func);   // function
 
// Array 생성자 함수에 의한 Array 객체(배열) 생성
const arr = new Array(1, 2, 3);
console.log(arr);           // [1, 2, 3]
console.log(typeof arr);    // object
 
// RegExp 생성자 함수에 의한 RegExp 객체(정규 표현식) 생성
const regExp = new RegExp(/ab+c/i);
console.log(regExp);        // /ab+c/i
console.log(typeof regExp); // object
 
// Date 생성자 함수에 의한 Date 객체 생성
const date = new Date();
console.log(date);          // 2023-03-16T07:40:05.958Z
console.log(typeof date);   // object
```
- 생성한 인스턴스의 프로토타입은 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체다.
- 인스턴스 없이 정적 메서드를 제공한다. 
```
const numObj = new Number(1.5);

// Number.prototype.toFixed로 Number.prototype 메서드
console.log(numObj.toFixed); 

// Number의 정적 메서드
console.log(Number.isInteger(0.5))
```

<br/>

## 원시값과 래퍼 객체
- 원시값은 객체가 아니지만 원시값인 숫자, 문자열, 불리언 값의 경우 원시값에 대해 객체처럼 마침표 표기법으로 접근하면 JS 엔진이 일시적으로 원시값을 연관된 객체로 변환해준다. 이때 생성되는 임시 객체를 ***래퍼 객체***라고 한다.
- 생성된 객체로 접근하거나 메서드 호출이 끝나면 다시 원시값으로 되돌린다.

```
const str = 'hi';

// 원시 타입인 문자열이 래퍼 객체인 String 인스턴스로 변환
console.log(str.length);
console.log(str.toUpperCase());

// 래퍼 객체로 프로퍼티에 접근, 메서드 호출 후 다시 원시값으로 되돌린다.
console.log(typeof str); // string
```
- 래퍼 객체 상태에서 String.prototype의 메서드를 상속받아 사용한다.
- 래퍼 객체의 처리가 종료되면 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값으로 식별자가 원시값을 갖도록 되돌리고 래퍼 객체는 가비지 컬렉션 대상이 된다. (숫자도 동일하지만 [[NumberData]] 내부 슬롯에 저장)
- 불리언 값도 동일하지만 메서드를 호출하는 경우가 없어 유용하지는 않다.
- 심벌도 래퍼 객체를 생성한다. 단, 리터럴 표기법으로는 생성할 수 없고 Symbol 함수로만 생성 가능
- String, Number 생성자 함수를 new 연산자와 함께 호출하여 문자열, 숫자 등 인스턴스를 사용할 필요가 없고 권장 X
- null과 undefiend는 래퍼 객체를 생성하지 않는다. -> 객체처럼 사용하면 에러 발생

<br/>

## 전역 객체
- 코드 실행 이전 단계에 JS 엔진이 어떤 객체보다도 먼저 생성하는 특수 객체이자 최상위 객체
- 브라우저 환경에서는 window, Node.js 환경에서는 global
- 표준 빌트인 객체와 환경에 따른 호스트 객체(클라이언트 Web API or Node.js의 호스트 API) 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.
- 계층적 구조상 표준 빌트인 객체와 호스트 객체를 프로퍼티로 소유

<br/>

#### 전역 객체의 특징
- 개발자가 의도적으로 생성 불가, 전역 객체 생성 함수가 제공되지 않는다.
- 전역 객체의 프로퍼티를 참조할 때 window 생략 가능

<br/>

### 빌트인 전역 프로퍼티
1. Infinity
- Infinity 프로퍼티는 무한대를 나타내는 숫자값 Infinity를 갖는다.

2. NaN
- NaN 프로퍼티는 숫자가 아님을 나타내는 숫자값 NaN을 갖는다. 
- Number.NaN 프로퍼티와 같다.

3. undefined
- undefined 프로퍼티는 원시 타입 undefined를 값으로 갖는다.

<br/>

### 빌트인 전역 함수
- 애플리케이션 전역에서 호출 가능한 빌트인 함수로서 전역 객체의 메서드

1. eval
- 문자열을 인수로 받아 코드가 표현식이라면 eval 함수는 런타임에 평가하여 값을 생성하고 표현식이 아닌 문이라면 런타임에 실행한다. 문자열 코드가 여러 개의 문이라면 모든 문 실행
- 자신이 호출된 위치에 해당하는 기존 스코프를 런타임에 동적 수정

```
const x = 1;
function foo() {
	// eval 함수는 런타임에 foo 함수의 스코프를 동적으로 수정한다.
    eval('var x = 2;');
    console.log(x); // 2
}

foo();
console.log(x); // 1
```
- 새로운 변수 x를 foo 함수의 스코프에 선언된 x 변수를 동적으로 추가한다. 함수가 호출되면 런타임 이전에 먼저 함수 몸체 내부의 모든 선언문을 먼저 실행하고 그 결과를 스코프에 등록 -> eval 함수가 호출되는 시점에 이미 foo 함수의 스코프가 존재
- strict mode에서 eval 함수는 기존 스코프를 수정하지 않고 eval 함수 자신의 자체적인 스코프 생성

```
const x = 1;
function foo() {
	'use strict';
    
	// eval 함수는 런타임에 foo 함수의 스코프를 동적으로 수정한다.
    eval('var x = 2; console.log(x);'); // 2
    console.log(x); // 1
}

foo();
console.log(x); // 1
```
- 인수로 전달받은 문자열 코드가 let, const 키워드를 사용한 변수 선언문이라면 암묵적으로 strict  mode 적용
- eval 함수를 통해 사용자로부터 입력받은 콘텐츠는 보안에 매우 취약하고 JS 엔진에 의해 최적화 수행이 되지 않아 처리 속도가 느리다 -> 사용 금지

<br/>

2. isFinite
- 전달받은 인수가 정상적인 유한수인지 검사 유한수라면 true 무한수라면 false
- 전달받은 인수가 숫자가 아닌 경우 숫자 타입을 변환후 검사 실행 이때 인수가 NaN으로 평가되는 값이면 false 반환 (null을 숫자타입으로 변환 시 0)

3. isNaN
- 전달받은 인수가 NaN인지 검사하고 그 결과를 불리언 타입으로 반환 숫자가 아닌경우 숫자로 변환 후 반환

4. parseFloat
- 전달받은 문자열 인수를 부동 소수점 숫자, 즉 실수로 해석하여 반환

```
parseFloat('3.14'); // 3.14
parseFloat('10.00'); // 10
```

5. parseInt
- 전달받은 문자열 인수를 정수로 해석하여 반환
- 두 번째 인수로 진법을 나타내는 기수 (2~36) 전달 가능 기수 지정 시 첫 번째 인수로 전달된 문자열을 해당 기수의 숫자로 해석하여 반환 단, 반환값은 언제나 10진수이고 기수 생략 시 10진수로 해석 반환
- 두 번째 인수 없이 첫 번째 인수 문자열이 "0x" or "0X"일 경우 자동으로 16진수로 해석
- 첫 번째 인수로 전달한 문자열의 두 번째 문자부터 해당 진수를 나타내는 숫자가 아닌 문자일 경우 이 문자와 계속되는 문자를 전부 무시하고 정수값만 반환
- 첫 번째 인수로 전달한 문자열에 공백이 있다면 첫 번째 문자열만 해석하여 반환(앞뒤 공백 무시) 단, 첫 번째 문자열을 숫자로 해석 불가능한 경우 NaN 반환

```
parseInt('10'); // 10
parseInt('10.123'); // 10

parseInt('10', 2); // 2
parseInt('10', 8); // 8

parseInt('0xf'); // 15
parseInt('f', 16); // 15

parseInt('1A0'); // 1
// 2진수로 해석할 수 없는 '2' 이후의 문자 모두 무시
parseInt('102'); // 2

parseInt(' 34 45 66'); // 34
parseInt('He was 40'); // NaN
```

- 기수를 지정하여 10진수 숫자를 해당 기수의 문자열로 변환 및 반환하고 싶다면 Number.prototype.toString 사용하기

```
const x = 15;

// 10진수 15를 2진수로 반환
x.toString(2); // '1111'
x.toString();  // '15'
```

<br/>

### encodeURI / decodeURI
- 완전한 URI를 문자열로 전달받아 이스케이프 처리를 위해 인코딩
- URI는 인턴넷에 있는 자원을 나타내는 유일한 주소

![](https://velog.velcdn.com/images/mintmin0320/post/3c0ae552-264c-465e-8ff9-f90d97b63ac6/image.png)

- 인코딩: URI 문자들을 이스케이프 처리하는 것, 이스케이프 처리는 네트워크를 통해 정보를 공유할 때 어떤 시스템에서도 읽을 수 있는 아스키 문자 셋으로 변환하는 것
- UTF-8 특수 문자의 경우 1문자당 1~3바이트 UTF-8 한글 표현의 경우 1문자당 3바이트 (ex 공백 문자는 %20, '가'는 %EC%9E%90으로 인코딩)
- 한글을 포함한 대부분의 외국어나 아스키 문자 셋에 정의되지 않는 특수 문자의 경우 URL에 포함 X, 따라서 URL 내부에 의미를 갖는 문자(%, ?, #)나 URL에 들어 올 수 없는 문자(한글, 공백 등) 또는 시스템에 의해 해석될 수 있는 문자(<,>)를 이스케이프 처리하여 문제를 예방하기 위해 이스케이프 처리가 필요하다.
- 단, 알파벳, 0~9, -_.!~*'() 문자는 이스케이프 처리에서 제외


```
const uri = 'https://mozilla.org/?x=шеллы';
const encoded = encodeURI(uri);
console.log(encoded);
// output: "https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B"

try {
  console.log(decodeURI(encoded));  // output: "https://mozilla.org/?x=шеллы"
} catch (e) {
  console.error(e);
}
```

- deCodeURI 함수는 인코딩된 URI를 인수로 전달받아 이스케이프 처리 이전으로 디코딩

<br/>

### encodeURIComponet / decodeURIComponent
- encodeURIComponet 함수는 URI 구성 요소를 인수로 전달받아 인코딩
- encodeURIComponet 함수는 인수로 전달된 문자열을 URI의 구성요소인 쿼리 스트링의 일부로 간주 따라서 쿼리 스트링 구분자로 사용되는 =, ?, &까지 인코딩

- decodeURIComponent 함수는 매개변수로 전달된 URI 구성 요소를 디코딩
- decodeURIComponent 함수는 매개변수로 전달된 문자열을 완전한 URI 전체라고 간주하고 쿼리 스트링 구분자로 사용되는 =, ?, &은 인코딩 X

<br/>

### 암묵적 전역

```
var x = 10;

function foo () {
	y = 20;
}
foo();

// 선언하지 않은 식별자 y를 전역에서 참조
console.log(x + y); // 30
```

- 선언하지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티가 된다.
- foo 함수가 호출되면 JS 엔진이 y 변수에 값 할당을 위해 스코프 체인을 통해 선언된 변수인지 확인하고 스코프 어디에서도 y를 찾지 못하면 참조에러가 발생해야 하지만, JS 엔진은 y = 20을 window.y = 20으로 해석하여 전역 객체에 프로퍼티에 동적 생성한다. y는 전역 객체의 프로퍼티가 되어 전역 변수처럼 동작하는 것을 ***암묵적 전역***이라고 한다.
- y는 변수 선언 없이 단지 전역 객체의 프로퍼티로 추가되었을 뿐 변수가 아니기 때문에 호이스팅 발생 x
- 변수가 아닌 프로퍼티인 y는 delete 연산자로 삭제 가능, 전역 변수는 프로퍼티이지만 delete 연산자로 삭제 불가

<br/><br/>

<br/><br/>
