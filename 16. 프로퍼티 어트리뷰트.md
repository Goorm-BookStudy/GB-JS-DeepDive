# 16장 프로퍼티 어트리뷰트

# 16.1 내부 슬롯과 내부 메서드

- 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메서드.
- ECMAScript 사양의 이중 대괄호[[]]로 감싼 이름들
- ECMAScript사양에 정의된 대로 구현되어 자바스크립트 엔진에서 실제로 동작하지만 개발자가 직접 접근할 수 있도록 외부로 공개된 객체의 프로퍼티는 아님. 자바스크립트 엔진의 내부 로직이기에 원칙적으로 직접적으로 접근하거나 호출할 수 있는 방법 제공x. 일부에 한해 간접적으로 접근 수단 제공
    - 모든 객체는 [[Prototype]] 내부슬롯 갖고 이는 __proto__를 통해 간접적으로 접근 가능

```jsx
const o = {};
o.[[Prototype]] // 불가능
o.__proto__; // Object.prototype
```

# 16.2 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

- 자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의
    - 프로퍼티 상태: 프로퍼티의 값(value), 값의 갱신 가능 여부(writable), 열거 가능 여부(enumerable), 재정의 가능 여부(configurable)
    - 프로퍼티 어트리뷰트: 자바스크립트 엔진이 관리하는 내부 상태 값인 내부 슬롯 [[Value]], [[Writable]], [[Enumerable]], [[Configurable]]이다.
- 프로퍼티 어트리뷰트에 직접 접근할 수 없지만 Object.getOwnPropertyDescriptor 메서드를 사용해 간접적으로 확인 가능
    - 객체의 참조와 프로퍼티 키(문자열) 전달, 프로퍼티 디스크립터(프로퍼티 어트리뷰트 정보 제공) 객체 반환. 존재하지 않는 프로퍼티나 상속받은 프로퍼티에 대한 프로퍼티 디스크립터 요구 시 undefined 반환
- getOwnPropertyDescriptors: 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체들 반환

```jsx
const person = {
	name: 'Lee'
};
person.age = 20;

console.log(Object.getOwnPropertyDescriptor(person, 'name'));
// {value: "Lee", writable: true, enumerable: true, configurable: true}
console.log(Object.getOwnPropertyDescriptors(person));
/*
{
	name: {value: "Lee", writable: true, enumerable: true, configurable: true},
	age: {value: 20, writable: true, enumerable: true, configurable: true}	
}
*/
```

# 16.3 데이터 프로퍼티와 접근자 프로퍼티

- 프로퍼티는 데이터 프로퍼티와 접근자 프로퍼티로 구분
    - 데이터 프로퍼티: 키와 값으로 구성된 일반적인 프로퍼티
    - 접근자 프로퍼티: 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티

## 1) 데이터 프로퍼티

- 다음과 같은 프로퍼티 어트리뷰트는 자바스크립트 엔진이 프로퍼티를 생성할 때 기본값으로 자동 정의

| 프로퍼티 어트리뷰트 | 프로퍼티 디스크립터 객체의 프로퍼티 | 설명 |
| --- | --- | --- |
| [[Value]] | value | - 프로퍼티 키를 통해 프로퍼티 값에 접근 시 반환되는 값. 
- 값 변경 시 [[Value]]에 값 재할당. 
- 프로퍼티 없으면 프로퍼티 동적 생성 후 생성된 프로퍼티의 [[Value]]에 값 저장 |
| [[Writable]] | writable | - 프로퍼티 값의 변경 가능 여부. 불리언 값
- false 인 경우 [[Value]]의 값을 변경할 수 없는 읽기 전용 프로퍼티 |
| [[Enumerable]] | enumerable | - 프로퍼티의 열겨 가능 여부. 불리언 값
- false인 경우 for…in문, Object.keys 메서드 등으로 열거 불가능 |
| [[Configurable]] | configurable | - 프로퍼티 재정의 가능 여부. 불리언 값
- false 인 경우 해당 프로퍼티의 삭제, 프로퍼티 어트리뷰트 값 변경 금지
- 단, [[Writable]]이 true 인 경우 [[Value]]의 변경 및 [[Writable]]을 false로 변경은 허용 |
- 프로퍼티 생성 시 [[Value]]값은 프로퍼티 값으로 초기화, 나머지는 true로 초기화. 프로퍼티 동적 추가도 동일

## 2) 접근자 프로퍼티

- 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장 시 사용하는 접근자 함수로 구성된 프로퍼티

| 프로퍼티 어트리뷰트 | 프로퍼티 디스크립터 객체의 프로퍼티 | 설명 |
| --- | --- | --- |
| [[Get]] | get | 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수.
접근자 프로퍼티 키로 프로퍼티 값 접근 시 프로퍼티 어트리뷰트 [[Get]]의 값인 getter 함수 호출, 그 결과가 프로퍼티 값으로 반환 |
| [[Set]] | set | 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수.
접근자 프로퍼티 키로 프로퍼티 값 저장 시 프로퍼티 어트리뷰트 [[]Set]의 값인 setter 함수 호출, 그 결과가 프로퍼티 값으로 저장 |
| [[Enumerable]] | enumerable | 데이터 프로퍼티와 동일 |
| [[Configurable]] | configurable | .. |
- 접근자 함수는 getter / setter 함수라고도 부른다. 둘 다 정의할 수 있고 하나만 정의할 수도 있다.

```jsx
const person = {
	// 데이터 프로퍼티
	firstName: 'Ungmo',
	lastName: 'Lee',

	// fullName은 접근자 함수로 구성된 접근자 프로퍼티이다.
	get fullName() { // getter 함수
		return `${this.firstName} ${this.lastName}`;
	},
	set fullName(name) { // setter 함수
		[this.firstName, this.lastName] = name.split(' ');
	}
};
// 데이터 프로퍼티를 통한 프로퍼티 값의 참조
console.log(person.firstName + ' ' + person.lastName); // Ungmo Lee

// 접근자 프로퍼티를 통한 프로퍼티 값의 저장 - 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.
person.fullName = 'Heegun Lee';

// 접근자 프로퍼티를 통한 프로퍼티 값의 참조 - 접근자 프로퍼티 fullName에 값을 저장하면 getter 함수가 호출된다.
console.log(person.fullName); // Heegun Lee

let descriptor = Object.getOwnPropertyDescriptor(person, 'firstName');
console.log(descriptor); // 데이터 프로퍼티
// { value: "Heegun", writable: true, enumerable: true, configurable: true }

descriptor = Object.getOwnPropertyDescriptor(person, 'fullName');
console.log(descriptor); // 접근자 프로퍼티
// { get: f, set: f, enumerable: true, configurable: true }
```

- 데이터 프로퍼티와 접근자 프로퍼티는 프로퍼티 디스크립터 객체가 다르기에 이를 통해 구분

# 16.4 프로퍼티 정의

- 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정희하는 것
- 객체의 프로퍼티가 어떻게 동작해야 하는지 명확히 정의 가능
- Object.defineProperty 메서드 - 프로퍼티의 어트리뷰트 정의. 객체의 참조 및 데이터 프로퍼티의 키인 문자열, 프로퍼티 디스크립터 객체 전달

```jsx
const person = {};

// 데이터 프로퍼티 정의
Object.defineProperty(person, 'firstName', {
	value: 'Ungmo',
	writable: true,
	enumerable: true,
	configurable: ture
});

Object.defineProperty(person, 'lastName', {
	value: 'Lee'
});

let descriptor = Object.getOwnpropertyDescriptor(person, 'firstName');
console.log(descriptor);
// firstName {value: 'Ungmo', writable: true, enumerable: true, configurable: true}

// 디스크립터 객체의 프로퍼티 누락 시 undefined, false 기본값
descriptor = Object.getOwnPropertyDescriptor(person, 'lastName');
console.log(descriptor);
// firstName {value: 'Lee', writable: false, enumerable: false, configurable: false}

// [[Enumerable]] false -> for ... in, Object.keys 등으로 열거 불가능
console.log(Object.keys(person)); // ['firstName']

// [[Writable]] false -> 프로퍼티의 [[Value]]값 변경 불가능, 에러 없이 무시
person.lastName = 'Kim';

// [[Configurable]] false -> 프로퍼티 삭제 불가능, 에러 없이 무시 / 프로퍼티 재정의 불가능
delete person.lastName; 

// 접근자 프로퍼티 정의
Object.defineProperty(person, 'fullName', {
	// getter 함수
	get() {
		return `${this.firstName} ${this.lastName}`;
	},
	// setter 함수
	set(name) {
		[this.firstName, this.lastName] = name.split(' ');
	},
	enumerable: true,
	configurable: true
});

descriptor = Object.getOwnPropertyDescriptor(person, 'fullName');
console.log('fullName', descriptor);
// fullName {get: f, set: f, enumerable: true, configurable: true}

person.fullName = 'Heegun Lee';
console.log(person); // {firstName: 'Heegun', lastName: 'Lee'}
```

- 프로퍼티 디스크립터 객체의 프로퍼티 일부 생략 시 아래와 같은 기본값 적용

| 프로퍼티 디스크립터 객체의 프로퍼티 | 대응하는 프로퍼티 어트리뷰트 | 생략했을 때의 기본값 |
| --- | --- | --- |
| value | [[Value]] | undefined |
| get | [[Get]] | undefined |
| set | [[Set]] | undefined |
| writable | [[Writable]] | false |
| enumerable | [[Enumerable]] | false |
| configurable | [[Configurable]] | false |
- Object.definedProperty → 하나의 프로퍼티만 정의 가능 / Object.defineProperties → 여러개 ㄱㄴ

# 16.5 객체 변경 방지

- 객체는 변경 가능한 값. 재할당 없이 직접 변경 가능 → 객체 변경 방지하는 다양한 메서드 제공. 금지 강도 다름

| 구분 | 메서드 | 프로퍼티 추가 | 프로퍼티 삭제 | 프로퍼티 값 읽기 | 프로퍼티 값 쓰기 | 프로퍼티 어트리뷰트 재정의 |
| --- | --- | --- | --- | --- | --- | --- |
| 객체 확장 금지 | Object.preventExtensions | X | O | O | O | O |
| 객체 밀봉 | Object.seal | X | X | O | O | X |
| 객체 동결 | Object.freeze | X | X | O | X | X |

## 1) 객체 확장 금지

- Object.preventExtensions - 객체의 확장 금지(프로퍼티 추가 금지)
- 프로퍼티 동적 추가, defineProperty 메서드 둘 다 금지
- Object.isExtensible 메서드로 확장 가능 객체인지 확인 가능

## 2) 객체 밀봉

- Object.seal - 프로퍼티 추가 및 삭제, 프로퍼티 어트리뷰트 재정의 금지. 밀봉된 객체는 읽기와 쓰기만 가능
- Object.isSealed 메서드로 밀봉된 객체 여부 확인 가능

## 3) 객체 동결

- Object.freeze - 프로퍼티 추가 및 삭제, 프로퍼티 어트리뷰트 재정의 금지, 프로퍼티 값 갱신 금지. 읽기만 가능
- Object.isFrozen메서드로 동결된 객체 여부 확인 가능

## 4) 불변 객체

- 위의 변경 방지 메서드들은 얕은 변경 방지(직속 프로퍼티만 변경 방지, 중첩 객체 영향 x)
- Object.freeze 메서드로 객체 동결해도 중첩 객체까지 동결 불가능
- 객체의 중첩 객체까지 동결해 변경이 불가능한 읽기 전용의 불변객체를 구현하려면 객체를 값으로 갖는 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메서드를 호출해야 한다.