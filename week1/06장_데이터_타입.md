# ✏️ 6장. 데이터 타입

JS의 모든 값은 데이터 타입을 갖는다.
JS는 8개의 데이터 타입을 갖고 있으며, 원시 타입과 객체 타입으로 분류된다.

원시 타입(immutable한 값으로 한 번 생성하면 값을 변경할 수 없고, 새로운 값을 생성해야 함)

- number: 숫자, 정수/실수 구분 없이 하나의 숫자 타입만 존재
- int: number가 나타낼 수 있는 숫자 범위 (2^53-1 ~ -2^53-1) 바깥의 수로 맨 끝에 n을 붙여 사용
- string: 문자열
- boolean: true/false
- undefined: var 키워드로 선언된 변수에 암묵적으로 할당되는 값
- null: 값이 없음을 의도적으로 명시할 때 사용되는 값
- symbol: 변경 불가능한 원시의 값으로 다른 값과 중복되지 않는 유일무이한 값

객체 타입(mutable한 값으로 내용을 수정하거나 추가할 수 있음)

- 객체, 함수, 배열 등

### 📌 6.1 숫자 타입

- JS는 정수와 실수를 구분하지 않고 모든 수를 실수로 처리하며, 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않고 하나의 숫자 타입만 사용한다.
- JS는 배정밀도 64비트 부동소수점 형식을 따른다.

```
console.log(1 === 1.0) // true
console.log(4 / 2) // 2
console.log(3 / 2) // 1.5
```

// 수정 예정

1. 배정밀도: 부동소수점 숫자를 표현하는 형식 중 하나로 보통 64비트를 사용한다. 부호 비트/지수/가수 부분으로 구성됨. 높은 정밀도를 위해 더 많은 비트를 사용한다. 반대 개념으로는 단정밀도가 있으며, 구성 요소는 동일하나 보통 32비트를 사용해 배정밀도보다 더 작은 범위, 더 큰 간격으로 값을 표현한다. 대신 메모리 사용량이 적고 연산 속도가 빨라 배정밀도와 단정밀도는 정밀도/메모리 사용량 사이의 트레이드 오프 관계를 나타내는 부동소수점 형식이다.
2. 부동소수점: 컴퓨터가 실수를 표현하는 방식 중 하나. 소수점을 고정된 위치가 아니라 '부동'하게 표현한다. 정수 부분과 소수 부분을 나누어 표현한다. JS는 64비트 부동소수점 형식을 따르기 때문에 부호 비트(0 or 1: 1비트), 지수(실수의 크기와 위치, 2진수로 나타냄: 11비트), 가수(소수점 부분을 2진수로 나타냄: 52비트)로 구성되어 있다.

- 정수, 실수, 2진수, 8진수, 16진수 리터럴 모두 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장되며 2진수, 8진수, 16진수를 표현할 데이터 타입이 없기에 이 값들을 참조하면 모두 10진수로 해석된다

```
var binary = 0b01000001;
var octal = 0o101;
var hex = 0x41;

console.log(binary) // 65
console.log(octal) // 65
console.log(hex) // 65
```

- 양의 무한대(infinity), 음의 무한대(-infinity), 산술 연산 불가(NaN: Not a Number)도 있다.
  (console에서 +0과 -0을 비교하면 같다고 하지만, Object.is로 엄격하게 비교하면 false가 나온다.)

```
console.log(10 / 0) // infinity
console.log(10 / -0) // -infinity
console.log(1 * 'string') // NaN
```

### 📌 6.2 문자열 타입

- 문자열은 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합으로 전 세계 대부분의 문자를 표현한다.
- 문자열은 "", '', ``으로 텍스트를 감싼다. 감싸지 않으면 JS 엔진은 키워드나 식별자 같은 토큰으로 인식하기 때문이다.

```
var string;
string = '안녕"하"세요' // 안녕"하"세요
string = "안녕'하'세요" // 안녕'하'세요
```

### 📌 6.3 템플릿 리터럴

- 런타임 시 일반 문자열로 변환되어 처리된다.
- 백틱을 이용해 편리한 문자열 처리 기능을 제공한다.
- 일반 문자열에서는 줄바꿈이나 백슬래시 등을 사용할 수 없어 이스케이프 시퀀스를 써야 했는데, 템플릿 리터럴을 사용하면 보다 간단하게 사용할 수 있다.

```
var template = '<ul>\n\t<li><a href="#">Home</a></li>\n<\ul>'
console.log(template)
// <ul>
//  <li><a href="#">Home</a></li>
// </ul>

var template = `<ul>\n\t<li><a href="#">Home</a></li>\n<\ul>`
console.log(template)
// <ul>
//  <li><a href="#">Home</a></li>
// </ul>
```

- 문자열 연산자 +와 공백을 사용해 문자열을 연결하거나 표현해야 할 때에도 표현식을 ${}로 감싸 표현할 수 있다.

```
var first = 'summer'
var second = 'mong'
console.log('My name is ' + first + second + '.') // My name is summermong.
console.log(`My name is ${first}${second}.`) // My name is summermong.
```

### 📌 6.4 불리언 타입

- 논리적 참과 거짓을 나타내는 true, false
- 주로 프로그램의 흐름을 제어하는 조건문에서 자주 사용된다.

```
let foo = true;
console.log(foo) // true;

foo = false;
console.log(foo) // false
```

### 📌 6.5 undefined 타입

- var 키워드로 선언한 변수는 처음 선언해 확보한 메모리 공간에 할당이 이뤄질 때까지 undefined로 초기화한다. 따라서 변수를 선언한 후 값을 할당하지 않으면 그 변수를 참조할 때 undefined가 반환된다.
- JS 엔진이 변수를 초기화 할 때 사용하는 값이므로 개발자가 의도적으로 사용하는 것은 취지에 맞지 않고 혼란을 야기할 수 있다.
- 값이 없다는 것을 명시하고 싶을 떄는 아래의 null 타입을 사용한다.

### 📌 6.6 null 타입

- 변수에 값이 없다는 것을 의도적으로 명시한다.
- 변수에 null을 할당한다는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미로, 이전에 할당되어 있던 값에 대한 참조를 제거하며 JS 엔진이 가비지 콜렉션을 수행한다.
- 유효한 값을 반화할 수 없는 경우에도 명시적으로 null을 반환한다. (ex. document.querySelector 메서드에서 조건에 부합하는 HTML 요소를 찾지 못한 경우 에러 대신 null을 반환)

### 📌 6.7 symbol 타입

- ES6에 추가된 7번째 타입으로 변경 불가능한 원시 타입의 값이다.
- 다른 값과 중복되지 않는 유일한 값이라 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키로 사용된다.
- Symbol 함수를 호출해 생성하며 값은 외부에 노출되지 않고, 다른 값과도 중복되지 않는다.

```
var key = Symbol('key');
console.log(typeof key) // symbol

var obj = {};
obj[key] = 'value';
console.log(obj[key]) // value
```

### 📌 6.8 객체 타입

- 추후 기술

### 📌 6.9 데이터 타입의 필요성

- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
  - 숫자 100을 저장하기 위해 8바이트의 메모리 공간을 확보해야 함
  - 문자열 100을 저장하기 위해 2바이트의 메모리 공간을 확보해야 함
  - 이처럼 타입에 따라 확보해야 하는 메모리 공간이 다르다.
- 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
  - 숫자 타입이 8바이트이므로 한번 참조할 때 8바이트 단위를 참조해야 한다. 그렇지 않으면 값이 훼손된다.
- 메모리에서 읽어들인 2진수를 어떻게 해석할지 결정하기 위해
  - 메모리에서 읽어들인 2진수가 0100 0001일 때 숫자로 해석하면 65지만 문자열로 해석하면 'A'가 된다.
  - 이런 경우 해당 메모리를 가진 변수에 할당된 값의 타입이 숫자라면 이 2진수를 숫자로 해석해 65로 반환된다.

### 📌 6.10 동적 타이핑

- C, Java와 같은 정적 타입 언어는 변수를 선언할 때 변수에 할당할 수 있는 데이터 타입을 사전에 선언해야 한다(명시적 타입 선언).
  - char c 에는 1바이트 정수 타입의 값(-128 ~ 127)만, int num 에는 4바이트 정수 타입의 값만 할당할 수 있다.
  - 변수의 타입을 변경할 수 없고, 변수의 타입에 맞는 값만 할당할 수 있다.
  - 타입의 일관성이 강제되기 때문에 유동적이진 않지만 안전하고 에러 발생을 줄일 수 있다.
- JS는 동적 타입 언어로 var, let, const 키워드로 변수를 선언한다.
  - 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있다.
  - JS의 변수는 할당에 의해 타입이 결정된다. (할당하는 값이 숫자인지 문자열인지)
  - 재할당에 의해 타입이 동적으로 변할 수 있다. (동적 타이핑)
  - JS는 변수의 타입이 고정되어 있지 않고 동적으로 변할 수 있으며, JS 엔진에 의해 암묵적으로 타입이 변환되기도 하는 경우가 있어 동적 타입 언어에 비해 유연하지만 신뢰성이 떨어진다.

결론은 '변수'는 타입을 갖지 않는다.
변수에 할당된 '값'이 타입을 가진다.
할당된 값에 의해 변수의 타입이 동적으로 결정된다.
