# ✏️ 39장 DOM

## 📌 39.4 노드 정보 취득 (p.709 참고)

- Node.prototype.nodeType: 노드 타입을 나타내는 상수를 반환한다.
  - Node.ELEMENT_NODE: 요소 노드 타입을 나타내는 상수 1 반환
  - Node.TEXT_NODE: 텍스트 노드 타입을 타나내는 상수 3 반환
  - Node.DOCUMENT_NODE: 문서 노드 타입을 나타내는 상수 9 반환
- Node.prototype.nodeName: 노드 이름을 문자열로 반환한다.
  - 요소 노드: 대문자 문자열로 태그 이름 등을 반환
  - 텍스트 노드: 문자열 "#text"를 반환
  - 문서 노드: 문자열 "#document"를 반환

## 📌 39.5 요소 노드의 텍스트 조작

##### 1. nodeValue

- setter, getter 모두 존재하는 접근자 프로퍼티로 참조와 할당 모두 가능
- 노드 객체의 nodeValue 프로퍼티를 참조하면 노드 객체의 값 반환
- 노드 객체의 값: 텍스트 노드의 텍스트로 이외의 경우 null 반환
- 값을 할당하면 텍스트를 변경할 수 있다.
  - 텍스트를 변경할 요소 노드 취득 후 취득한 요소 노드의 텍스트 노드 탐색 (firstChild 사용)
  - 탐색한 텍스트 노드의 nodeValue 프로퍼티로 텍스트 노드의 값 변경

```
<!DOCTYPE html>
<html>
  <body>
    <div id="foo">Hello</div>
  </body>
  <script>
    // 1. #foo 요소 노드의 자식 노드인 텍스트 노드를 취득한다.
    const $textNode = document.getElementById("foo").firstChild;

    // 2. nodeValue 프로퍼티를 사용하여 텍스트 노드의 값을 변경한다.
    $textNode.nodeValue = "World";

    console.log($textNode.nodeValue); // World
  </script>
</html>
```

##### 2. textContent

- setter, getter 모두 존재하는 접그자 프로퍼티
- 요소 노드의 텍스트와 모든 자손 노드의 텍스트를 모두 취득하거나 변경
- 요소 노드의 textContent 참조 시 요소 노드의 콘텐츠 영역(시작 태그 ~ 종료 태그) 내의 텍스트를 모두 반환

```
<!DOCTYPE html>
<html>
  <body>
    <div id="foo">Hello <span>world!</span></div>
  </body>
  <script>
    // #foo 요소 노드의 텍스트를 모두 취득한다. 이때 HTML 마크업은 무시된다.
    console.log(document.getElementById("foo").textContent); // Hello world!
  </script>
</html>
```

- 요소 노드의 textContent 프로퍼티에 문자열을 할당하면 할당한 문자열이 텍스트로 추가됨
- 마크업이 포함되어 있어도 문자열 그대로 인식된다.
  - 유사한 동작을 하는 innerText 프로퍼티가 있다.
  - CSS에 순종적이며(visibility: hidden인 요소 노드의 텍스트는 반환 X) textContent 프로퍼티보다 느리므로 지양해야 한다.

## 📌 39.6 DOM 조작

- 새로운 노드를 생성해 DOM에 추가하거나 기존 노드의 삭제, 교체하는 것
- 리플로우와 리페인트가 발생하여 성능에 영향을 준다.
- 따라서 성능 최적화를 위해 주의해서 다뤄야 한다.

#### 1. innerHTML

- setter, getter 모두 존재하는 접근자 프로퍼티
- 요소 노드의 HTML 마크업을 취득하거나 변경한다.
- 요소 노드의 콘텐츠 영역(시작 태그 ~ 종료 태그) 내의 모든 HTML 마크업을 문자열로 반환한다.
- textContent 프로퍼티는 HTML 마크업을 무시하고 텍스트만 반환하지만 innerHTML 프로퍼티는 마크업이 포함된 문자열 그대로 반환한다.
- innerHTML 프로퍼티에 문자열을 할당하면 요소 노드의 모든 자식 노드가 제거되고, 할당한 문자열에 포함된 HTML 마크업이 파싱돼 요소 노드의 자식 노드로 DOM에 반영된다.
- 주의점 1
  - innerHTML 프로퍼티에 할당한 HTML 마크업 문자열은 렌더링 엔진에 의해 파싱되어 요소 노드의 자식으로 DOM에 반영된다.
  - 사용자로부터 입력받은 데이터를 그대로 할당하는 것은 XSS(Cross-Site Scripting Attacks)에 취약하므로 위험하다. (파싱 과정에서 그대로 악성 코드가 실행될 가능성)
  - HTML 새니티제이션으로 위험 요소가 있는 HTML 마크업을 살균할 수 있다.
- 주의점 2
  - 해당 프로퍼티에 HTML 마크업 문자열 할당 시 요소 노드의 모든 자식 노드를 제거하고 DOM을 변경한다.
  - 이는 효율적이지 않은 경우를 야기한다.
- 주의점 3
  - 새로운 요소를 삽입할 때 삽입될 위치를 지정할 수 없다.

#### 2. insertAdjacentHTML 메서드

- Element.prototype.insertAdjacentHTML(position, DOMString)
- 기존 요소를 제거하지 않으면서 위치를 지정해 새로운 요소를 삽입한다.
- 2번째 인수로 전달한 HTML 마크업 문자열을 파싱한다. (DOMString)
- 그 결과로 생성된 노드를 첫 번째 인수로 전달할 위치에 삽입해 (position) DOM에 반영한다.
- 첫 번째 인수로 전달할 수 있는 문자열은 아래 4가지다.

```
<!DOCTYPE html>
<html>
  <body>
    <!-- beforebegin -->
    <div id="foo">
      <!--afterbegin -->
      text
      <!--beforeend-->
    </div>
    <!--afterend-->
  </body>
  <script>
    const $foo = document.getElementById('foo');

    $foo.insertAdjacentHTML('beforebegin', '<p>beforebegin</p>');
    $foo.insertAdjacentHTML('afterbegin', '<p>afterbegin</p>');
    $foo.insertAdjacentHTML('beforeend', '<p>beforeend</p>');
    $foo.insertAdjacentHTML('afterend', '<p>afterend</p>');
  </script>
</html>
```

- innerHTML 프로퍼티보다 효율적이고 빠르지만 XSS에 취약한 점은 동일하다.

#### 3. 노드 생성과 추가

##### 요소 노드 생성

- Document.prototype.createElement(tagName) 메서드: 요소 노드를 생성 후 반환
- 요소 노드를 생성할 뿐 DOM에 추가하지는 않는다.
- 따라서 이후 DOM에 추가하는 별도 처리가 필요하다.

##### 텍스트 노드 생성

- Document.prototype.createTextNode(text) 메서드: 텍스트 노드를 생성 후 반환
- 요소 노드의 자식 노드지만 자식 노드로 추가되지 않고 홀로 존재하는 상태
- DOM에 추가하는 별도 처리가 필요하다.

##### 텍스트 노드를 요소 노드의 자식 노드로 추가

- Node.prototype.appendChild(childNode) 메서드: 매개변수 childNode에게 인수로 전달할 노드를 appendChild 메서드를 호출한 노드의 마지막 자식 노드로 추가
- 이로써 요소 노드와 텍스트 노드가 부모-자식 관계가 되었지만 아직 DOM에 추가하는 별도 처리가 필요하다.

##### 요소를 DOM에 추가

- Node.prototype.appendChild 메서드로 요소 노드를 다른 요소 노드의 마지막 자식 요소로 추가한다.
- 이 과정에서 비로소 생성한 요소 노드가 DOM에 추가된다.
- 이로써 DOM이 변경되면서 리플로우와 리페인트가 실행된다.

```
<!DOCTYPE html>
<html>
  <body>
    <ul id="fruits">
      <li>Apple</li>
    </ul>
  </body>
  <script>
    const $fruits = document.getElementById("fruits");

    // 1. 요소 노드 생성
    const $li = document.createElement("li");

    // 2. 텍스트 노드 생성
    const textNode = document.createTextNode("Banana");

    // 3. 텍스트 노드를 $li 요소 노드의 자식 노드로 추가
    $li.appendChild(textNode);

    // 4. $li 요소 노드를 #fruits 요소 노드의 마지막 자식 노드로 추가
    $fruits.appendChild($li);
  </script>
</html>
```

#### 4. 복수의 노드 생성과 추가

- 컨테이너 요소 사용으로 DOM 변경을 최소화할 수 있다. (p.724 참고)
- 성능에는 유리하지만 불필요한 컨테이너 요소가 DOM에 추가되는 부작용이 있다.
- DocumentFragment 노드로 해결할 수 있다.
  - 노드 객체의 일종으로 부모 노드가 없어 기존 DOM과는 별도로 존재한다.
  - 자식 노드들의 부모 노드로서 서브 DOM을 구성해 기존 DOM에 추가하는 용도로 사용됨
  - DOM 변경이 일어나는 것은 1번 뿐이기에 성능에 더 효율적이다.

```
const $fruits = document.getElementById('fruits');
const $fragment = document.createDocumentFragment();
['Apple', 'Banana', 'Orange'].forEach(text => {
	// 요소 노드 생성
	const $li = document.createElement('li');

	// 텍스트 노드 생성
	const textNode = document.createTextNode(text);

	// 텍스트 노드를 li 태그의 자식 요소로 추가
	$li.appendChild(textNode);

	// li 요소 노드를 documentFragment의 자식 요소로 추가
	$fragment.appendChild(li)
});

// 돔에 documentFragment를 추가
$fruits.appendChild($fragment)
```

#### 5. 노드 삽입

##### Node.prototype.appendChild 메서드

- 인수로 전달받은 노드를 자신을 호출한 노드의 마지막 자식 노드로 DOM에 추가
- 노드를 추가할 위치는 정할 수 없고 언제나 마지막 자식 노드 위치에만 가능

##### Node.prototype.insertBefore(newNode, childNode) 메서드

- 첫 번째 인수로 전달받은 노드를 두 번째 인수로 전달받은 노드 앞에 삽입
- 두 번째 인수로 전달받은 노드는 반드시 insertBefore 메서드를 호출한 노드의 자식 노드여야 한다. (그렇지 않으면 DOMException 에러 발생)
- 두 번째 인수로 전달받은 노드가 null이면 첫 번째 인수로 전달받은 노드를 해당 메서드를 호출한 노드의 마지막 자식 노드로 추가한다. (= appendChild 메서드처럼)

#### 6. 노드 이동

- DOM에 이미 존재하는 노드를 appendChild || insertBefore 메서드를 사용해 DOM에 다시 추가하면 현재 위치에서 제거되고 새로운 위치에 추가된다. (이동)

#### 7. 노드 복사 (p.732 참고)

- Node.prototype.cloneNode([deep: true | false]) 메서드는 노드의 사본을 생성해 반환한다.
- 매개변수 deep에 true를 전달하면 깊은 복사해 모든 자손 노드가 포함된 사본 생성
- false를 전달하면 얕은 복사로 노드 자신만의 사본을 생성한다.
  - 자손 노드를 복사하지 않으므로 텍스트 노드도 없다.

#### 8. 노드 교체

- Node.prototype.replaceChild(newChild, oldChild) 메서드는 자신을 호출한 노드의 자식 노드를 다른 노드로 교체한다.
- 첫 번째 매개변수에는 교체할 새로운 노드를 인수로 전달
- 두 번째 매개변수에는 이미 존재하는, 교체될 노드를 인수로 전달 (해당 메서드를 호출한 노드의 자식 노드여야 함)
- oldChild는 DOM에서 제거됨

#### 9. 노드 삭제

- Node.prototype.removeChild(child) 메서드는 매개변수에 인수로 전달한 노드를 DOM에서 삭제한다.
- 인수로 전달한 노드는 해당 메서드를 호출한 노드의 자식 노드여야 한다.

## 📌 39.7 어트리뷰트

#### 1. 어트리뷰트 노드와 attributes 프로퍼티

- HTML 요소는 여러 개의 속성을 가질 수 있다.
- HTML 어트리뷰트는 HTML 요소의 동작을 제어하기 위해 추가적인 정보를 제공한다.
- HTML 요소의 시작 태그에 어트리뷰트 이름="어트리뷰트 값" 형식으로 정의한다.
- 글로벌 어트리뷰트(id, class, title 등)와 이벤트 핸들러 어트리뷰트(onClick, onSubmit 등)는 모든 HTML 요소에서 공통적으로 사용할 수 있다.
- 특정 HTML 요소에만 한정적으로 사용할 수 있는 어트리뷰트도 있다. (type, value, checked 와 같은 어트리뷰트를 input 요소에만 사용하는 예)
- HTML 문서가 파싱될 때 HTML 요소의 어트리뷰트는 어트리뷰트 노드로 변환되어 요소 노드와 연결된다.
- 모든 어트리뷰트 노드의 참조는 NamedNodeMap(유사 배열 객체 && 이터러블) 객체에 담겨서 요소 노드의 attributes 프로퍼티에 저장된다.
- 요소 노드의 모든 어트리뷰트 노드는 요소 노드의 Element.prototype.attributes 프로퍼티로 취득할 수 있다.
- attributes 프로퍼티는 getter만 존재하는 읽기 전용 접근자 프로퍼티다.

#### 2. HTML 어트리뷰트 조작

- Element.prototype.getAttributes(참조)/setAttributes(변경) 메서드로 요소 노드에서 메서드를 통해 직접 HTML 어트리뷰트 값을 취득하거나 변경할 수 있다.
- Element.prototype.hasAttributes(attributeName) : 특정 HTML 어트리뷰트의 존재 여부
- Element.prototype.removeAttributes(attributeName) : 특정 HTML 어트리뷰트의 삭제

#### 3. HTML 어트리뷰트 vs DOM 프로퍼티

- HTML 어트리뷰트의 역할: HTML 요소의 초기 상태를 지정하는 것 (불변)
- 요소 노드는 상태를 가지고 있다.
  - 초기 상태와 최신 상태 2가지를 관리해야 한다.
  - 초기 상태는 어트리뷰트 노드가, 최신 상태는 DOM 프로퍼티가 관리한다.
- 어트리뷰트 노드
  - 초기 상태를 관리한다.
  - 초기 상태 값을 취득하거나 변경하려면 getAttribute/setAttribute 사용
- DOM 프로퍼티
  - 유저가 입력한 최신 상태를 관리한다.
  - 언제든 동적으로 변경되어 최신 상태를 유지한다.
  - 단 모든 DOM 프로퍼티가 유저의 입력에 따라 변경된 최신 상태를 관리하지는 않는다. (사용자 입력에 의한 상태 변화와 관계 있는 DOM 프로퍼티만 항상 최신 상태를 유지한다.)

##### HTML 어트리뷰트와 DOM 프로퍼티의 대응 관계

- id 어트리뷰트와 id 프로퍼티는 1:1 대응하며 동일한 값으로 연동된다.
- input 요소의 value 어트리뷰트는 value 프로퍼티와 1:1 대응하나 초기 상태/최신 상태라는 점에서 다르다.
- class 어트리뷰트는 className, classList 프로퍼티와 대응한다.
- for 어트리뷰트는 htmlFor 프로퍼티와 1:1 대응한다.
- td 요소의 colspan 어트리뷰트는 대응하는 프로퍼티가 없다.
- textContent 프로퍼티는 대응하는 어트리뷰트가 없다.
- 어트리뷰트는 대소문자를 구별하지 않지만 대응하는 프로퍼티 키는 카멜 케이스를 따른다.

##### DOM 프로퍼티 값의 타입

- getAttribute 메서드로 취득한 어트리뷰트 값은 언제나 문자열이다.
- DOM 프로퍼티로 취득한 최신 상태의 값은 문자열이 아닐 수도 있다. (checked는 불리언 값인 것처럼)

#### 4. data 어트리뷰트와 dataset 프로퍼티

- HTML 요소에 정의한 사용자 정의 어트리뷰트와 JS 간의 데이터 교환 가능
- data 어트리뷰트는 data-user-id, data-role과 같이 data- 접두사 다음에 임의의 이름을 붙여 쓴다.
- 이 어트리뷰트의 값은 HTMLElement.dataset 프로퍼티로 취득할 수 있다.
- dataset 프로퍼티는 HTML 요소의 모든 data 어트리뷰트의 정보를 제공하는 DOMStringMap 객체를 반환한다.
- 이 객체는 data 어트리뷰트의 data- 접두사 뒤의 임의의 이름을 카멜 케이스로 변환한 프로퍼티를 갖고 있다.
- 이 프로퍼티로 data 어트리뷰트의 값을 취득하거나 변경할 수 있다.
- 존재하지 않는 이름을 키로 사용해 할당하면 새로 data 어트리뷰트가 추가된다.

## 📌 39.8 스타일

#### 1. 인라인 스타일 조작

- HTMLElement.prototype.style 프로퍼티는 setter, getter 모두 존재하는 접근자 프로퍼티
- 요소 노드의 인라인 스타일을 취득하거나 추가/변경한다.
- 참조 시 CSSStyleDeclaration 타입의 객체를 반환
  - 해당 객체는 다양한 CSS 프로퍼티에 대응하는 프로퍼티를 보유
  - 이 프로퍼티에 값을 할당하면 인라인 스타일로 HTML 요소에 추가/변경됨
  - CSS 프로퍼티는 케밥 케이스, 이에 해당하는 CSSStyleDeclaration 객체의 프로퍼티는 카멜 케이스를 준수한다.
  - 케밥 케이스로 쓰려면 대괄호 표기법을 사용한다.
  - 단위 지정이 필요한 경우에는 반드시 단위를 지정해야 한다.

#### 2. 클래스 조작

- .으로 시작하는 클래스 선택자를 사용해 CSS class를 미리 정의한 후 HTML의 class 어트리뷰트 값을 변경해 HTML 요소의 스타일을 변경할 수 있다.
- class 어트리뷰트에 대응하는 DOM 프로퍼티는 className과 classList다. (JS에서 class는 예약어이기 때문)

##### className

- setter, getter 모두 존재하는 접근자 프로퍼티
- HTML 요소의 class 어트리뷰트 값을 취득하거나 변경함
- 요소 노드의 className 프로퍼티를 참조하면 class 어트리뷰트 값을 문자열로 반환함
- 요소 노드의 className 프로퍼티에 문자열을 할당하면 class 어트리뷰트 값을 할당한 문자열로 변경함
- 문자열을 반환하므로 공백으로 구분됱 여러 개의 클래스를 반환한 경우 다루기 불편함

##### classList

- class 어트리뷰트의 정보를 담은 DOMTokenList 객체를 반환함
- 해당 객체는 class 어트리뷰트의 정보를 나타내는 컬렉션 객체
- 유사 배열 객체 && 이터러블
- add, remove, item, contains, replace, toggle 등 메서드를 제공한다.

#### 3. 요소에 적용되어 있는 CSS 스타일 참조

- style 프로퍼티는 인라인 스타일만 반환한다.
- 클래스를 적용한 스타일이나 상속으로 적용된 스타일은 style 프로퍼티로 참조할 수 없다.
- HTML 요소에 적용된 모든 CSS 스타일을 참조해야 할 경우 getComputedStyle 메서드를 사용한다.
- window.getComputedStyle(element[, pseudo]) 메서드
  - 첫 번째 인수로 전달한 요소 노드에 적용된 평가된 스타일을 CSSStyleDeclartion 객체에 담아 반환한다. (평가된 스타일: 링크, 임베딩, 인라인 등 모든 스타일이 조합돼 최종 적용된 스타일)
  - 두 번째 인수로 :after, :before 같은 의사 요소를 지정하는 문자열을 전달할 수 있다.
