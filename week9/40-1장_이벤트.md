# ✏️ 40장 이벤트

## 📌 40.1 이벤트 드리븐 프로그래밍

- 브라우저는 처리해야 할 특정 사건(클릭 등)이 발생하면 이를 감지해 이벤트를 발생 시킴
- 애플리케이션이 특정 이벤트에 반응해 어떤 일을 하고 싶다면, 해당 이벤트가 발생할 때 호출될 함수를 브라우저에게 알려 호출을 위임함

- 이벤트 핸들러: 이벤트가 발생할 때 호출될 함수
- 이벤트 핸들러 등록: 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것
- ex. 유저가 버튼을 클릭할 때 함수를 호출해 어떤 일을 처리하고 싶은데 언제 호출할지 모르니 클릭 이벤트가 '발생'하면 특정 함수를 호출하도록 브라우저에게 위임하는 것
- 이벤트와 그에 대응하는 함수(이벤트 핸들러)를 통해 유저와 애플리케이션은 상호작용을 함
- 이벤트 드리븐 프로그래밍: 프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식

## 📌 40.2 이벤트 타입

- 이벤트 타입: 이벤트의 종류를 나타내는 '문자열'

#### 1. 마우스 이벤트

| 이벤트 타입 | 이벤트 발생 시점                                    |
| ----------- | --------------------------------------------------- |
| click       | 마우스 버튼을 클릭했을 때                           |
| dbclick     | 마우스 버튼을 더블 클릭했을 때                      |
| mousedown   | 마우스 버튼을 눌렀을 때                             |
| mouseup     | 누르던 마우스 버튼을 놓았을 때                      |
| mousemove   | 마우스 커서를 움직였을 때                           |
| mouseenter  | 마우스 커서를 HTML 요소 안으로 이동할 때 (버블링 X) |
| mouseover   | 마우스 커서를 HTML 요소 안으로 이동할 때 (버블링 O) |
| mouseleave  | 마우스 커서를 HTML 요소 밖으로 이동할 때 (버블링 X) |
| mouseout    | 마우스 커서를 HTML 요소 안으로 이동할 때 (버블링 X) |

#### 2. 키보드 이벤트

| 이벤트 타입 | 이벤트 발생 시점                                                                                                                                                                    |
| ----------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| keydown     | 모든 키를 눌렀을 때 발생 (control, option, shift, tab, delete, enter, 방향키, 문자, 숫자, 특수 문자 키 / 문자, 숫자, 특수 문자, enter는 연속적으로 발생하지만 그 외는 한 번만 발생) |
| keypress    | 문자 키를 눌렀을 때 연속적으로 발생 (문자, 숫자, 특수 문자, enter 키를 눌렀을 때만 발생 / 폐지됨)                                                                                   |
| keyup       | 누르던 키를 놓았을 때 1번 발생 (keydown 이벤트와 동일)                                                                                                                              |

#### 3. 포커스 이벤트

| 이벤트 타입 | 이벤트 발생 시점                          |
| ----------- | ----------------------------------------- |
| focus       | HTML 요소가 포커스를 받았을 때 (버블링 X) |
| focusin     | HTML 요소가 포커스를 받았을 때 (버블링 O) |
| blur        | HTML 요소가 포커스를 잃었을 때 (버블링 X) |
| focusout    | HTML 요소가 포커스를 잃었을 때 (버블링 O) |

focusin, focusout 이벤트 헨들러는 addEventListener 메서드 방식으로 등록해야 한다.

#### 4. 폼 이벤트

| 이벤트 타입            | 이벤트 발생 시점                                                               |
| ---------------------- | ------------------------------------------------------------------------------ |
| submit                 | 1. form 요소 내의 input, select 입력 필드(textarea 제외)에서 엔터 키를 누를 때 |
| (form 요소에서만 발생) | 2. form 요소 내의 submit 버튼 (<button>, <input type="submit">)을 클릭했을 때  |
| reset                  | form 요소 내의 reset 버튼을 눌렀을 때 (최근에는 사용 X)                        |

#### 5. 값 변경 이벤트

| 이벤트 타입      | 이벤트 발생 시점                                                                                                                    |
| ---------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| input            | input, select, textarea 요소 값이 입력되었을 때                                                                                     |
| change           | input, select, textarea 요소 값이 변경되었을 때 (input 이벤트와 달리 HTML 요소가 포커스를 잃으면 입력이 종료되었다고 인식하여 발생) |
| readystatechange | HTML 문서의 로드와 파싱 상태를 나타내는 document.readyState 프로퍼티 값이 변경될 때 ('loading', 'interactive', 'complete')          |

#### 6. DOM 뮤테이션 이벤트

| 이벤트 타입      | 이벤트 발생 시점                                          |
| ---------------- | --------------------------------------------------------- |
| DOMContentLoaded | HTML 문서의 로드와 파싱이 완료돼 DOM 생성이 완료되었을 때 |

#### 7. 뷰 이벤트

| 이벤트 타입 | 이벤트 발생 시점                                                                |
| ----------- | ------------------------------------------------------------------------------- |
| resize      | 브라우저 윈도우의 크기를 리사이즈할 때 연속적으로 발생 (window 객채에서만 발생) |
| scroll      | 웹페이지(document) 또는 HTML 요소를 스크롤할 때 연속적으로 발생                 |

#### 8. 리소스 이벤트

| 이벤트 타입 | 이벤트 발생 시점                                                                               |
| ----------- | ---------------------------------------------------------------------------------------------- |
| load        | DOMContentLoaded 이벤트가 발생한 후 모든 리소스의 로딩이 완료될 때 (주로 window 객체에서 발생) |
| unload      | 리소스가 언로드 될때 (주로 새로운 웹페이지를 요청한 경우)                                      |
| abort       | 리소스 로딩이 중단되었을 때                                                                    |
| error       | 리소스 로딩이 실패했을 때                                                                      |

## 📌 40.3 이벤트 핸들러 등록

- 이벤트 핸들러를 등록하는 방법은 3가지다.

#### 1. 이벤트 핸들러 어트리뷰트 방식

- 이벤트 핸들러 어트리뷰트의 이름은 onclick처럼 on 접두사 + 이벤트의 종류를 나타내는 이벤트 타입으로 이루어짐
- 이벤트 핸들러 어트리뷰트 값으로 **함수 호출문 등 문을 할당**하면 이벤트 핸들러가 등록됨
- 이벤트 핸들러를 등록할 때 콜백 함수처럼 함수 참조를 등록해야 브라우저가 이벤트 핸들러를 호출할 수 있음
- 함수 참조가 아니라 함수 호출문을 등록하면 함수호출문의 평가 결과가 이벤트 핸들러로 등록됨
- 함수를 반환하는 고차 함수 호출문이면 문제가 없지만 함수가 아닌 값을 반환하는 함수 호출문을 이벤트 핸들러로 등록하면 브라우저가 호출할 수 없음

```
...
<button onclick='sayHi('Lee')'>Click me!</button>
<script>
  function sayHi(name) {
    console.log(`Hi! ${name}.`);
  }
...
```

- 위 예제는 이벤트 핸들러 어트리뷰트 값으로 함수 호출문을 할당함
- 이벤트 핸들러 어트리뷰트 값은 아래와 같이 암묵적으로 생성될 이벤트 핸들러의 함수 몸체를 의미함 (함수를 암묵적 생성 후 이벤트 핸들러 어트리뷰트 이름과 동일한 키 onclick 이벤트 핸들러 프로퍼티에 할당함 - 문자열)
- 이렇게 작동하는 이유는 이벤트 핸들러에 인수를 전달하기 위해서임

```
function onclick(event) {
    sayHi('Lee');
}
```

- CBD 방식의 프레임워크/라이브러리에서는 사용하는 경우가 있긴 하지만 HTML과 JS는 관심사가 다르므로 분리하는 것을 추천하며 사용은 지양하는 것이 좋다.

#### 2. 이벤트 핸들러 프로퍼티 방식

- window객체, Documentm HTMLElement 타입의 DOM 노드 객체는 이벤트에 대응하는 이벤트 핸들러 프로퍼티를 갖고 있음
- 이벤트 핸들러 프로퍼티의 키: on 접두사 + 이벤트의 종류를 나타내는 이벤트 타입
- 이벤트 핸들러 프로퍼티에 함수를 바인딩하면 이벤트 핸들러가 등록됨
- 이벤트 타깃 / on + 이벤트 타입 / 이벤트 핸들러 형태로 이루어짐

![image](https://velog.velcdn.com/images/saiani1/post/01e44f89-cc8d-42bc-acfe-de6f0727141c/image.png)

- 이벤트 핸들러는 대부분 이벤트를 발생시킬 이벤트 타깃에 바인딩하지만 전파된 이벤트를 캐치할 DOM 노드 객체에 바인딩할 때도 있음
- 1번 방식과 달리 HTML과 JS가 뒤섞이는 문제를 해결할 수 있지만 이벤트 핸들러 프로퍼티에 하나의 이벤트 핸들러만 바인딩할 수 있다는 단점이 있음

```
<body>
  <button>Click me!</button>
  <script>
    const $button = document.querySelector('button');

    $button.onclick = function() {
      console.log('button clicked 1');
    };

    // 첫 번째 이벤트 핸들러는 두 번째로 바인딩된 이벤트 핸들러에 의해 실행되지 않음
    $button.onclick = function() {
      console.log('button clicked 2');
    };
  </script>
</body>
```

#### 3. addEventListener 메서드 방식

- 첫 번째 매개변수는 이벤트 종류를 나타내는 문자열인 이벤트 타입을 전달함 (on 접두사 X)
- 두 번째 매개변수는 이벤트 핸들러를 전달함
- 세 번째 매개변수는 이벤트를 캐치할 이벤트 전파 단계(캡처링 또는 버블링)를 지정함
  - (true: 캡처링 단계에서 이벤트 캐치 / false || 생략: 버블링 단계에서 이벤트 캐치)

![image](https://velog.velcdn.com/images/hyesom/post/8af47c3f-f817-4597-90f4-d0ddfa76e66e/image.png)

```
<body>
  <button>Click me!</button>
  <script>
    const $button = document.querySelector('button');

    const handleClick = () => console.log('button click');

    $button.addEventListener('click', handleClick);
    $button.addEventListener('click', handleClick);
  </script>
</body>
```

- 동일한 HTML 요소에서 발생한 동일한 이벤트에 대해 이벤트 핸들러 프로퍼티와 addEventListener 메서드 방식을 모두 사용하면 어떻게 될까?
  - addEventListener 메서드 방식은 이벤트 핸들러 프로퍼티에 바인딩된 이벤트 핸들러에 아무 영향을 주지 않는다. (이벤트 핸들러 프로퍼티와 addEventListener 2개의 핸들러 모두 작동)
  - addEventListener 메서드는 동일한 HTML 요소에서 발생한 동일한 이벤트에 대해서 하나 이상의 이벤트 핸들러를 등록할 수 있음 (등록 순서대로 호출)
  - 단 참조가 동일한 이벤트 핸들러를 중복하면 1개만 등록된다.

## 📌 40.4 이벤트 핸들러 제거

- addEventListener 메서드로 등록한 이벤트 핸들러를 제거할 때는 EventTarget.prototype.removeEventListener 메서드를 사용한다.
- 등록할 때 전달한 인수와 동일하지 않으면 이벤트 핸들러가 제거되지 않는다.
- 무명 함수를 이벤트 핸들러로 등록한 경우에는 제거할 수 없다. (이벤트 핸들러의 참조를 변수나 자료구조에 저장해야 하는데 참조할 수 없으므로)
- 기명 이벤트 핸들러 내부에 호출해서 이벤트 실행 후 제거하는 방식도 있음
- 무명 함수라면 arguments.callee로 자기 자신을 호출해 제거할 수도 있음

  - 코드 최적화를 방해하므로 엄격 모드에서는 사용 금지
  - 가급적 이벤트 핸들러의 참조를 변수나 자료구조에 저장해 제거하는 편이 좋음

- 이벤트 핸들러 프로퍼티 방식으로 등록한 경우에는 removeEventListener로 제거할 수 없음
  - 이벤트 핸들러 프로퍼티에 null을 할당한다.

```
...
  $button.onclick = handleClick;
  $button.onclick = null;
...
```

## 📌 40.5 이벤트 객체

- 이벤트가 발생하면 이벤트에 대한 정보를 담고 있는 이벤트 객체가 동적으로 생성됨
- 생성된 이벤트 객체는 이벤트 핸들러의 첫 번째 인수로 전달됨

```
<body>
  <p>클릭하세요. 클릭한 곳의 좌표가 표시됩니다.</p>
  <em class="message"></em>
  <script>
    const $msg = document.querySelector('.message');

    // 매개변수 e에 암묵적으로 할당
    function showCoords(e) {
      $msg.textContent = `clientX: ${e.clientX}, clientY: ${e.clientY}`
    }

    document.onClick = showCoords;
  </script>
</body>
```

- 클릭 이벤트로 생성된 이벤트 객체는 이벤트 핸들러의 첫 번째 인수로 전달돼 매개변수 e에 암묵적으로 할당됨 (브라우저가 이벤트 핸들러를 호출할 때 이벤트 객체를 인수로 전달하기 때문)
- 이벤트 객체를 전달 받으려면 이벤트 핸들러를 정의할 때 매개변수를 명시적으로 선언해야 함

- 이벤트 핸들러 어트리뷰트 방식으로 이벤트 핸들러를 등록했다면 아래와 같이 전달 받을 수 있음
- 이 경우 이벤트 핸들러의 첫 번째 매개변수 이름이 반드시 event여야 함
- 이벤트 핸들러 어트리뷰트 값은 암묵적으로 생성되는 이벤트 핸들러의 함수 몸체이기 때문

```
<!DOCTYPE html>
<html>
<!-- 어트리뷰트 방식의 경우 event가 아닌 다른 이름으로는 이벤트 객체를 전달받지 못한다. -->
<body onclick="showCoords(event)">
  <p>클릭하세요. 클릭한 곳의 좌표가 표시됩니다.</p>
  <em class="message"></em>
  <script>
    const $msg = document.querySelector('.message');

    // 이벤트 객체는 이벤트 핸들러의 첫 번째 인수로 전달된다.
    function showCoords(e) {
      $msg.textContent = `clientX: ${e.clientX}, clientY: ${e.clientY}`;
    }
  </script>
</body>
</html>
```

#### 1. 이벤트 객체의 상속 구조

- 이벤트 객체는 아래와 같은 상속 구조를 갖는다.
- Event, UIEvent 등 모두 생성자 함수로 생성자 함수를 호출해 이벤트 객체를 생성할 수 있음

![image](https://velog.velcdn.com/images%2Fniyu%2Fpost%2F1850cb91-ccbd-44d3-8b5e-a9c99436ed74%2Fimage.png)

- 이벤트 객체 중 일부는 사용자의 행위에 의해 생성되고 일부는 JS 코드에 의해 인위적으로 생성된다.
  - MouseEvent 타입의 이벤트 객체는 사용자가 마우스를 클릭, 이동할 때 생성되는 이벤트 객체
  - CustonEvent 타입의 이벤트 객체는 JS 코드에 의해 인위적으로 생성한 이벤트 객체
- Event 인터페이스는 DOM 내에서 발생한 이벤트에 의해 생성되는 이벤트 객체
- 여기에는 모든 이벤트 객체의 공통 프로퍼티가 정의되어 있음
- 하위 인터페이스에는 이벤트 타입에 따라 고유한 프로퍼티가 정의되어 있음
- 이벤트 객체의 프로퍼티는 발생한 이벤트의 타입에 따라 달라진다.

#### 2. 이벤트 객체의 공통 프로퍼티

- Event 인터페이스의 이벤트 관련 프로퍼티는 모든 이벤트 객체가 상속받는 공통 프로퍼티다.

![image](https://velog.velcdn.com/images%2Fniyu%2Fpost%2Ffe7b632b-8722-460a-a635-7c3ca1bfc3a6%2Fimage.png)

#### 3. 마우스 정보 취득

- 마우스와 관련된 이벤트가 발생하면 생성되는 MouseEvent 타입의 이벤트 객체의 고유 프로퍼티
  - 마우스 포인터의 좌표 정보를 나타내는 프로퍼티: screen, client, page, offset (X/Y)
  - 버튼 정보를 나타내는 프로퍼티: altKey, ctrlKey, shiftKey, button

#### 4. 키보드 정보 취득

- 키보드와 관련된 이벤트가 발생하면 생성되는 KeyboardEvent 타입의 이벤트 객체의 고유 프로퍼티
  - altKey, ctrlKey, shiftKey, metaKey, key, keyCode

## 📌 40.6 이벤트 전파

- DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파된다.
- 이를 이벤트 전파라고 한다.

![image](https://velog.velcdn.com/images/saiani1/post/6fadf532-09a2-451c-9598-2abe034a5dd9/image.png)

- ul 요소의 두 번째 자식 요소 li 요소를 클릭하면 클릭 이벤트 발생
- 생성된 이벤트 객체는 이 이벤트를 발생시킨 DOM 요소인 이벤트 타깃을 중심으로 DOM 트리를 통해 전파됨
- 이벤트 전파는 이벤트 객체가 전파되는 방향에 따라 3단계로 구분 가능
  - 캡처링 단계: 이벤트가 상위 요소 -> 하위 요소 방향으로 전파
  - 타깃 단계: 이벤트가 이벤트 타깃에 도달
  - 버블링 단계: 이벤트가 하위 요소 -> 상위 요소 방향으로 전파

```
<body>
  <ul id="fruits">
    <li id="apple">Apple</li>
    <li id="banana">Banana</li>
    <li id="orange">Orange</li>
  </ul>
  <script>
    const $fruits = document.getElementById("fruits");

    // #friuts 요소의 하위 요소인 li 요소를 클릭한 경우
    $fruits.addEventListener('click', e => {
      console.log(`이벤트 단계: ${e.eventPhase}`); // 3 : 이벤트 단계
      console.log(`이벤트 타깃: ${e.target}`); // {object HTMLLIElement}
      console.log(`커런트 타깃: ${e.currentTarget}`); // [object HTMLUListElement]
    });
  </script>
</body>
```

- 캡처링 단계: li 요소를 클릭해 클릭 이벤트 객체가 생성되고 클릭된 li 요소가 이벤트 타깃이 됨. 클릭 이벤트 객체는 window에서 시작해 이벤트 타깃 방향으로 전파됨
- 타깃 단계: 이벤트 객체는 이벤트를 발생시틴 이벤트 타깃에 도달함
- 버블링 단계: 이벤트 객체는 이벤트 타깃에서 시작해 window 방향으로 전파됨

- 이벤트 핸들러 어트리뷰트/프로퍼티 방식으로 등록한 이벤트 핸들러는 타깃 단계, 버블링 단계의 이벤트만 캐치할 수 있다.
- addEventListener 메서드 방식으로 등록한 이벤트 핸들러는 캡처링 단계의 이벤트도 선별적으로 캐치할 수 있다. (3번째 인수로 true 전달 시 / 미전달 또는 false면 타깃 단계, 버블링 단계만)

- 대부분의 이벤트는 캡처링과 버블링으로 전파되지만 아래 이벤트들은 버블링으로 전파되지 않는다.
  - 포커스 이벤트: focus/blur
  - 리소스 이벤트: load/unload/abort/error
  - 마우스 이벤트: mouseenter/mouseleave
- 따라서 캡처링 단계의 이벤트를 캐치해야 하는데 이럴 경우 대체할 수 있는 이벤트가 있기 때문에 캡처링 단계에서 이벤트를 캐치할 경우는 별로 없다.

```
<!DOCTYPE html>
<html>
<body>
  <p>버블링과 캡처링 이벤트 <button>버튼</button></p>
  <script>
    // 버블링 단계의 이벤트 캐치
    document.body.addEventListener('click', () => {
    	console.log('Handler for body.');
    });

    // 캡처링 단계의 이벤트 캐치
    document.querySelector('p').addEventListener('click', () => {
    	console.log('Handler for paragraph.');
    }, true);

    // 타깃 단계의 이벤트 캐치
    document.querySelector('button').addEventListener('click', () => {
    	console.log('Handler for button.');
    });
  </script>
</body>
</html>
```

- 위 예제의 body 요소는 버블링 단계의 이벤트만, p 요소는 캡처링 단계의 이벤트만 캐치한다.
- 이벤트는 캡처링 > 타깃 > 버블링 단계로 호출된다.

## 📌 40.7 이벤트 위임

- 이벤트 위임: 여러 개의 하위 DOM 요소에 각각 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM 요소에 이벤트 핸들러를 등록하는 방법
  - 그렇지 않으면 100개의 하위 요소에 모두 추가해야 하는데 이는 성능 저하, 어려운 유지 보수의 원인이 된다.
  - 동적으로 하위 요소를 추가해도 일일이 등록할 필요가 없다.

```
<head>
  <style>
    #fruits {
      display: flex;
      list-style-type: none;
      padding: 0;
    }
    #fruits li {
      width: 100px;
      cursor: pointer;
    }
    #fruits .active {
      color: red;
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <nav>
    <ul id="fruits">
      <li id="apple" class="active">Apple</li>
      <li id="banana">Banana</li>
      <li id="orange">Orange</li>
    </ul>
  </nav>
  <div>선택된 내비게이션 아이템: <em class="msg">apple</em></div>
  <script>
    const $fruits = document.getElementById("fruits");
    const $msg = document.querySelector(".msg");

    function activate({ target }){
      // 이벤트를 발생시킨 요소(target)가 ul#fruits의 자식 요소가 아니라면 무시
      if(!target.matches('#fruits > li')) return;

      [...$fruits.children].forEach($fruits => {
        $fruits.classList.toggle('active', $fruit === target);
        $msg.textContent = target.id;
      });
    }

    $fruits.onclick = activate;
  </script>
</body>
```

- 일반적으로 이벤트 객체의 target 프로퍼티와 currentTarget 프로퍼티는 동일한 DOM 요소를 가리키지만 이벤트 위임을 통해 상위 DOM 요소에 이벤트를 바인딩한 경우 다른 DOM 요소를 가리킬 수도 있다.
