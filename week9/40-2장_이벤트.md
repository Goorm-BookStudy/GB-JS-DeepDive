# ✏️ 40장 이벤트

## 📌 40.8 DOM 요소의 기본 동작 조작

#### 1. DOM 요소의 기본 동작 중단

- 이벤트 객체의 preventDefault 메서드: DOM 요소가 가진 저마다의 기본 동작을 중단시킨다.

```
<!DOCTYPE html>
<html>
<body>
  <a href="http://www.google.com">go</a>
  <script>
  document.querySelector('a').onclick = e => {
    // a 요소의 기본 동작을 중단한다.
    e.preventDefault();
  };
  </script>
</body>
</html>
```

#### 2. 이벤트 전파 방지

- 이벤트 객체의 stopPropagation 메서드: 이벤트 전파를 중지시킨다.
- 상위 DOM 요소인 container 요소에 이벤트를 위임했다.
- 하위 DOM 요소에서 발생한 클릭 이벤트를 container 요소가 캐치해 이벤트를 처리한다.
- 하지만 하위 요소 중 btn2 요소는 자체적으로 이벤트를 처리한다. (전파되는 것을 중단 시킴)
- 이로서 하위 DOM 요소의 이벤트를 개별적으로 처리하기 위해 이벤트의 전파를 중단시킨다.

```
<!DOCTYPE html>
<html>
<body>
  <div class="container">
    <button class="btn1">Button 1</button>
    <button class="btn2">Button 2</button>
    <button class="btn3">Button 3</button>
  </div>
  <script>
    // 이벤트 위임. 클릭된 하위 버튼 요소의 color를 변경
    document.querySelector('.container').onclick = ({ target }) => {
      if(!target.matches('.container > button')) return;
      target.style.color = 'red';
    };

    document.querySelector('.btn2').onclick = e => {
      e.stopPropagation(); // 이벤트 전파 중단
      e.target.style.color = 'blue';
    };
  </script>
</body>
</html>
```

## 📌 40.9 이벤트 핸들러 내부의 this

#### 1. 이벤트 핸들러 어트리뷰트 방식

- 이벤트 핸들러 어트리뷰트의 값으로 지정한 문자열은 암묵적으로 생성되는 이벤트 핸들러의 문
- handleClick 함수는 이벤트 핸들러에 의해 일반 함수로 호출된다.
- 일반 함수로서 호출되는 함수 내부의 this 는 전역 객체를 가리킴

```
<button onclick="handleClick()">Click me</button>
...
  function handleClick() {
    console.log(this); // window
  }
...
```

- 단 이벤트 핸들러를 호출할 때 인수로 전달한 this는 이벤트를 바인딩한 DOM 요소를 가리킴

```
<button onclick="handleClick(this)">Click me</button>
...
  function handleClick(button) {
    console.log(button); // 이벤트를 바인딩한 button 요소
    console.log(this); // window
  }
...
```

#### 2. 이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식

- 이벤트 핸들러 내부의 this는 이벤트를 바인딩한 DOM 요소를 가리킴
- 즉 이벤트 핸들러 내부의 this는 이벤트 객체의 currentTarget 프로퍼티와 같다. (p.790)
- 화살표 함수로 정의한 이벤트 핸들러 내부의 this는 상위 스코프의 this를 가리킨다. (화살표 함수는 함수 자체의 this 바인딩을 갖지 않으므로, currentTarget과 this가 다르다.)
- 클래스에서 이벤트 핸들러를 바인딩하는 경우 생성할 인스턴스가 아니라 이벤트를 바인딩한 DOM 요소를 가리킬 수 있기 때문에 주의해야 한다. (p. 792)

## 📌 40.10 이벤트 핸들러에 인수 전달

- 함수에 인수를 전달하려면 함수를 호출할 때 전달해야 한다.
- 이벤트 핸들러 어트리뷰트 방식: 함수 호출문을 사용하기에 인수를 전달할 수 있음
- 그외 2가지 방식: 이벤트 핸들러를 브라우저가 호출하기에 함수 자체를 등록해야 한다.
  - 인수를 전달할 수 없기 때문에 이벤트 핸들러 내부에서 함수를 호출하며 인수를 전달한다.
  - 또는 이벤트 핸들러를 반환하는 함수를 호출하면서 인수를 전달할 수도 있다.

```
<!DOCTYPE html>
<html lang="kr">
  <head>
    <meta charset="UTF-8" />
    <title>Practice</title>
  </head>
  <body>
    <label>User name <input type="text"/></label>
    <em class="message"></em>
    <script>
      const MIN_USER_NAME_LENGTH = 5; // 이름 최소 길이
      const $input = document.querySelector('input[type=text]');
      const $msg = document.querySelector('.message');

      const checkUserNameLength = min => {
        $msg.textContent =
          $input.value.length < min ? `이름은 ${min}자 이상 입력해 주세요` : '';
      }

      // 이벤트 핸들러 내부에서 함수를 호출하면서 인수를 전달한다.
      $input.onblur = () => {
        checkUserNameLength(MIN_USER_NAME_LENGTH);
      }
    </script>
  </body>
</html>
```

```
<!DOCTYPE html>
<html lang="kr">
  <head>
    <meta charset="UTF-8" />
    <title>Practice</title>
  </head>
  <body>
    <label>User name <input type="text"/></label>
    <em class="message"></em>
    <script>
      const MIN_USER_NAME_LENGTH = 5; // 이름 최소 길이
      const $input = document.querySelector('input[type=text]');
      const $msg = document.querySelector('.message');

      const checkUserNameLength = min => e => {
        $msg.textContent =
          $input.value.length < min ? `이름은 ${min}자 이상 입력해 주세요` : '';
      }

      // 이벤트 핸들러를 반환하는 함수를 호출하면서 인수를 전달한다.
      $input.onblur = checkUserNameLength(MIN_USER_NAME_LENGTH);
    </script>
  </body>
</html>
```

- 외부 함수로서 min을 받고 내부 함수로서 e를 받는 구조 (함수를 반환함)

## 📌 40.11 커스텀 이벤트

#### 1. 커스텀 이벤트 생성

- 이벤트 객체는 이벤트 생성자 함수로 생성할 수 있다.
- 이벤트가 발생하면 암묵적으로 생성되는 이벤트 객체는 발생한 이벤트의 종류에 따라 이벤트 타입이 결정된다.
- 이벤트 생성자 함수를 호출해 '명시적으로 생성한' 이벤트 객체는 임의로 이벤트 타입을 지정할 수 있다.
- 이처럼 개발자의 의도로 생성된 이벤트는 커스텀 이벤트라고 한다.

```
const keyboardEvent = new KeyboardEvent('keyup');
console.log(keyboardEvent.type); // keyup

const customEvent = new CustomEvent('foo');
console.log(customEvent.type); // foo
```

- 첫 번째 인수로 이벤트 타입을 나타내는 문자열을 전달한다.
- 기존 이벤트 타입을 사용할 수도, 임의의 문자열을 사용해 새로운 이벤트 타입을 지정할 수도 있다. (후자의 경우 CustomEvent 이벤트 생성자 함수를 사용한다.)
- 생성된 커스텀 이벤트 객체는 bubbles와 cancelable 프로퍼티의 값이 false이므로 버블링 되지 않고, 기본 동작도 취소할 수 없다.
- 이를 true로 설정하려면 두 번째 인수로 bubbles || cancelable 프로퍼티를 갖는 객체를 전달해야 한다.

```
const customEvent = new MouseEvent('click', {
    bubbles: true,
    cancelable: true
});
```

- 이외에도 이벤트 타입에 따라 가지는 이벤트 고유의 프로퍼티 값을 지정할 수 있다.
- 이벤트 생성자 함수로 생성한 커스텀 이벤트는 isTrusted 프로퍼티의 값이 언제나 false다. (사용자의 행위에 의해 발생한 이벤트인지 여부 - 인위적 발생의 경우 false)

#### 2. 커스텀 이벤트 디스패치

- 생성된 커스텀 이벤트는 dispatchEvent 메서드로 디스패치(이벤트를 발생시키는 행위)할 수 있다.
- dispatchEvent 메서드에 이벤트 객체를 인수로 전달하면서 호출하면 인수로 전달한 이벤트 타입의 이벤트가 발생한다.
- 이벤트 핸들러는 비동기 처리 방식으로 동작하지만, dispatchEvent 메서드는 동기 처리 방식으로 호출한다.
- 즉 커스텀 이벤트에 바인딩된 이벤트 핸들러를 직접 호출하는 것
- 따라서 디스패치 전에 커스텀 이벤트를 처리할 이벤트 핸들러를 등록해야 한다.
- detail 프로퍼티를 포함한 객체를 CustomEvent 이벤트 생성자 함수에 전달할 수 있다.
- 임의의 이벤트 타입을 지정해 커스텀 이벤트 객체를 생성한 경우 반드시 addEventListener 메서드 방식으로 이벤트 핸들러를 등록해야 한다.
