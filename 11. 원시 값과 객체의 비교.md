# 11.1 원시 값

- 자바스크립트가 제공하는 7가지 데이터 타입은 원시타입, 객체타입으로 구분
- 원시 값은 변경 불가능한 값 / 객체는 변경 가능한 값
- 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값 저장 / 객체를 변수에 할당하면 변수에는 참조값 저장
- 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달(값에 의한 전달) / 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달(참조에 의한 전달)

## 1) 변경 불가능한 값

- 한번 생성된 원시 값은 읽기 전용 값으로서 변경 불가능 → 데이터의 신뢰성 보장
- 변경 불가능하다는 것은 변수가 아니라 값 = 변수는 언제든지 재할당을 통해 변수 값 변경(교체) 가능
- 변수 ↔ 상수 = 재할당이 금지된 변수 = 할당이 한번만 허용
- 원시 값을 할당한 변수에 새로운 원시 값을 재할당 하면 메모리 공간에 저장되어 있는 재할당 이전의 원시 값을 변경하는 것이 아니라 새로운 메모리 공간을 확보하고 재할당한 원시 값을 저장한 후, 변수는 새롭게 재할당한 원시 값을 가리킨다. 이때 변수가 참조하던 메모리 공간의 주소가 바뀐다.
- 변수가 참조하던 메모리 공간의 주소가 변경된 이유: 변수에 할당된 원시 값이 변경 불가능한 값이기 때문
    - 변수 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 ㄱ밧을 저장한 뒤, 변수가 참조하던 메모리 공간의 주소를 변경 → 불변성
- 불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다
    - 변수값 변경 가능하면 예기치 않게 변수 값이 변경될 수 있어 상태 변경을 추적하기 어렵게 만든다.

## 2) 문자열과 불변성

- 원시 값을 저장하려면 먼저 확보해야 하는 메모리 공간의 크기를 결정해야 한다. → 이를 위해 원시 타입별로 메모리 공간의 크기가 미리 정해져 있다.
    - ECMAScript 사용에 문자열 타입(2바이트), 숫자 타입(8바이트) 이외의 원시 타입은 부라우저 제조사의 구현에 따라 크기가 다를 수 있다.
- 문자열과 다른 원시값의 차이
    - 문자열은 0개 이상의 문자로 이루어진 집합으로 , 1개 문자 = 2바이트 메모리 공간에 저장
    - 문자열은 몇 개의 문자로 아루어졌느냐에 따라 필요한 메모리 공간의 크기 결정
    - 숫자값은 1, 10000 → 둘 다 8바이트 / 1개 문자 → 2바이트, 10개 문자 → 20바이트 필요
- 자바스크립트의 문자열은 원시 타입이며, 변경 불가능하다. → 문자열이 생성된 이후에는 변경 불가능

```jsx
var str = 'Hello';
str = 'world';
```

- 두번째 문은 문자열 Hello를 수정하는게 아니라 새로운 문자열 world를 메모리에 생성하고, 식별자 str는 이것을 가리킨다. Hello, world 둘 다 메모리에 존재하고 식별자 str는 Hello를 가리키다가 world를 가리키도록 변경되었을 뿐
- 문자열은 유사 배열 객체이면서 이터러블 → 배열과 유사하게 각 문자에 접근 가능
- ❗유사 배열 객체
    - 배열처럼 인덱스로 프로퍼티 값에 접근 가능하고 length 프로퍼티 갖는 객체. for문으로 순회 가능
    - 원시 값을 객체처럼 사용하면 원시 값을 감싸는 래퍼 객체로 자동 변환

```jsx
var str = 'string';
str[0] = 'S';
console.log(str); // string
```

- 문자열은 변경 불가능한 값이기에 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않는다.
- 예기치 못한 변경으로 부터 자유로움 → 데이터의 신뢰성 보장
- 새로운 문자열 변수에 재할당은 가능

## 3) 값에 의한 전달

```jsx
var score = 80;
var copy = score; // score는 변수 값 80으로 평가 -> 새로운 숫자 값 80이 생성되어 copy에 할당
console.log(score, copy); // 80 80
console.log(soore === copy); // true

score = 100;
console.log(score, copy); // 100 80
console.log(score === copy);  // false
```

- 변수에 원시 값을 갖는 변수를 할당하면 할당 받는 변수에는 할당되는 변수의 원시 값이 복사되어 전달 = 값에 의한 전달
- score변수와 copy 변수의 값 80은 다른 메모리 공간에 저장된 별개의 값
- ECMAScript  사양에는 변수를 통해 메모리를 어떻게 관리해야 하는지 명확하게 정의되어 있지 않다. → 자바스크립트 엔진을 구현하는 제조사에 따라 실제 내부 동작 방식 차이 존재
    - 변수에 원시값을 갖는 변수를 할당하면 원시값이 복사되는 방식
    - 변수에 원시 값을 갖는 변수를 할당하는 시점에는 두 변수가 같은 원시 값을 참조하다가 어느 한쪽의 변수에 재할당이 이뤄졌을 때 비로소 새로운 메모리 공간에 재할당 된 값을 저장하도록 동작
- 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기에 변수에는 값이 전달되는게 아니라 메모리 주소가 전달된다. → 값에 의한 전달이라는 용어는 자바스크립트를 위한 용어가 아니라 ‘공유에 의한 전달’ 이라 표현하기도 한다.
- 식별자 = (메모리에 저장되어 있는) 어떤 값을 구별해서 식별해낼 수 있는 고유한 이름 → 값이 아니라 메모리 주소 기억 → 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근 가능 → 식별자 = 메모리 주소에 붙인 이름

```jsx
var x = 10;
```

- 할당연산자는 값 10이 저장된 메모리 공간의 주소 전달 → 식별자 x는 메모리 공간에 저장된 숫자 값 10 식별 가능

```jsx
var copy = score;
```

- score는 식별자 표현식으로서 숫자 값 80 으로 평가됨.

⇒ 값에 의한 전달도 사실은 값을 전달하는 것이 아니라 메모리 주소를 전달. 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다. 

⇒ 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 간섭할 수 없다.

# 11.2 객체

- 객체는 프로퍼티 개수가 정해지지 않으며 동적으로 추가 삭제 가능, 프로퍼티 값 제약 없음 → 확보해야 할 메모리 공간의 크기를 사전에 정할 수 x
- ❗자바스크립트 객체의 관리 방식
    - 자바스크립트 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블이라 생각
    - 자바 등과 다르게 클래스 없이 객체 생성 가능, 객체 생성 이후라도 동적으로 프로퍼티와 메서드 추가 가능 → 사용하기에는 편리하지만 성능면에서는 클래스 기반 객체지향 프로프ㅐㄱ밍 언어의 객체보다 생성과 접근에 비용 더 든다.
    - V8 자바스크립트 엔진에서는 프로퍼티에 접근하기 위해 동적 탐색 대신 히든 클래스 방식 사용해 어느정도 성능 보장

## 1) 변경 가능한 값

- 객체는 변경 가능한 값
- 원시 값을 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 원시 값에 접근할 수 있다.
- 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조값에 접근할 수 있다.
    - 참조 값: 생성된 객체가 저장된 메모리 공간의 주소 그 자체. 참조 값을 통해 변수가 객체에 접근 가능
- 원시 값을 할당한 변수를 참조하면 메모리에 저장되어 있는 원시값에 접근
- 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근
- 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다. = 재할당 없이 프로퍼티를 동적으로 추가, 갱신, 삭제 가능
- 객체를 할당한 변수에 재할당을 하지 않았으므로 객체를 할당한 변수의 참조 값은 변경되지 않는다.

```jsx
var person = {
	name: 'Lee'
};
person.name; = 'Kim';
person.address = 'Seoul';
// person 변수는 객체 {name: 'Kim', address: 'Seoul'}을 가리키고(참조하고) 있다. 라고 표현
console.log(person); // {name: 'Kim', address: 'Seoul'} 

```

- 객체 변경 시 원시 값 처럼 이전값 복사하여 새롭게 생성하면 신뢰성이 확보되겠지만 메모리의 효율적 소비가 어렵고 성능이 나빠진다. → 메모리의 효율적 소비 및 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해 객체는 변경 가능한 값으로 설계되어 있다.
- 여러개의 식별자가 하나의 객체 공유 가능
- ❗얕은 복사와 깊은 복사
    - 객체를 프로퍼티 값으로 갖는 경우 얕은 복사 = 한 단계까지만 복사, 깊은 복사 = 객체에 중첩되어 있는 객체까지 모두 복사
        
        ```jsx
        const o = { x: { y: 1 } };
        
        // 얕은 복사
        const c1 = { ...o };
        console.log(c1 === o }; // false
        console.log(c1.x === o.x); // true
        
        // lodash의 cloneDeep을 사용한 깊은 복사
        const _ = require('lodash');
        // 깊은 복사
        const c2 = _.cloneDeep(o);
        console.log(c2 === o); // false
        console.log(c2.x === o.x); // false
        ```
        
    - 얕은 복사와 깊은 복사로 생성된 객체는 원본과는 참조 값이 다른 별개의 객체이지만 얕은 복사는 객체에 중첩되어 있는 객체의 경우 참조값을 복사한다.

## 2) 참조에 의한 전달

- 여러개의 식별자가 하나의 객체를 공유할 수 있다는 것의 의미와 부작용

```jsx
var person = {
	name: 'Lee'
};
// 참조 값을 복사(얕은 복사)
var copy = person;
copy.name = 'Kim';
person.address = 'Seoul';
console.log(person); // {name: 'Kim', address: 'Seoul'};
console.log(copy); // {name: 'Kim', address: 'Seoul'};
```

- 원본 person과 사본 copy는 저장된 메모리 주소는 다르지만 동일한 참조 값 가진다 = 동일한 객체 가리킴 = 두 개의 식별자가 하나의 객체 공유 = 어느 한쪽에서 객체를 변경하면 서로 영향
- 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서는 값에 의한 전달과 동일. → 변수에 저장되어 있는 값이 원시값이냐 참조값이냐가 중요