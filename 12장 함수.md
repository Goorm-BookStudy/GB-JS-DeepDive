## 12장 함수
> 📌 프로그래밍 언어의 함수

- 함수는 객체다.
- 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의하는 것
- 함수 내부로 입력을 전달받는 변수를 ***매개변수***, 입력을 ***인수***, 출력을 ***반환값***이라 한다.
- 함수는 값이며, 여러 개 존재할 수 있으므로 특정 함수 구별을 위해 식별자인 함수 이름을 사용한다.-> 코드 ***가독성 증가***
- 몇 번이든 호출할 수 있으므로 코드의 재사용성이 높다.
- 코드의 중복을 억제하고 재사용성을 높인다 -> 유지보수의 편의성을 높이고 실수를 줄여 코드 ***신뢰성***이 높아진다.
- 함수 정의를 통해 생성한다.
```
function add(x, y) {
	return x + y;
}
```

#### 함수 호출
- 인수를 매개변수를 통해 함수로 전달하면서 함수의 실행을 명시적으로 지시하는 것
```
var result = add(2, 5);
```

#### 함수 리터럴
> 📌 리터럴 - 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기 방식

- JS 함수는 객체 타입의 값이다. -> 함수 리터럴로 생성할 수 있다.
- 함수 리터럴도 평가되어 값을 생성, 이 값은 객체다. 
- function 키워드, 함수 이름, 매개 변수 목록, 함수 몸체로 구성
```
변수에 함수 리터럴을 할당
var f = function add(x + y) {
	return x + y;
}
```

<br/>

|구성 요소|설명|
|-------|---|
|함수 이름|함수 이름은 식별자다. -> 네이밍 규칙 준수 해야함|
||함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다.|
||함수 이름은 생략 가능, 이름이 있는 함수를 기명 함수, 이름 없는 함수를 무명/익명 함수라고 한다.|
|매개변수 목록|0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분|
||각 매개변수에는 함수를 호출할 때 지정한 인수가 순서대로 할당 즉, 매개변수 목록 순서도 의미가 있다.|
||매개변수는 함수 몸체 내에서 변수와 동일 취급, 따라서 매개변수도 네이밍 규칙 준수해야함|
|함수 몸체|함수가 호출되었을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드|
||함수 호출에 의해 실행됨|


##### 일반 객체 vs 함수 객체
- 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.
- 함수 객체는 일반 객체에는 없는 함수 객체만의 고유 프로퍼티를 가진다.

<br/>

### 함수 정의
#### 함수 선언문
- 함수 이름 생략할 수 없다.
- 표현식이 아닌 문이다.
```
function add(x, y) {
	return x + y;
}

/* 생략 불가 */
function (x, y) {
	return x + y;
}
```
- 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없지만 함수 선언문이 변수에 할당되는 것처럼 보이는 경우가 있다.
- JS 엔진이 코드 문맥에 따라 동일한 함수 리터럴을 표현식이 아닌 문인 함수 선언문으로 해석하는 경우와 표현식으로 해석하기 때문이다.
- 함수 이름을 생략할 수 없다는 점을 제외하면 함수 리터럴과 동일하다.
- 기명 함수 리터럴은 함수 선언문 또는 함수 리터럴 표현식으로 해석될 가능성이 있다는 의미다.

<br/>

📌 기명 함수 리터럴은 중의적인 코드다. -> 문맥에 따라 해석이 다르다.
- JS 엔진은 함수 이름이 있는 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석하고
- 함수 리터럴이 값으로 평가되어야 하는 문맥 예를 들면 함수 리터럴을 변수에 할당하거나 피연산자로 사용하면 함수 리터럴로 해석
- 두 방법 모두 함수가 생성되는 것은 동일하지만 함수 생성하는 내부 동작에 차이가 있다.

```
// 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석
var foo = function add(x,y) {
	return x + y;
};

// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석
(var add = function add(x,y) {
	return x + y;
});

add(); // ReferenceError: add is not defined
```
💡 에러 발생 이유
- 함수의 이름(add)은 내부에서만 참조할 수 있는 식별자이다. 외부에서 호출했기 때문에 에러가 발생한다.
- foo를 호출하게 된다면 오류가 발생하지 않는다. -> JS 엔진이 암묵적으로 함수 이름을 식별자로 생성하고 거기에 함수 객체를 할당했기 때문이다.

- ⭐️ 지금까지 우리가 호출한 함수 이름은 사실 객체를 가리키는 식별자를 호출한 것이다.
```
/* 함수를 선언을 코드로 표현하면 이러한 형태이다. */
var add = function add(x,y){    // 앞에 add는 식별자 이름 뒤에 add는 함수 이름이다
	return x + y;
};

console.log(add(2,5)) // 함수의 식별자(add)를 호출한 것이다.
```

<br/>

### 함수 표현식
> 📌 일급 객체 - JS 함수는 값처럼 변수에 할당할 수도 있고 프로퍼티 값, 배열의 요소가 될 수도 있다.

- 함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당 가능하다.
- 이러한 함수의 정의 방식을 ***함수 표현식***이라고 한다.
```
/* 함수를 선언과 동일해 보이지만 함수 이름 생략이 가능하다. */
var add = function(x,y){
	return x + y;
};

console.log(add(2,5))
```

<br/>

🟢 함수 표현식과 함수 선언문은 동일하게 보이지만 그렇지 않다.
- 함수 표현식은 "표현식인 문"이고, 함수 선언문은 "표현식이 아닌 문이다."

<br/>

### 함수 생성 시점과 호이스팅
#### 함수 선언문과 함수 표현식으로 정의한 함수의 생성 시점은 다르다.
##### 함수 선언문 - 런타임 이전에 함수 객체 생성(함수 이름과 동일한 이름의 식별자를 암묵적으로 생성 및 할당)
- 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다. 런타임 이전에 JS 엔진에서 먼저 실행
- 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 JS 고유의 특징을 ***함수 호이스팅***이라고 한다.

> 💡 변수 호이스팅과 함수 호이스팅은 런타임 이전에 식별자를 생성한다는 부분은 동일하지만 변수 호이스팅은 undefined로, 함수 호이스팅은 함수 객체가 할당된다.

<br/>

##### 함수 표현식 - 할당문이 실행되는 시점, 즉 런타임에 평가되어 함수 객체가 생성 된다.
- 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.
- 런타임 이전에 undefined로 초기화된다.
- ⭐️함수 표현식으로 함수를 정의하면 ***함수 호이스팅***이 아닌 ***변수 호이스팅***이 발생한다.⭐️


#### 함수 선언문은 이전에 호출해도 정상적으로 사용 가능하지만, 함수 표현식은 undefined로 초기화된 값이므로 사용에 제약이 있다.

<br/>

### Function 생성자 함수
- JS에서 기본 제공하는 빌트인 Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new 연산자와 함께 호출하면 함수 객체를 생성해서 반환 (new 연산자가 없어도 결과는 동일하다.)
- 클로저를 생성하지 않는 등, 기존 다른 함수와 다르게 작동한다.
- 일반적이지 않고 바람직하지 않은 생성 방식이다.
```
var add = new Funtion('x', 'y', 'return x + y');

console.log(add(2,5))
```

<br/>

### 화살표 함수
- function 키워드를 축약해서 사용, 익명 함수로 정의한다.
- 기존 함수와 this 바인딩 방식, prototype 프로퍼티가 없고 arguments 객체를 생성 x
```
const add = (x + y) => x + y;
```

<br/>

## 함수 호출
- 0개 이상의 인수를 쉼표로 구분해서 나열한다.
- 함수 호출 시 현재 실행 흐름을 중단하고 함수로 실행 흐름을 옮긴다.
- 매개변수에 인수가 순서대로 할당되고 함수 몸체 문들이 실행됨.

<br/>

### 매개변수
- 함수 정의할 때 선언, 함수 몸체 내부에서 변수와 동일하게 취급됨 (함수 호출 시 함수 몸체 내부에서 암묵적으로 매개변수가 생성되고 undefined로 초기화된 이후 인수가 순서대로 할당
- 스코프 유효 범위는 함수 내부
- 인수가 부족해 인수가 할당되지 않은 매개변수는 undefined이다.(처음 초기화 값)
- 초과된 경우는 암묵적으로 arguments 객체 프로퍼티로 보관된다.
```
function add(x,y) {
	console.log(arguments); // Arguments(3) [2, 5, 10]
    
    return x + y;
}

add(2, 5, 10) // 10은 arguments에 저장
```

<br/>

#### 인수 확인
1. JS 함수는 매개변수와 인수의 개수가 일치하는지 확인 x
2. JS는 동적 타입 언어이다. 따라서 JS 함수는 매개변수의 타입을 사전에 지정 불가능하다.

##### 📍 인수 전달을 확인할 필요성이 있다.
- 부적절한 호출을 줄여 런타임 에러를 방지

##### typeof를 사용해 타입 검증 -> 숫자가 아닌 값을 찾는다.

```
function add(x,y){
	if(typeof x !== 'number' || typeof y !== 'number'){
    	throw new TypeError('인수는 모두 숫자만!')'
    }
}
```

##### arguments 객체를 통해 인수 개수를 확인

```
function add(a, b, c){
	a = a || 0
    b = b || 0;
    c = c || 0;
    
    return a + b + c;
}

console.log(add(1, 2, 3)); // 6
console.log(add(1, 2));    // 3
console.log(add(1));       // 1
console.log(add());        // 0
```

##### 매개변수 기본 값
- 매개변수의 기본 값을 지정한다.
```
function add(a = 0, b = 0, c = 0) {
   return a + b + c;
}

console.log(add(1, 2, 3)); // 6
console.log(add(1, 2));    // 3
console.log(add(1));       // 1
console.log(add());        // 0
```

#### 매개변수의 최대 개수
- 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야한다.
- 코드의 가독성, 유지보수성, 역할을 고민했을 때 이상적인 매개변수는 최대 3개 이상 넘지 않도록 권장 그 이상의 경우 하나의 매개변수를 선언하고 객체를 인수로 전달하는 것이 유리하다.

##### 객체를 인수로 사용하기
- 프로퍼티 키만 정확하게 지정하면 매개변수 순서를 고려하지 않아도 된다.
- 명시적으로 인수의 의미 설명 시 프로퍼티 키를 사용하므로 코드의 가독성도 좋아진다.


#### 반환문 
- 함수 호출은 표현식이다. -> 함수 호출 표현식은 return 키워드가 반환하는 표현식의 평가 결과이다.
- return에 명시적 값을 지정하지 않으면 undifend가 반환된다.
- 반환문은 생략 가능하다. 함수의 마지막 문까지 실행 뒤 암묵적으로 undefined 반환'

<br/>

### 참조에 의한 전달과 외부 상태의 변경
```
function changeVal(primitive, obj) {
	primitive += 100;
    obj.name = 'Kim';
}

var num = 100;
var person = { name: 'Lee' }

console.log(num); 
console.log(person)

changeVal(num, person);

console.log(num); // 100
console.log(person) // {name: "Kim"}
```
<br/>

📍원시 값은 값 자체가 복사되어 전달되므로 기존 값이 변경되지 않는다.

📍 객체의 경우 참조 값이 복사되어 전달되므로 값이 변경되는 부수효과가 발생한다.
- 외부 상태를 변경하면 값이 변경될 경우 상태 변화를 추적하기 어렵고 코드의 복잡성을 증가시키며 가독성을 해치게 된다.

> 💡 해결방법 - 객체를 불변 객체로 만들어 사용한다.(객체의 복사본을 만든다. (새롭게 생성하는 것처럼))

- 객체 변경이 필요한 경우 객체의 방어적 복사를 통해 원본 객체를 완전히 복제(깊은 복제)를 통해 새로운 객체를 생성하고 재할당을 통해 교체한다. -> 이를 통해 부수효과 방지


<br/>

### 즉시 실행 함수
- 함수 정의와 동시에 즉시 호출되는 함수
- 단 한 번만 호출된다.
- 기본적으로 무명으로 사용되나, 기명으로도 사용이 가능하지만 다시 호출은 불가능하다.
- (...)로 감싸지 않으면 에러가 발생한다.
- 변수, 함수 이름의 충돌 방지할 수 있다.

>  💡 그룹 연산자로 묶은 이유

- 먼저 함수 리터럴을 평가해서 함수 객체를 생성하기 위해서

```
(function() {
	var a = 3;
    var b = 5;
    return a * b;
}());
```

#### 일반 함수처럼 값 반환, 인수 전달이 가능하다.
```
var res = (function() {
	var a = 3;
    var b = 5;
    return a * b;
}());

console.log(res); // 15

res = (function (a, b) {
	return a * b;
}(3, 5));

console.log(res); // 15
```

<br/>

### 재귀 함수
- 함수 자기 자신을 호출하는 것을 ***재귀 호출***이라고 한다.
- 재귀 함수는 자기 자신을 호출하는 함수이다.
- 함수 내부에서 호출가능한 함수 이름을 이용해 자기 자신을 계속 호출한다. (단, 함수 외부에서 호출 시 식별자를 가리키도록 해야함)
- 팩토리얼 같은 반복되는 처리 구문에 사용한다.
- 자신을 무한 재귀 호출한다. -> 탈출 조건이 없다면 스택 오버플로 에러가 발생한다.

<br/>

### 중접 함수
- 함수 내부에 정의된 함수를 중첩 함수 또는 내부 함수라고한다.
- 중첩 함수를 포함하는 함수를 외부 함수라고 한다.
- 중첩 함수는 자기 자신을 포함하는 외부 함수를 돕는 헬퍼 함수 역할
```
function outer() {
	var x = 1;
    
    // 중첩함수
    function inner () {
    	// 외부 함수의 변수 참조 가능
	    console.log(x + y); // 3
    }
    inner();
}

outer();
```

<br/>

### 콜백 함수
- 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수
- 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 ***고차 함수***라고 한다.
- 외부에서 로직의 일부분을 함수로 전달받아 수행 -> 유연한 구조를 갖는다.
- 고차 함수에 전달되어 헬퍼 함수의 역할 수행 -> 고차 함수는 콜백 함수를 자신의 일부분으로 합성
- 고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출
- 함수형 프로그래밍 패러다임뿐 아니라 비동기 처리(이벤트 처리, Ajax 통신, 타이머 함수 등), 배열 고차 함수에서 활용된다.

> 📌 콜백 함수는 고차 함수에 의해 호출, 이때 고차 함수는 필요에 따라 콜백 함수에 인자를 전달

<br/>

### 순수 함수와 비순수 함수
📍외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수를 ***순수 함수***라고 한다.
- 동일한 인수가 전달되면 동일한 값 반환
- 함수 내부로 전달된 인수에만 의존해 값 생성 및 반환
- 내부 상태에만 의존한다고 해도 호출될 때마다 변화하는 값(현재 시간)이라면 순수 함수 x
- 최소 하나 이상의 인수를 전달 받음 -> 최소 하나도 없으면 존재 의미가 없다. 
- 인수 변경시키지 않는 것이 기본 -> 인수 불변성 유지
```
var cnt = 0;

// 언제나 동일한 인수가 전달되고 동일한 값 반환
function increase(n) {
	return ++n;
}

cnt = increase(cnt);
console.log(cnt); // 1

cnt = increase(cnt);
console.log(cnt); // 2
```

<br/>

📍 외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수 효과가 있는 함수를 ***비순수 함수***라고 한다.

> 💡 외부 상태 - 전역 변수, 서버 데이터, 파일, console, DOM 등

- 함수 외부 상태를 변경하는 부수 효과가 있다.
- 외부 상태에 의존하게 되어 반환 값과 외부 상태를 변경할 수도 있고, 상태 변화 추적이 어렵다.
```
var cnt = 0;

// 언제나 동일한 인수가 전달되고 동일한 값 반환
function increase(n) {
	return ++cnt;       // 외부 상태에 의존하여 외부 상태를 변경
}

// 비순수 함수는 외부 상태를 변경하므로 상태 변화 추적이 어렵다.
increase(cnt);
console.log(cnt); // 1

increase(cnt);
console.log(cnt); // 2
```

<br/>

#### 함수형 프로그래밍
- 순수 함수와 보조 함수 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임
- 로직 내에 조건문과 반목문을 제거해 복잡성을 해결, 변수 사용을 억제하거나 생명주기를 최소화해서 상태 변경을 피해 오류를 최소화하는 것을 목표로 한다.

<br/><br/>
