# 35장 스프레드 문법
- 하나로 뭉쳐진 값들의 집합을 펼쳐 개별적인 값들의 목록으로 만든다.
- 스프레드 문법의 결과는 값이 아니다. (...이 피연산자를 연산하여 값을 생성하는 연산자가 아니다)
- 스프레드 문법의 결과는 변수에 할당 불가 ( 쉼표로 구분하는 값의 목록을 사용하는 문맥에서만 사용 )

```
console.log(...[1, 2, 3]); // 1 2 3

// 문자열은 이터러블이다.
console.log(...'Hello'); // H e l l o

// Map과 Set은 이터러블이다.
console.log(...new Map([['a', '1'],['b','2']])); // ['a', '1'] ['b', '2']
console.log(...new Set([1,2,3])); // 1 2 3

// 이터러블이 아닌 일반 객체는 스프레드 문법의 대상이 될 수 없다.
console.log(...{a: 1, b: 2});
// TypeError
```

<br/>

#### 사용하는 경우
- 함수 호출문의 인수 목록
- 배열 리터럴의 요소 목록
- 객체 리터럴의 프로퍼티 목록

<br/>

## 함수 호출문의 인수 목록에서 사용하는 경우
### Math.max 메서드
- 매개변수 개수를 확정할 수 없는 가변 인자 함수, 여러 개의 인수 중 최대값 반환
- 숫자가 아닌 배열을 전달하면 최대값을 못 구해 NaN 반환

```
Math.max([1,2,3]); // NaN
```

- 개별적인 값들의 목록으로 만들어(스프레드 문법 사용) 최대값을 구한다.
- 이전에는 배열을 펼쳐서 요소들의 목록을 함수의 인수로 전달하고 싶은 경우 Function.prototype.apply를 사용했다.
- 가독성이 좋다.
- Rest 파라미터 문법과 형태가 동일해 혼동의 여지가 있다.(Rest는 인수를 배열로 만들어 받는다)

<br/>

## 배열 리터럴 내부에서 사용하는 경우
### concat
- ES5에서 2개의 배열을 1개의 배열로 결합할 때 사용

```
var arr = [1, 2].concat([3, 4]);
console.log(arr); // [1,2,3,4]

const arr = [...[1,2], ...[3,4]];
console.log(arr); // [1,2,3,4]
```

<br/>

### splice
- 배열 중간에 다른 요소들을 추가하거나 제거할 때 사용

```
var arr1 = [1,4];
var arr2 = [2,3];

arr1.splice(1, 0, arr2);

console.log(arr1); // [1,[2,3],4]

// [1,2,3,4]를 만드려면 [2,3]을 해체해야한다.
Array.prototype.splice.apply(arr1, [1,0].concat(arr2));
console.log(arr1); // [1,2,3,4]
```

- ES6

```
const arr1 = [1,4];
const arr2 = [2,3];

arr1.splice(1, 0, ...arr2);
console.log(arr1); // [1,2,3,4]
```

<br/>

### 배열 복사 slice
- 원본 배열의 각 요소를 얕은 복사하여 새로운 복소본 생성

```
// ES5
var origin = [1,2];
var copy = origin.slice();

console.log(copy); //[1,2]
console.log(copy === origin); // false

// ES6
const origin = [1,2];
const copy = origin.slice();

console.log(copy); //[1,2]
console.log(copy === origin); // false
```

<br/>

### 이터러블을 배열로 변환
- ES5에서 이터러블을 배열로 변환 시 Function.prototype.apply or Function.prototype.call 메서드 사용하여 slice 메서드 호출

```
// ES5
function sum() {
	// 이터러블이면서 유사 배열 객체인 arguments를 배열로 변환
    var args = Array.prototype.slice.call(arguments);
    
    return args.reduce(function (pre, cur) {
    	return pre + cur;
    }, 0);
}

console.log(sum(1,2,3)); // 6
```

- 위 방법은 이터러블이 아닌 유사 배열 객체도 배열로 변환가능

```
// ES6
function sum () {
	return [...arguments].reduce((pre, cur) => pre + cur, 0);
}

console.log(sum(1,2,3)); // 6

// 더 나은 방법 Rest 파라미터 사용

const sum = (...args) => args.reduce((pre,cur) => pre + cur, 0);

console.log(sum(1,2,3,)); // 6
```

- 이터러블이 아닌 유사 배열 객체는 스프레드 문법 대상 x
- 이터러블이 아닌 유사 배열 객체를 배열로 변경하려면 Array.from 메서드를 사용해야 한다.

<br/>

### Array.from
- 유사 배열 객체 또는 이터러블을 인수로 전달받아 배열로 변환하여 반환

```
Array.from(arrayLike); [1,2,3]
```

<br/>

## 객체 리터럴 내부에서 사용하는 경우
- 스프레드 프로퍼티를 사용하면 객체 리터럴의 프로퍼티 목록에서도 스프레드 문법 사용 가능
- 이 경우 이터러블이 아니어도 스프레드 프로퍼티 제안은 일반 객체를 대상으로도 스프레드 문법 사용 허가

```
// 객체 복사
const obj = { x: 1, y:2};
const copy = {...obj};
console.log(copy); // {x:1,y:2}
console.log(obj === copy); // false

// 객체 병합
const merged = {x: 1, y: 2, ...{a: 3, b: 4} };
console.log(merged); // {x: 1, y:2, a:3, b:4}
```

- 스프레드 프로퍼티 제안 이전에는 ES6에서 도입된 Object.assign 메서드를 사용해 여러 개의 객체를 병합 및 특정 프로퍼티를 변경 추가

```
// Object.assign
// 특정 프로퍼티 병합
const merged = Object.assign({}, {x: 1, y: 2}, ...{a: 3, b: 4} });
console.log(merged); // {x: 1, y:2, a:3, b:4}

// 특정 프로퍼티 변경
const merged = Object.assign({}, {x: 1, y: 2}, ...{y: 100} });
console.log(merged); // {x: 1, y:100}

// 특정 프로퍼티 추가
const merged = Object.assign({}, {x: 1, y: 2}, ...{z: 0} });
console.log(merged); // {x: 1, y:2, z: 0}

// ES6
// 특정 프로퍼티 병합
const merged = { ...{x: 1, y: 2}, ...{y: 10, z: 3} };
// 중복될 경우 뒤에 위치한 프로퍼티가 우선권을 가진다.
console.log(merged); // {x: 1, y:10, z:3}

// 특정 프로퍼티 변경
const merged = {... {x: 1, y: 2}, y: 100 };
console.log(merged); // {x: 1, y:100}

// 특정 프로퍼티 추가
const merged = {...{x: 1, y: 2, z: 0 };
console.log(merged); // {x: 1, y:2, z: 0}

```

<br/>
