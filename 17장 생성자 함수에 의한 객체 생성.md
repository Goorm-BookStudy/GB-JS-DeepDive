## 17장 생성자 함수에 의한 객체 생성
### Object 생성자 함수
- new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성 및 반환 이후 프로퍼티 또는 메서드를 추가하여 객체 완성
- 생성자 함수란 new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수 생성자 함수로 생성된 객체를 인스턴스라고 한다.
- Object 외에도 String, Number 등의 빌트인 생성자 함수를 제공한다.
- 특별한 이유가 없다면 유용하지 않은 방식
```
const person = new Object();

person.name = 'Lee';
person.hi = function() {
	console.log('hi');
}

console.log(person) // {name: "Lee", hi: f}
person.hi(); // "hi"
```

<br/>

### 생성자 함수
- 객체 리터럴에 의한 객체 생성의 경우 매번 같은 프로퍼티를 기술해야하는 비효율적인 문제가 발생한다. 생성자 함수에 의한 객체 생성의 경우 객체를 생성하기 위한 템플릿처럼 동일한 객체를 여러 개 간편하게 생성 가능하다.
- new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작하고 없다면 일반 함수로 동작한다.
- 인스턴스를 생성하는 것과 생성된 인스턴스를 초기화(인스턴스 프로퍼티 추가 및 초기값 할당)하는 생성 과정을 거친다. 인스턴스 생성은 필수지만 초기화는 옵션이다
```
function Circle(radius) {
	this.radius = radius; 	        // 초기화는 선택이다.
    this.getDiameter = function() {
    	return 2 * this.radius;
    };
}
```

<br/>

#### 생성자 함수의 인스턴스 생성 과정
- new 연산자로 생성한 생성자 함수는 반환(return)하는 코드가 없어도 JS 엔진에서 암묵적으로 인스턴스를 생성 및 초기화 후 암묵적으로 인스턴스를 반환한다.

1. 인스턴스 생성과 this 바인딩
- 암묵적으로 빈 객체가 생성되는데(아직 완성되지 않은) 이 빈 객체가 생성자 함수가 생성한 인스턴스이다.
- 그리고 이 빈 객체, 즉 인스턴스는 this에 바인딩 된다. -> 생성자 함수 내부의 this가 생성자 함수가 생성한 인스턴스를 가리키는 이유
- 런타임 이전에 실행된다.

<br/>

> 📌 바인딩
- 식별자와 값을 연결하는 과정

<br/>

2. 인스턴스 초기화
- 생성자 함수의 기술되어 있는 코드를 한 줄씩 실행하며 this에 바인딩되어 있는 인스턴스를 초기화 -> 생성자 함수가 인수로 전달받은 초기값을 프로퍼티에 초기화 or 고정값 할당, 인스턴스에 프로퍼티나 메서드 추가

3. 인스턴스 반환
- 생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적 반환(return 없이)
- tihs가 아닌 다른 객체를 명시적으로 반환하면 return 문에 명시한 객체 반환, 원시 값 반환 시 값은 무시되고 암묵적으로 this 반환
- 생성자 함수 내부에서 return 문은 반드시 생략해야 한다.

<br/>

### 내부 메서드 [[Call]], [[Construct]]
- 함수 선언문 또는 함수 표현식으로 정의한 함수는 일반적인 함수로서 호출할 수 있고 생성자 함수로도 호출 가능
- 함수는 객체이므로 객체와 동일하게 동작, 함수 객체는 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드를 모두 가진다.
- 일반 객체는 호출 불가능하지만 함수 객체는 가능하므로 일반 객체가 가지는 내부 슬롯과 메서드 외에 함수로서 동작하기 위해 함수 객체만을 위한 [[Environment]], [[FormalParameters]] 등의 내부 슬롯과 [[Call]], [[Construct]] 같은 내부 메서드를 추가로 가진다.

<br/>

> 💡 함수가 일반 함수로서 호출되면 함수 객체의 내부 메서드 [[Call]]이 호출되고 new 연산자와 함께 생성자를 함수로서 호출되면 내부 메서드 [[Construct]]가 호출된다.
- 내부 메서드 [[Call]]을 갖는 함수 객체를 callable, 내부 메서드 [[Construct]]을 갖는 함수 객체를 constructor, [[Construct]]를 갖지 않는 함수 객체를 non-constructor 라고 부른다.
- 즉 함수 객체는 반드시 callable이면서 constructor이거나 callable이면서 non-constructor이다.

<br/>

#### constructor, non-constructor 구분
- JS 엔진은 함수 정의를 평가하여 함수 객체를 생성할 때 함수 정의 방식에 따라 함수를 구분
- constructor - 함수 선언문, 함수 표현식, 클래스
- non-constructor - 메서드(ES6 메서드 축약 표현), 화살표 함수

<br/>

#### 생성자 함수와 일반 함수 구분
- 두 함수는 사실 호출 방법이 다를 뿐 큰 차이가 없다.
- 생성자 함수는 일반적으로 첫 문자를 대문자로 기술하는 파스칼 케이스를 사용한다.
- new.target을 통해 함수 내부에서 어떤 함수로 호출되었는지 구분이 가능하다. new 연산자와 함께 호출되면 함수 내부의 new.targe은 함수 자신을 가리킨다. 일반 함수로 호출될 경우 undefined로 호출된다.
```
if(!new.target) // 생성자 함수로 호출되지 않은 경우를 방지가 가능하다.
```

- 대부분의 빌트인 생성자 함수는 new 연산자와 호출되었는지를 확인 후 적절한 값을 반환
(Object와 function 생성자 함수는 new 연산자 없이도 new 연산자와 함께 호출된 결과와 동일하게 작동)
- 나머지 빌트인 생성자 함수들은 new 연산자가 없다면 문자열, 숫자, 불리언 값을 반환한다. 이를 통해 데이터 타입을 변환하기도 한다.
