# 47장 에러 처리
## 에러 처리의 필요성
- try...catch 문을 사용하여 발생한 에러를 적절하게 대응하면 프로그램이 강제 종료되지 않고 계속해서 코드 실행이 가능하다.
- 예외 상황이 발생했을 경우 적절한 대처가 필요하다.

```
// DOM에 button 요소가 존재하지 않으면 querySelector 메서드는 에러를 발생시키지 않고 null을 반환한다. 
const $button = document.querySelector('button'); null

$button.classList.add('disabled');
// TypeError: Cannot read property 'classList' of null
```

- querySeletor 메서드는 인수로 전달한 문자열이 CSS 선택자 문법에 맞지 않는 경우 에러를 발생시킨다.

```
// 옵셔널 체이닝 연산자 `?.`을 사용해서 에러를 막음
const $button = document.querySeletor('button'); // null
$button?.classList.add('disabled');
```

- 모든 에러 대응은 불가능하다. 예외적인 상황 발생을 전제하고 대응하는 코드 작성이 필요하다.

<br/>

## try...catch...finally
- 예외 상황이 발생하면 반환하는 값(null or 1)을 if 문이나 단축 평가 또는 옵셔널 체이닝 연산자를 통해 확인해서 처리하는 방법과 에러 처리 코드를 미리 등록하고 발생 시 에러 처리 코드로 점프하는(try...catch) 방법이 있다.

```
try {
  // 실행할 코드(에러가 발생할 가능성이 있는 코드)
} catch (err) {
  // try 코드 블록에서 에러가 발생하면 이 코드 블록의 코드가 실행된다.
  // err 에는 try 코드 블록에서 발생한 Error 객체가 전달된다.
} finally {
  // 에러 발생과 상관없이 반드시 한 번 실행된다.
}
```

- try 코드 블록에서 발생된 에러는 catch 문의 err 변수에 전달되고 catch 코드 블록이 실행된다.
- 프로그램이 에러가 발생해도 강제 종료되지 않는다.

<br/>

## Error 객체
- Error 생성자 함수는 에러 객체를 생성한다.
- 에러를 상세히 설명하는 에러 메시지를 인수로 전달 가능

```
const error = new Error('invalid');
```

- message(에러 메시지), stack(에러를 발생시킨 콜스택의 호출 정보를 나타내는 문자열이며 디버깅 목적으로 사용) 프로퍼티를 갖는다.

<br/>

#### Error 생성자 함수를 포함해 7가지의 에러 객체를 생성할 수 있는 Error 생성자 함수를 제공

1. Error 생성자 함수: 일반적 에러 객체
2. SyntaxError 생성자 함수: JS 문법에 맞지 않는 문 해석할 때 발생하는 에러 객체
3. ReferenceError 생성자 함수: 참조할 수 없는 식별자 참조 시 발생하는 에러 객체
4. TypeError 생성자 함수: 피연산자 또는 인수의 데이터 타입이 유효하지 않을 때 발생하는 에러 객체
5. RangeError 생성자 함수: 숫자값의 허용 범위를 벗어났을 때 발생하는 에러 객체
6. URIError 생성자 함수: encodeURI 또는 decodeURI 함수에 부적절한 인수 전달했을 때 발생하는 에러 객체
7. EvalError 생성자 함수: eval 함수에서 발생하는 에러 객체

<br/>

## throw 문
- 에러 객체를 생성한다고 에러가 발생하지는 않는다. 에러 객체 생성과 에러 발생은 의미가 다르다.

```
try{
    throw new Error('에러');
} catch(err){
    console.error(err); // Error: 내가만든에러
}
```

- try 코드 블록에서 throw 문으로 에러 객체를 던져야 한다.

<br/>

> throw 표현식;

<br/>

- 에러를 던지면 catch 코드 블록이 실행되기 시작한다.

```
try {
  // 에러 객체를 던지면 catch 코드 블록이 실행되기 시작한다.
  throw new Error('something wrong');
} catch (error) {
  console.log(error); // Error: something wrong
}
```

<br/>

## 에러의 전파
- 호출자 방향으로 전파된다. 즉 콜 스택의 아래 방향(실행 중인 실행 컨텍스트가 푸시되기 직전에 푸시된 실행 컨텍스트 방향)으로 전파

```
const foo = () => {
  throw Error('foo에서 발생한 에러'); // 4
};

const bar = () => {
  foo(); // 3
};

const baz = () => {
  bar(); // 2
};

try {
  baz(); // 1
} catch (err) {
  console.error(err);
}
```

- 1에서 baz 함수 호출 시 2에서 bar 함수가 호출되고 3에서 foo 함수가 호출되고 fOO 함수는 4에서 에러를 throw 한다. 
- 이때 foo 함수가 throw한 에러는 호출 방향 으로 전파된다 이때 이 에러를 catch 하여 대응하지 않으면 프로그램이 강제 종료된다.
- 비동기 함수인 setTimeout이나 프로미스 후속 처리 메서드의 콜백 함수는 호출자가 없으니 주의가 필요하다.(태스크 큐나 마이크로태스크 큐에 일시 저장되었다가 콜 스택이 비면 이벤트 루프에 의해 콜스택으로 푸시되어 실행)
- 이때 콜 스택에 푸시된 콜백 함수의 실행 컨텍스트는 콜 스택의 가장 하부에 존재하게 된다. -> 에러를 전파할 호출자 존재 x
