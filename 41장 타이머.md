# 타이머
## 호출 스케줄링
- 일정 시간이 경과된 이후에 호출되도록 함수 호출을 예약하려면 타이머 함수를 사용한다. 이를 호출 스케줄링이라 한다.
- JS는 타이머를 생성할 수 있는 타이머 함수 setTimeout과 setInterval, 타이머를 제거할 수 있는 타이머 함수 clearTimeout과 clearInterval을 제공한다. (ECMAScript 사양에 정의된 빌트인 함수는 아니다. 브라우저 환경과 Node.js 환경에서 모두 전역 객체의 메서드로서 타이머 함수 제공 즉 호스트 객체다.)
- 타이머 함수는 모두 일정 시간이 경과된 이후 콜백 함수가 호출되도록 타이머를 생성한다. (만료되면 콜백함수 호출)
- setTimeout 생성한 타이머는 단 한 번 동작하고 setInterval 함수가 생성한 타이머는 반복 동작한다.(만료 될때마다 계속 호출)
- JS는 단 하나의 실행 컨텍스트를 갖기 때문에 두 가지 이상의 태스크를 동시에 실행 불가 -> 싱글 스레드 동작 이런 이유로 타이머 함수는 비동기 처리 방식으로 작동

<br/>

## 타이머 함수
### setTimeout/clearTimeout
- 두 번째 인수로 전달받은 시간으로 단 한 번 동작하는 타이머를 생성하고 만료되면 첫 번째 인수로 전달받은 콜백 함수 호출
- 두 번째 인수 전달을 생략할 경우 0으로 지정
- 세 번째 인수로는 콜백 함수에 전달할 인수를 전달
- 고유한 타이머 id를 반환한다 브라우저 환경의 경우 숫자이며 node.js 환경은 객체다.

```
setTimeout(name => console.log(`hi ${name}, 1000, 'Lee');

// clearTimeout 함수는 호출 스케줄링을 취소
const timerId = setTimeout (() => console.log('hi), 1000);

clearTimeout(timerId);
```

<br/>

### setInterval/clearInterval
- 두 번째 인수로 전달받은 시간으로 반복 동작하는 타이머 생성
- setTimeout과 동일하게 고유한 타이머 id를 반환하고 이를 통해 타이머 취소가 가능하다

```
let count = 1;

const timeoutId = setInterval(() => {
	console.log(count); // 1 2 3 4 5
    
    if(count++ === 5) clearInterval(timeoutId);
}, 1000);
```

<br/>

## 디바운스와 스로틀
- scroll, resize, input, mousemove 같은 이벤트는 짧은 시간 간격으로 연속해서 발생한다. 과도한 호출은 성능에 문제를 일으킬 수 있다. 디바운스와 스로틀은 연속해서 발생하는 이벤트를 그룹화해 과도한 이벤트 발생을 방지한다.

<br/>

### 디바운스
- 짧은 시간 간격으로 이벤트 발생 시 이벤트 핸들러를 호출하지 않다가 일정 시간 경과 이후 이벤트 핸들러 한 번만 호출

```
const $input = document.querySelector('input');
const $msg = document.querySelector('.msg') ;

const debounce = (callback, delay) => {
  let timerId;
  // debounce는 timerId를 기억하는 클로저를 반환
  return event => {
    // delay가 끝나기 전에 또 이벤트가 발생하면 이전 타이머를 취소하고 새 타이머 재설정함
    // delay보다 짧은 간격으로 발생한 이벤트에는 callback이 호출되지 않음
    if (timerId) clearTimeout(timerId);
    timerId = setTimeout(callback,delay,event);
  };
};

// 300ms 동안 이벤트가 없으면 콜백이 한번만 실행됨
 $input.oninput = debounce(e => {
   $msg.textContent = e.target.value;
 },300);
```

![](https://velog.velcdn.com/images/mintmin0320/post/c5067570-7672-4960-9e31-4306b3c38467/image.png)

- resize 이벤트 처러, input 요소에 입력된 값으로 ajax 요청하는 입력 필드 자동완성, UI 구현, 버튼 중복 클릭 방지 처리 등에 유용하다.
- 실무에서는 Underscore - debounce 혹은 Lodash - debounce 사용 권장

<br/>

### 스로틀
- 짧은 시간 연속적으로 이벤트가 발생해도 일정 시간 간격으로 이벤트 핸들러가 최대 한 번만 호출되도록 한다.

```
const throttle = (callback, delay) =>  { 
   let timerId;
  
   // throttle 함수는 timerId를 기억하는 클로저를 반환
   return event => {
   // delay가 경과하기 이전에 이벤트가 발생하연 아무것도 하지 않다가 
   // delay가 경과했을 때 이벤트가 발생하면 새로운 타이머를 재설정한다. 
   // 따라서 delay 간격으로 callbacl＜이 호출된다．
   if (timerId) return;
   timerId = setTimeout(() => {
    callback(event); 
    timerld = null;
   }, delay, event);
  };
};

let normalCount = 0;
$container.addEventListener('scroll',() => {
  $normalCount.textContent = ++normalCount;
});

let throttleCount = 0;

$container.addEventListener('scroll', throttle(() => {
  $normalCount.textContent = ++normalCount;
},100));
```

![](https://velog.velcdn.com/images/mintmin0320/post/54f4942b-1750-4821-823c-2089c2ab2503/image.png)

- scroll 이벤트는 사용자가 스크롤할 때 짧은 시간 간격으로 연속 발생한다. 과도한 호출 방지를 위해 throttle 함수는 이벤트를 그룹화해서 일정 시간 단위로 이벤트 핸들러가 호출되도록 호출 주기를 만든다.
- 두 번째 인수로 전달한 시간이 경과하기 이전에 이벤트가 발생하면 아무것도 하지 않다가 경과했을 때 콜백 함수를 호출하고 새로운 타임를 재설정 한다. debounce와의 차이점은 시간 간격으로 콜백 함수가 호출된다.
- scroll 이벤트, 무한스크롤 UI 구현 등에 유용하게 사용된다.
- 실무에서는 Underscore - throttle 혹은 Lodash - throttle 사용 권장

<br/>
