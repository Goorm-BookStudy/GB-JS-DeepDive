## 10.1 객체란?

- 원시타입: 단 하나의 값만 나타내고 변경 불가능한 값
- 객체 타입: 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조, 변경 가능한 값
- 객체 : 0개 이상의 프로퍼티로 구성된 집합, 프로퍼티는 키와 값으로 구성 = 프로퍼티와 메서드로 구성된 집합체
    - 프로퍼티 값: 함수(일급객체이기 때문)를 포함한 모든 값
    - 프로퍼티 값이 함수 일 경우 일반 함수와 구분하기 위해 메서드라고 부름
    - 프로퍼티: 객체의 상태를 나타내는 값
    - 메서드: 프로퍼티를 참조하고 조작할 수 있는 동작

## 10.2 객체 리터럴에 의한 객체 생성

- 자바스크립트는 프로토타입 기반 객체 지향 언어로서, 다양한 객체 생성 방법 지원 → 그중 객체 리터럴이 일반적인 방법
    - 객체 리터럴, Object 생성자 함수, 생성자 함수, Object create 메서드, 클래스(ES6)
- 중괄호({}) 내에 0개 이상의 프로퍼티 정의
- 변수에 할당되는 시점에 자바스크립트 엔진이 객체 리터럴을 해석해 객체 생성
    - ❓변수에 할당되는 시점이 런타임을 말하는건가?
- 중괄호 내에 프로퍼티 정의 안하면 빈 객체 생성
- 객체 리터럴의 중괄호는 코드 블록이 아니라 값으로 평가되는 표현식이기에 세미콜론을 붙인다.
- 객체 리터럴 외의 객체 생성 방식은 모두 함수 사용해 객체 생성. 객체 리터럴은 new 연산자와 함께 생성하 호출할 필요 없이 숫자 값이나 문자열을 만드는 것과 유사하게 객체 생성 가능하다는 장점

## 10.3 프로퍼티

- 객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.

```jsx
var person = {
	name: 'Lee',
	age: 20,
	firstName: 'Ung-mo',
	'last-name': 'Lee',
	'': '', // 권장 x
	0: 1,
	var: '' // 권장 x
};
```

- 프로퍼티 나열 시 쉼표(,)로 구분. 마지막 프로퍼티 뒤에는 옵션
- 프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌 값(일반적으로 문자열 이용)
    - 식별자 역할.
    - 식별자 네이밍 규칙 따르지 않으면 따옴표(’’, “”)로 묶어야 함
    - 문자열, 문자열로 평가할 수 있는 표현식을 사용해 프로퍼티 키 동적 생성 가능 → 표현식 대괄호([])로 묶어야 함
    
    ```jsx
    var obj = {};
    var key = 'hello';
    obj[key] = 'world'; // ES5 프로퍼티 키 동적 생성
     // var obj = { [key]: 'world' }; // ES6 계산된 프로퍼티 이름
    ```
    
    - 프로퍼티 키로 빈 문자열 사용해도 에러는 발생하지 않지만 권장 x
    - 프로퍼티 키에 문자열, 심벌 값 이외의 값은 문자열로 암묵적 타입 변환
        - 숫자 리터럴 사용 시 따옴표는 붙지 않지만 내부적으로는 문자열로 변환
    - 예약어(var, function) 사용해도 에러는 발생하지 않지만 권장x
    - 중복 선언 시 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티 덮어씀 → 에러 x
- 프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값

## 10.4 메서드

- 자바스크립트의 함수는 일급 객체이기에 값으로 취급할 수 있어 프로퍼티 값으로 사용 가능
- 프로퍼티 값이 함수 일 경우 일반 함수와 구분하기 위해 메서드라고 부름 → 메서드 = 객체에 묶여 있는 함수

```jsx
var circle = {
	radius: 5,
	getDiameter: function() {
		return 2 * this.radius; // this는 circle가리킴
	}
};
console.log(circle.getDiameter()); // 10
```

## 10.5 프로퍼티 접근

1. 마침표 표기법: 마침표 프로퍼티 접근 연산자(.) 사용
2. 대괄호 표기법: 대괄호 프로퍼티 접근 연산자([…]) 사용
    - 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열(아니면 식별자로 해석)
    - 프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는 이름이면 반드시 대괄호 표기법 사용
        - 프로퍼티 키가 숫자로 이루어진 문자열인 경우는 따옴표 생략 가능
- 프로퍼티 키가 식별자 네이밍 규칙을 준수하면 둘 다 사용 가능
- 연산자 좌측에는 객체로 평가되는 표현식, 우측 또는 내부에는 프로퍼티 키 지정
- 객체에 존재하지 않는 프로퍼티 접근 시 undefined 반환(ReferenceError는 발생하지 않는다)

```jsx
var person = {
	name: 'Lee',
	1: 10
};
console.log(person.name); // Lee
console.log(person['name']); // Lee
console.log(person.age) // undefined

person.1 // SyntaxError
person.'1' // ..
person[1] // 10
person['1'] // 10
```

- `person.last-name` 의 경우 브라우저 환경과 Node.js 환경의 실행 결과가 다르다
    - 공통: person.last-name은 person.last와 연산자인 -, 식별자 name로 구분된다. person 객체에 last를 프로퍼티 키로 하는 프로퍼티가 없기에 person.last는 undefined로 평가된다. 즉, undefined-name과 같다.
    - 브라우저 환경: name(기본값 빈 문자열 ’’)이라는 전역변수(전역 객체 window의 프로퍼티)가 암묵적으로 존재하기에  undefined-’’ = NaN이 된다.
    - Node.js 환경: name이라는 식별자 선언이 없어 ReferenceError: name is not defined 에러 발생

## 10.6 프로퍼티 값 갱신

- 이미 존재하는 프로퍼티에 값 할당 시 프로퍼티 값 생신

## 10.7 프로퍼티 동적 생성

- 존재하지 않는 프로퍼티에 값 할당 시 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값 할당

```jsx
var person = {
	name: 'Lee'
};

person.age = 20;
console.log(person); // {name: 'Lee', age: 20}
```

## 10.8 프로퍼티 삭제

- delete 연산자: 객체의 프로퍼티 삭제
    - 피연산자: 프로퍼티 값에 접근할 수 있는 표현식
- 존재하지 않는 프로퍼티 삭제 시 에러 없이 무시

```jsx
delete person.age;
```

## 10.9 ES6에서 추가된 객체 리터럴의 확장 기능

1. 프로퍼티 축약 표현
    - 프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키를 생략 할 수 있다.(프로퍼티 키는 변수 이름으로 자동 생성된다)
    
    ```jsx
    // ES5
    var x = 1, y = 2;
    var obj = {
    	x: x,
    	y: y
    };
    console.log(obj); // {x:1, y:2}
    
    // ES6
    let x = 1, y = 2;
    const obj = { x, y }; // 프로퍼티 축약 표현
    console.log(obj); // {x:1, y:2}
    ```
    
2. 계산된 프로퍼티 이름
    - 문자열 또는 문자열로 타입 변환할 수 있는 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적으로 생성 가능
    - 프로퍼티 키로 사용할 표현식을 대괄호([])로 묶어야 한다.
    
    ```jsx
    // ES5 - 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성하면 객체 리터럴 외부에서 대괄호 표기법을 사용해야함
    var prefix = 'prop';
    var i = 0;
    var obj = {};
    
    // 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성
    obj[prefix + '-' + ++i] = i;
    obj[prefix + '-' + ++i] = i;
    obj[prefix + '-' + ++i] = i;
    console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
    
    // ES6 - 객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 키를 동적 생성 가능
    const prefix = 'prop';
    let i = 0;
    
    // 객체 리터럴 내부에서 계산된 프로퍼티 이름으로 키를 동적 생성
    const obj = {
    	[`${prefix}-${++i}`]: i,
    	[`${prefix}-${++i}`]: i,
    	[`${prefix}-${++i}`]: i
    };
    console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
    ```
    
3. 메서드 축약 표현
    - ES6의 메서드 축약 표현으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작 - 26.2 메서드 참고
    
    ```jsx
    // ES5 - 프로퍼티 값으로 함수 할당
    var obj = {
    	name: 'Lee',
    	sayHi: function() {
    		console.log('Hi! ' + this.name);
    	}
    };
    obj.sayHi(); // Hi! Lee
    
    // ES6 - function 키워드를 생략한 축약 표현 사용
    const obj = {
    	name: 'Lee',
    	// 메서드 축약 표현
    	sayHi() {
    		console.log('Hi! ' + this.name);
    	}
    };
    obj.sayHi(); // Hi! Lee
    ```