# ✏️ 11장 원시 값과 객체의 비교

JS가 제공하는 데이터 타입 7가지는 크게 원시 타입과 객체 타입으로 구분한다.

- 원시 타입
  - 변경 불가능한 값
  - 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 '실제 값'이 저장된다.
  - 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 '원시 값이 복사되어 전달'된다. (값에 의한 전달)
- 참조 타입
  - 변경 가능한 값
  - 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 '참조 값'이 저장된다.
  - 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 '참조 값이 복사되어 전달'된다. (참조에 의한 전달)

## 📌 11.1 원시 값

#### 1. 변경 불가능한 값

한 번 생성된 원시 값은 읽기 전용 값으로서 '변경할 수 없다'.

- 변수: 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 공간을 식별하기 위해 붙인 이름
- 값: 변수에 저장된 데이터로서 표현식이 평가돼 생성된 결과
- 변경 불가능하다는 것은 변수가 아닌 '값'에 대한 진술이다.
  - 변수는 언제든지 재할당을 통해 변수 값을 변경(교체)할 수 있다. (상수는 불가능)
  - 원시 값의 불변성은 데이터의 '신뢰성'을 보장한다.

원시 값을 할당한 변수에 새로운 원시 값을 재할당하면,

1. 새로운 메모리 공간을 확보하고
2. 재할당한 원시 값을 저장한 후
3. 변수는 새롭게 재할당된 원시 값을 가리킨다.
4. 이 때 변수가 참조하던 메모리 공간의 주소가 바뀐다.

4번의 이유는 '변수에 할당된 원시 값이 변경 불가능한 값'이기 때문이다.
따라서 변수 값을 바꾸기 위해 원시 값을 재할당 하면 새로운 공간 확보 후 재할당 값을 저장하고, 변수가 참조하던 메모리 공간의 주소를 변경한다. (불변성)

이런 불변성이 없다면 값의 변경, 상태 변경을 추적하기 어려워진다.

#### 2. 문자열과 불변성

ECMAScript 사양에 문자열 타입(2바이트), 숫자 타입(8바이트) 외에 다른 원시 타입은 크기를 규정하지 않아 브라우저 제조사의 구현에 따라 원시 타입의 크기가 다를 수 있다.

- 문자열은 0개 이상의 문자로 이뤄진 집합이다.
- 1개의 문자는 2바이트의 메모리 공간에 저장된다.
- 문자열은 몇 개의 문자로 이뤄졌느냐에 따라 필요한 메모리 공간의 크기가 결정된다.
- 숫자 값은 1도, 100000도 동일한 8바이트가 필요하지만(배정밀도 '64비트' 부동소수점) 문자열은 그렇지 않다.

- C는 문자열 타입이 없는 대신 하나의 문자를 위한 char 타입이 있어 문자열을 문자의 배열로 처리한다.
- JAVA에서는 문자열을 String 객체로 처리한다.
- JS는 개발자의 편의를 위해 원시 타입인 문자열 타입을 제공한다.

```
var str = 'Hello';
str = 'world';
```

- 문자열 Hello가 생성된 후 식별자 str는 문자열 Hello가 저장된 메모리 공간의 첫 번쩨 메모리 셀 주소를 가리킨다.
- 두 번째 코드가 실행되면 world를 메모리에 생성하고 식별자 str는 이것을 가리킨다.
- Hello, world 모두 메모리에 존재하며, 식별자 str은 Hello를 가리켰다가 world을 가리키게 되었다.

```
var str = 'string';
console.log(str[0]); // s

console.log(str.length); // 6
console.log(str.toUpperCase()); // STRING

str[0] = 'S';
console.log(str) // string
```

- 문자열은 유사 배열 객체면서 이터러블이다.
  - 유사 배열 객체: 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고, length 프로퍼티를 갖는 객체
  - 문자열은 for문으로 순회할 수 있다.
  - 하지만 원시 값이므로 변경할 수 없다.

#### 3. 값에 의한 전달

```
var score = 80;
var copy = score; // score 변수 값이 복사되어 할당된다.

console.log(score, copy) // 80, 80
console.log(score === copy) // true
```

- 값에 의한 전달: 변수에 원시 값을 갖는 변수를 할당하면 할당 받는 변수 copy에는 할당되는 변수 score의 원시 값이 복사되어 전달된다.
- 하지만 동일한 값 80을 가져도 두 80은 서로 다른 메모리 공간에 저장된 별개의 값이다.

```
score = 100;
console.log(score, copy) // 100, 80
console.log(score === copy) // false
```

- score 변수의 값을 변경해도 copy 변수의 값에는 아무 영향도 미치지 않는다.

[참고]

- ECMAScript에 변수를 통해 어떻게 메모리를 관리해야 하는지, 값에 의한 전달이라는 용어도 명확하게 나오지 않는다.
  - 따라서 현재 변수에 원시 값을 갖는 변수를 할당하면 원시 값이 복사되는 것으로 표현했지만, 두 변수가 같은 임시 값을 참조하다가 어느 한 쪽의 변수에 재할당이 이뤄졌을 때 비로소 새로운 메모리 공간에 재할당된 값을 저장하도록 동작할 수도 있다. (python)
- 값에 의한 전달도 사실 값을 전달하는 것이 아니라 메모리 주소를 전달하는 것이다.
  - 단, 메모리 주소를 통해 메모리 공간에 접근해 값을 참조할 수 있다.
  - 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되는 것
  - 변수(식별자)는 값이 아니라 메모리 주소를 기억한다.
- 중요한 것은 결국 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어, 어느 한 쪽에서 값이 변경되어도 영향을 미치지 않는다는 것!

## 📌 11.2 객체

객체는 프로퍼티 수가 정해져 있지 않으며, 동적으로 추가/삭제할 수 있다.
따라서 원시 값처럼 확보해야 할 메모리 공간의 크기를 사전에 정할 수 없다.

- JS 객체는 프로퍼티 키를 인덱스로 사용하는 해시테이블이라고 볼 수 있다.
- 클래스 기반 객체지향 프로그래밍 언어는 사전에 정의된 클래스를 기반으로 객체를 생성한다.
  - 이는 객체 생성 전에 프로퍼티와 메서드가 정해져 있어 그대로 객체를 생성하는 것이다.
  - 객체 생성 이후에 프로퍼티를 추가/삭제를 할 수 없다.
- JS는 클래스 없이 객체를 생성할 수 있고, 생성 이후에도 추가/삭제할 수 있다.
  - 다만 이로 인해 클래스 기반보다 객체 생성 및 프로퍼티 접근에 더 많은 비용이 들어 비효율적이다.
  - 프로퍼티에 접근하기 위해 '동적 탐색' 대신 '히든 클래스'라는 방식으로 성능을 보완한다.
  - 히든 클래스: JAVA처럼 고정된 클래스와 유사하게 동작한다. (**확인 필요**)

#### 1. 변경 가능한 값

객체 타입의 값, 객체는 변경 가능한 값이다.

- 객체를 할당한 변수가 기억하는 메모리 주소로 메모리 공간에 접근하면 참조 값에 접근할 수 있다.
- 참조 값: 생성된 객체가 저장된 메모리 공간의 주소

이 때 person은 객체가 저장된 메모리 공간의 주소, 즉 참조 값을 통해 접근한다.

```
var person = {
    name: 'Hwang'
};
```

변수는 객체를 가리키고 있다 또는 객체를 참조하고 있다.
person 변수는 객체 {name: 'Hwang'}를 가리키고(참조하고) 있다.

```
// 할당이 이뤄지는 시점에 객체 리터럴 해석 및 객체 생성
var person = {
    name: 'Hwang'
};

// person 변수에 저장되어 있는 참조 값으로 실제 객체에 접근
console.log(person); // {name: 'Hwang'}
```

- 원시 값은 변경 불가능한 값으로, 원시 값을 갖는 변수의 값을 변경하려면 '재할당' 외에는 방법이 없다.
- 반면 객체는 변경 가능한 값으로, 재할당 없이 객체를 변경할 수 있다.
- 프로퍼티를 동적으로 추가/삭제하거나 갱신할 수 있다.
- 수정해도 객체를 할당한 변수의 참조 값은 변경되지 않는다.

만약 객체가 원시 값처럼 변경할 때마다 이전 값을 복사해 새롭게 생성한다면 신뢰성은 확보할 수 있지만, 1) 객체의 크기가 클 수도 있고, 2) 객체의 크기가 일정하지 않을 수 있으며, 3) 프로퍼티 값이 객체일 때 복사하는 비용이 많이 들어 비효율적인 메모리 소비를 하게 된다. (**확인 필요**)

따라서 객체는 변경 가능한 값으로 설계 되었지만, 여러 개의 식별자가 하나의 객체를 공유한다는 단점이 있다.

얕은 복사와 깊은 복사로 생성된 객체는 원본과 다른 객체다.
즉 원본과 복사본은 참조 값이 다른 별개의 객체다.

```
const o = { x: { y: 1} };

// 얕은 복사
const c1 = { ...o};
console.log(c1 === o); // false
console.log(c1.x === o.x); // true

// 깊은 복사
const _ = require('lodash');
const c2 = _.cloneDeep(o);
console.log(c2 === o); // false
consoel.log(c2.x === o.x) // false
```

- 얕은 복사 (shallow copy)
  - 객체를 프로퍼티 값으로 갖는 객체의 경우 한 단계까지만 복사하는 것
  - 객체에 중첩되어 있는 객체의 경우 참조 값을 복사한다.
  - 객체를 할당한 변수를 다른 변수에 할당하는 것도 얕은 복사에 해당된다.
- 깊은 복사 (deep copy)
  - 객체에 중첩되어 있는 객체까지 모두 복사하는 것
  - 그래서 원시 값처럼 완전한 복사본을 만든다.
  - 원시 값을 할당한 변수를 다른 변수에 할당하는 것도 깊은 복사에 해당된다.

```
const v = 1;
const c1 = v;
console.log(c1 === v); // true

const o = { x: 1};
const c2 = o;
console.log(c2 === o); // true
```

#### 2. 참조에 의한 전달

여러 개의 식별자가 하나의 객체를 공유하는 것에 대한 부작용

```
var person = {
    name: 'Hwang'
};

// 참조 값을 복사(얕은 복사)
var copy = person;
```

- 객체를 가리키는 변수(원본인 person)를 다른 변수(사본인 copy)에 할당하면 원본의 참조 값이 복사되어 전달된다. (참조에 의한 전달)
- person, copy 모두 동일한 객체를 가리킨다.
- 둘 중 어느 쪽에서 객체를 변경하면 서로 영향을 받게 된다.

```
var person = {
    name: 'Hwang'
};

var copy = person;
console.log(copy === person); // true

copy.name = 'Yoon';
person.address = 'Seoul';

console.log(person); // {name: 'Yoon', address: 'Seoul'}
console.log(copy); // {name: 'Yoon', address: 'Seoul'}
```

- 값에 의한 전달, 참조에 의한 전달 모두 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해 전달한다.
- 다만 식별자가 기억하는 메모리 공간(변수)에 저장된 값이 원시 값/참조 값에 따라 달라진다.
- 따라서 실질적으로 값에 의한 전달만 있을 뿐 참조에 의한 전달은 존재하지 않는다.
- 원시 값인지 참조 값인지 구별을 강조하기 위해 값에 의한 전달, 참조에 의한 전달로 나눈다.
  (JS에는 포인터가 존재하지 않다. 포인터가 있는 다른 프로그래밍 언어의 참조에 의한 전달과 다른 의미를 갖고 있다. **확인 필요**)

```
var person = {
    name: 'Hwang'
};

var person2 = {
    name: 'Hwang'
};

// 둘의 값은 같지만 다른 메모리에 저장된 객체로 동일하지 않다.
console.log(person === person2); // false

// 비교하는 두 부분은 모두 값으로 평가되는 표현식으로, 둘다 동일하게 Hwang으로 평가된다.
console.log(person.name === person2.name) // true
```
