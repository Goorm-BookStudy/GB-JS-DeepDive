# ✏️ 14장 전역 변수의 문제점

## 📌 14.1 변수의 생명 주기

#### 1. 지역 변수의 생명 주기

- 변수는 선언에 의해 생성되고, 할당을 통해 값을 가지며, 언젠가 소멸한다. (생명주기)
- 함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고, 함수가 종료하면 소멸한다.

```
function foo() {
    var x = 'local';
    console.log(x); // local
    return x;
}

foo();
console.log(x); // 참조 오류
```

- 지역 변수 x는 함수 foo가 호출되기 전까지 생성되지 않는다.
- 함수 foo가 종료되면 지역 변수 x도 소멸되어 생명 주기가 종료된다.
- 지역 변수의 생명 주기 === 함수의 생명 주기
  - 지역 변수의 생명 주기가 더 긴 경우도 있다.
  - 변수의 생명주기: 메모리 공간의 확보 ~ 메모리 공간의 해제 ~ 가용 메모리 풀에 반환
  - 변수는 메모리가 해제될 때 까지 유효하다.
  - 할당된 메모리 공간은 그 누구도 참조하지 않을 때 가비지 콜렉터에 의해 해제되어 가용 메모리 풀에 반환된다. 즉 누군가 스코프를 참조하고 있으면 스코프는 소멸하지 않고 생존하게 된다.
  - 따라서 함수가 종료하면 함수가 생성한 스코프도 소멸하지만, 누군가 그 스코프를 참조하고 있다면 해제되지 않고 생존하게 된다. (클로저 참고)

```
var x = 'global';

function foo() {
    console.log(x); // undefined
    var x = 'local';
}

foo();
console.log(x); // global
```

- foo 함수 내부에서 선언된 지역 변수 x는 undefined로 초기화 된 상태다. 따라서 전역 변수 x가 아닌 지역 변수 x를 참조하며, 이 때 지역 변수 x는 아직 값을 할당하지 않은 상태다.
- 호이스팅은 '스코프' 단위로 동작한다.
  - 전역 변수의 호이스팅은 전역 변수의 선언이 전역 스코프의 선두처럼 동작해 전역 전체에서 유효하다.
  - 지역 변수의 호이스팅은 지역 변수의 선언이 지역 스코프의 선두처럼 동작해 함수 전체에서 유효하다.

#### 2. 전역 변수의 생명 주기

함수와 달리 전역 코드는 명시적 호출 없이 실행된다. (코드가 로드되자마자 해석 및 실행)
함수는 함수 몸체의 마지막 문 또는 반환문이 실행되면 종료되지만, 전역 코드는 '더 이상 실행할 문이 없을 때' 종료된다.

[참고]
전역 객체란, 코드가 실행되기 이전 JS 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체를 말한다.브라우저에서는 winndow, node.js에서는 global 객체를 의미한다. 전역 객체는 표준 빌트인 객체와 환경에 따른 호스트 객체 (클라이언트 web API, node.js의 host API), var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.

- 브라우저 환경에서 전역 객체는 window다.
- 브라우저 환경에서 var 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티로 웹 페이지를 닫기 전까지 유효하다.
- var 키워드로 선언한 전역 변수의 생명 주기 === 전역 객체의 생명 주기

## 📌 14.2 전역 변수의 문제점

1. 암묵적 결합

- 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용한다.
- 변수의 유효 범위가 크면 클수록 코드의 가독성은 나빠지고, 오류가 발생할 확률이 높아진다.

2. 긴 생명 주기

- 전역 변수는 생명 주기가 길며 메모리 리소스도 오랜 시간 소비한다.
- 이는 전역 변수의 상태를 변경할 시간도, 기회도 많다는 것을 의미한다.
- var 키워드는 변수의 중복 선언을 허용하므로 의도치 않은 재할당도 이뤄질 수 있다.

3. 스코프 체인 상에서 종점에 존재함

- 전역 변수는 스코프 체인 상 종점에 존재한다.
- 변수 검색 시 전역 변수가 가장 마지막에 검색된다.
- 이는 전역 변수의 검색 속도가 가장 느리다는 것을 의미한다.

4. 네임스페이스(**확인 필요**)의 오염

- 파일이 분리되어 있어도 하나의 전역 스코프를 공유한다.
- 다른 파일에서 동명의 전역 변수나 전역 함수가 같은 스코프에 존재하면 예상치 못한 결과를 야기한다.
- 아래와 같이 브라우저 환경에서 var x = 2로 재할당된다. (이를 위해 모듈 시스템, IIFE 같은 방법으로 변수와 함수를 캡슐화 하고 이름 충돌을 방지한다.)

```
<!-- index.html -->
<script src="script1.js"></script>
<script src="script2.js"></script>

// script1.js
var x = 1;
console.log(x);

// script2.js
var x = 2;
console.log(x);
```

## 📌 14.3 전역 변수의 사용을 억제하는 방법

#### 1. 즉시 실행 함수 (라이브러리에 다수 사용)

함수 정의와 동시에 호출되는 즉시 실행 함수는 단 한 번만 호출된다.
모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.

```
(function() {
    var foo = 10; // 즉시 실행 함수의 지역 함수
    ...
}());

console.log(foo); // 참조 오류
```

#### 2. 네임스페이스 객체

전역에 네임스페이스 역할을 담당할 객체를 생성한다.
그리고 전역 변수처럼 사용할 변수를 프로퍼티로 추가한다.
식별자 충돌은 방지할 수 있지만 객체 자체가 전역 변에 할당되므로 유용하지는 않다.

```
var MYAPP = {};
MYAPP.name = 'Hwang';
console.log(MYAPP.name); // Hwang
```

```
var MYAPP = {};
MYAPP.person = {
    name: 'Hwang',
    address: 'Suwon'
};
console.log(MYAPP.person.name); // Hwang
```

#### 3. 모듈 패턴 (클로저 참고)

관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈로 만든다.
JS의 클로저를 기반으로 동작하며 전역 변수의 억제 + 캡슐화를 구현한다.

- 캡슐화: 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조/조작하는 동작인 메서드를 하나로 묶는 것
- 객체의 특정 프로퍼티나 메서드를 감추기 위해 사용함 (=정보 은닉)
- 객체지향 프로그래밍 언어는 클래스를 구성하는 멤버에 대해 public, private, protected 등 접근 제한자(**확인 필요**)를 사용해 공개 범위를 한정한다.
  - JS는 접근 제한자를 제공하지 않는다.

#### 4. ES6 모듈

ES6 모듈을 사용하면 전역 변수를 사용할 수 없다.

- ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다.
- 따라서 모듈 내에서 var 키워드로 선언한 변수는 전역 변수도, window 객체의 프로퍼티도 아니다.
- 구형 브라우저에서는 동작하지 않으며, 브라웢의 ES6 모듈 기능을 사용하더라도 트랜스파일링 또는 번들링이 필요해 ES6 모듈 기능보다 웹팩 등 모듈 번들러 사용이 일반적이다. (48~49장 참고)
- 모던 브라우저에서 ES6 모듈을 사용하려면 아래와 같이 사용한다.

```
<script type="module" src="lib.mjs"></script>
<script type="module" src="app.mjs"></script>
```
