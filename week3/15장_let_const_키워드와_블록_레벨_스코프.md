# ✏️ 15장 let, const 키워드와 블록 레벨 스코프

## 📌 15.1 var 키워드로 선언한 변수의 문제점

1. 변수 중복 선언 허용: 이로 인한 의도치 않은 변수 값 변경한다.
2. 함수 레벨 스코프: 함수의 코드 블록만을 지역 스코프로 인정한다.
   함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다. (1번 야기)
3. 변수 호이스팅: var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다. (undefined)
   이는 프로그램의 흐름상 맞지 않고, 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다.

## 📌 15.2 let 키워드

ES6에서 도입된 변수 선언 키워드 let

1. 변수 중복 선언 금지: 동명의 변수를 중복 선언하면 문법 에러가 발생한다.
2. 블록 레벨 스코프: 모든 코드 블록을 지역 스코프로 인정한다.

```
let foo = 1; // 전역
{
    let foo = 2; // 지역
    let bar = 3; // 지역
}

console.log(foo); // 1
console.log(bar); // 참조 오류
```

3. 변수 호이스팅: 변수 호이스팅이 발생하지 않는 것처럼 동작한다. (⭐️)

```
console.log(foo); // 참조 오류
let foo;
```

var 키워드로 선언한 변수는 런타임 이전에 JS 엔진에 의해 암묵적으로 선언 / 초기화 단계가 동시에 진행된다.
즉 선언 단계에서 스코프(실행 컨텍스트의 렉시컬 환경)에 변수 식별자를 등록, JS 엔진에 변수의 존재를 알린다.
초기화 단계에서 undefined로 변수를 초기화 해, 스코프에 변수가 존재하기 때문에 선언문 이전에도 접근이 가능하다.

반면 let 키워드로 선언한 변수는 **선언 / 초기화 단계가 분리되어 진행된다.**
런타임 이전에 JS 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되지만, 초기화 단계는 변수 선언문에 도달했을 때 실행된다.
그래서 초기화 단계 이전에 변수에 접근할 시 참조 에러가 발생한다.
**즉, let 키워드로 선언한 변수는 스코프 시작부터 초기화 단계 시작 지점(변수 선언문)까지 변수를 참조할 수 없다.**
이러한 구간을 일시적 사각지대(Temporal Dead Zone)라고 부른다.

```
// 런타임 이전 선언 단계 실행 & 초기화 이전의 TDZ로 변수 참조 불가
console.log(foo); // 참조 오류

// 변수 선언문에서 초기화 진행
let foo;
console.log(foo); // undefined

// 할당문에서 할당 실행
foo = 1;
console.log(foo); // 1
```

**따라서 let 키워드로 선언한 변수는 호이스팅이 발생하지 않는 것처럼 보이지만 그렇지 않다.**
호이스팅이란 변수 또는 함수 선언이 스코프의 맨 위로 끌어올려지는 것을 말한다.
let은 호이스팅이 이뤄지지만, 초기화가 동시에 일어나지 않아 에러가 발생한다.

```
let foo = 1; // 전역 변수
{
    console.log(foo); // 참조 오류 (cannot access 'foo' before initialization)
    let foo = 2; // 지역 변수
}
```

ES6에서 도입된 let, const를 포함 모든 선언을 호이스팅하지만 let, const, class 선언문은 호이스팅이 발생하지 않는 것처럼 동작한다.

4. 전역 객체와 let
   var 키워드로 선언한 지역 변수와 전역 함수, 선언하지 않은 변수에 값을 할당하는 암묵적 전역은 전역 객체 window의 프로퍼티가 되며 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다.
   하지만 let 키워드로 선언한 전역 변수는 전역 객체 windo의 프로퍼티가 아니다.

```
// 브라우저에서만 실행 가능한 예제

var x = 1; // 전역 변수
y = 2; // 암묵적 전역
function foo() {} // 전역 함수

// var 키워드로 선언한 전역 변수 === 전역 객체 window의 프로퍼티
console.log(window.x); // 1
// 전역 객체 window의 프로퍼티는 전역 변수처럼 사용할 수 있다.
console.log(x); // 1

// 암묵적 전역 === 전역 객체 window의 프로퍼티
console.log(window.y); // 2
console.log(y); // 2

// 함수 선언문으로 정의한 전역 함수 === 전역 객체 window의 프로퍼티
console.log(window.foo); // f foo() {}
// 전역 객체 window의 프로퍼티는 전역 변수처럼 사용할 수 있다.
console.log(foo); // f foo() {}
```

```
// 브라우저에서만 실행 가능한 예제
// let, const 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티가 아니다.

let x = 1;

console.log(window.x); // undefined
console.log(x); // 1
```

## 📌 15.3 const 키워드

상수를 선언하기 위해 사용하지만 반두시 상수만을 위해 사용하는 것은 아니다.
let 키워드와 대부분 동일하나 차이점이 존재한다.

1. 선언과 초기화
   const 키워드로 선언한 변수는 **반드시 선언과 동시에 초기화 해야 한다.**
   const 키워드로 선언한 변수는 블록 레벨 스코프를 가지며, 변수 호이스팅이 발생하지 않는 것처럼 동작한다.

```
{
    console.log(foo); // 참조 오류 (not access 'foo' before initialization)
    const foo = 1;
    console.log(foo); // 1
}
console.log(foo); // 참조 오류 (not defined)
```

2. 재할당 금지
   var/let 키워드로 선언한 변수는 재할당이 자유롭지만 const 키워드로 선언한 변수는 재할당이 금지된다. (TypeError 발생)

3. 상수
   const 키워드로 선언한 변수에 '원시 값'을 할당한 경우 변수 값을 변경할 수 없다.
   원시 값은 변경 불가능한 값이므로 재할당 없이 값을 변경할 수 없어, const 키워드를 상수를 표현하는데 사용하기도 한다.

변수의 상대 개념인 상수는 재할당이 금지된 변수로, 이 역시 값을 저장하기 위한 메모리 공간이 필요하기에 변수라고 할 수 있다.
다만 변수는 언제든 재할당을 통해 변수의 값을 변경할 수 있지만, 상수는 재할당이 금지된다.

p.216의 예제처럼 세율과 같이 고정된 값을 사용할 때 상수를 쓰면 유지 보수성이 대폭 상승한다.
상수는 대문자로 선언해 상수임을 명확히 드러내며 스네이크 케이스로 표현하는 것이 일반적이다.

4. const 키워드와 객체
   const 키워드로 선언된 변수에 원시 값을 할당하면 3번에서 말한 것과 같이 값을 변경할 수 없다.
   하지만 const 키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있다. (객체는 변경 가능한 값으로 재할당 없이도 변경 가능)

```
const person = {
    name: 'Yoon'
};

person.name = 'Hwang';
console.log(person); // {name: 'Hwang'}
```

const 키워드는 재할당을 금지할 뿐 '불변'을 의미하는 것이 아니다.
새로운 값을 재할당하는 것은 불가하지만, 프로퍼티의 생성/삭제/값 변경 등 객체를 변경하는 것은 가능하다.
이 때 객체가 변경되더라도 변수에 할당된 참조 값은 변경되지 않는다.

## 📌 15.4 var vs let vs const

변수 선언에는 기본적으로 const를 사용하고, let은 재할당이 필요한 경우에 한정하여 사용하는 것이 좋다.

- ES6을 사용한다면 var 키워드 사용은 지양한다.
- 재할당이 필요한 경우에만 let 키워드를 사용하며 변수의 스코프는 최대한 좁힌다.
- 재할당이 필요 없는 상수와 객체에는 const를 사용한다.
