# ✏️ 17장 생성자 함수에 의한 객체 생성

## 📌 17.1 Object 생성자 함수

new 연산자와 Object 생성자 함수를 호출하면 빈 객체를 생성해 반환한다.

- 빈 객체를 생성한 후 프로퍼티 또는 메서드를 추가해 객체를 완성한다.
- 생성자 함수란 new 연산자와 함께 호출해 객체(인스턴스)를 생성하는 함수다.
- 생성자 함수에 의해 생성된 객체를 인스턴스라고 한다.
- JS는 Object 생성자 함수 외에도 String, Number, Boolean, Function, Array, Date, RegExp, Promise 등 빌트인 생성자 함수를 제공한다. (**예제 확인**)

객체 리터럴로 객체를 생성하는 것이 좀 더 간단하다.

## 📌 17.2 생성자 함수

##### 1. 객체 리터럴에 의한 객체 생성 방식의 문제점

동일한 프로퍼티를 갖는 객체를 여러 개 생성할 경우 매번 같은 프로퍼티를 기술해야 하는 비효율성

##### 2. 생성자 함수에 의한 객체 생성 방식의 문제점

객체를 생성하기 위한 템플릿처럼 생성자 함수를 사용해 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있음

```
function Circle(radius) {
    this.radius = radius;
    this.getDiameter = function() {
        return 2 * radius;
    };
}

const circle1 = new Circle(5);
console.log(circle.getDiameter()); // 10
```

**[참고]**
this는 객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수다.
this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다.

| 함수 호출 방식       | this가 가리키는 값(this 바인딩)        |
| -------------------- | -------------------------------------- |
| 일반 함수로서 호출   | 전역 객체                              |
| 메서드로서 호출      | 메서드를 호출한 객체(마침표 앞의 객체) |
| 생성자 함수로서 호출 | 생성자 함수가 미래에 생성할 인스턴스   |

- 생성자 함수는 객체를 생성하는 함수를 말한다.
- 단 JAVA처럼 클래스 기반 객체 지향 언어의 생성자와 달리 형식이 정해져 있지 않다.
- 따라서 일반 함수와 동일한 방법으로 생성자 함수를 정의하고, new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.
- new 연산자와 함께 생성자 함수를 호출하지 않으면 생성자 함수가 아닌 일반 함수로 동작한다.

##### 3. 생성자 함수의 인스턴스 생성 과정

생성자 함수의 역할

- 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿으로서 동작하는 것
- 즉 인스턴스를 생성하는 것과 생성된 인스턴스를 초기화(인스턴스 프로퍼티 추가 및 초기값 할당)하는 것
- 인스턴스 생성은 필수이며 초기화 과정은 옵션이다.

JS 엔진은 암묵적인 처리를 통해 인스턴스를 생성하고 반환한다.
new 연산자와 함께 생성자 함수를 호출하면 JS는 아래 과정을 거쳐 암묵적으로 인스턴스를 생성, 초기화 후 암묵적으로 반환한다.

1. 인스턴스 생성과 this 바인딩
   암묵적으로 빈 객체가 생성됨. (생성자 함수가 생성한 인스턴스)
   이 빈 객체는 this에 바인딩된다. (식별자와 값을 연결하는 과정)

```
function Circle(radius) {
    console.log(this); // Circle {} (암묵적 인스턴스 생성 및 바인딩)

    this.radius = radius;
    this.getDiameter = function() {
        return 2 * radius;
    };
}
```

2. 인스턴스 초기화
   생성자 함수의 코드가 한 줄씩 실행되어 this에 바인딩 되어 있는 인스턴스를 초기화함
   이 처리는 개발자가 하기 때문에 암묵적이지 않으며 옵션이다.

```
function Circle(radius) {
    this.radius = radius; // this에 바인딩 된 인스턴스 초기화
    this.getDiameter = function() {
        return 2 * radius;
    };
}
```

3. 인스턴스 반환
   생성자 함수 내부에서 모든 처리가 끝나고 완성된 인스턴스가 바인딩된 this를 암묵적을 반환한다.

```
function Circle(radius) {
    // 암묵적으로 빈 객체 생성 후 this에 바인딩
    // this에 바인딩 된 인스턴스 초기화
    this.radius = radius;
    this.getDiameter = function() {
        return 2 * radius;
    };
    // 인스턴스가 바인딩된 this가 암묵적으로 반환됨
}
const circle = new Circle(1);
console.log(circle); // {radius: 1, getDiameter: f}
```

this가 아닌 다른 객체를 명시적으로 반환하면 return문에 명시한 객체가 반환된다.

```
function Circle(radius) {
    // 암묵적으로 빈 객체 생성 후 this에 바인딩
    // this에 바인딩 된 인스턴스 초기화
    this.radius = radius;
    this.getDiameter = function() {
        return 2 * radius;
    };
    // 인스턴스가 바인딩된 this가 암묵적으로 반환됨
    return {};
}
const circle = new Circle(1);
console.log(circle); // {}
```

명시적으로 원시 값을 반환하면 원시 값은 무시되고 암묵적으로 this가 반환된다.

```
function Circle(radius) {
    // 암묵적으로 빈 객체 생성 후 this에 바인딩
    // this에 바인딩 된 인스턴스 초기화
    this.radius = radius;
    this.getDiameter = function() {
        return 2 * radius;
    };
    // 인스턴스가 바인딩된 this가 암묵적으로 반환됨
    return 100;
}
const circle = new Circle(1);
console.log(circle); // {radius: 1, getDiameter: f}
```

**생성자 함수 내부에서 this가 아닌 다른 값을 반환하는 것은 생성자 함수의 기본 동작을 훼손하는 것이므로 생성자 함수 내부에서는 return문을 반드시 생략해야 한다.**

##### 4. 내부 메서드 [[Call]]과 [[Construct]]

함수 선언문/함수 표현식으로 정의한 함수는 함수로서 호출 + 생성자 함수로서도 호출 가능

- 생성자 함수로 호출한다 함은 new 연산자와 함께 호출해 객체를 생성하는 것을 의미함
- 함수는 객체이므로 일반 객체와 동일하게 동작하고, 일반 객체가 가진 내부 슬롯과 내부 메서드를 모두 가지고 있다.
- 단 일반 객체와 달리 함수는 호출할 수 있으므로 함수 객체만을 위한 [[Environment]], [[FormalParameters]] 등 내부 슬롯과 [[Call]], [[Construct]] 같은 내부 메서드를 갖고 있다.
- 일반 함수로 호출되면 함수 객체 내부 메서드 [[Call]]이 호출되고, new 연산자와 함께 생성자 함수로서 호출되면 내부 메서드 [[Construct]]가 호출된다.

- 내부 메서드 [[Call]]을 갖는 함수 객체를 callable이라고 한다.
- 내부 메서드 [[Construct]]를 갖는 함수 객체를 constructor라고 한다.
- 내부 메서드 [[Construct]]를 갖지 않는 함수 객체를 non-constructor라고 한다.
- 함수는 호출 가능한 객체이므로 반드시 callable하지만 constructor일 수도 있고 non-constructor일 수도 있다.
- 즉 모든 함수가 생성자 함수로서 호출할 수 있는 것은 아니다.

##### 5. constructor와 non-constructor의 구분

- constructor: 함수 선언문, 함수 표현식, 클래스
- non-constructor: 메서드, 화살표 함수

```
function foo() {}
const bar = function() {};
const baz = {
    x: function() {} // 일반 함수로 정의되어 메서드로 인정하지 않는다.
};

// 일반 함수로 정의된 함수만이 생성자다.
new foo(); // foo {}
new bar(); // bar {}
```

##### 6. new 연산자

new 연산자와 함께 호출하는 함수는 constructor여야 한다.

```
// 생성자 함수로서 정의하지 않은 일반 함수
function add(x, y) {
    return x+y;
}

// 생성자 함수로서 정의하지 않은 일반 함수를 new 연산자와 함께 호출
let inst = new add();
console.log(inst); // 함수가 객체를 반환하지 않으므로 반환문 무시. 빈 객체 생성 후 반환

// 객체를 반환하는 일반 함수
function createUser(name, role) {
    return { name, role };
}

// 일반 함수를 new 연산자와 함께 호출
inst = new createUser('Hwang', 'admin');
console.log(inst); // {name: 'Hwang', role: 'admin'}
```

new 연산자 없이 생성자 함수를 호출하면 일반 함수로 호출된다.

- 함수 내부의 this는 전역 객체 window를 가리키게 된다.
- 예제의 radius 프로퍼티와 getDiameter 메서드는 전역 객체의 프로퍼티와 메서드가 된다.
- 생성자 함수는 일반적으로 첫 문자를 대문자로 기술하여 일반 함수와 구별할 수 있도록 한다.

##### 7. new.target

생성자 함수가 new 연산자 없이 호출되는 것을 방지하기 위해 new.target 등장

- this와 유사하게 생성자인 모든 함수 내부에서 암묵적인 지역 변수와 같이 사용됨(메타 프로퍼티)
- 함수 내부에서 new.target을 사용하면 new 연산자와 함께 생성자 함수로 호출되었는지 확인할 수 있음
- new 연산자와 함께 생성자 함수로 호출되면 함수 내부의 new.target은 함수 자신을 가리킴
- new 연산자 없이 일반 함수로 호출되면 호출된 함수 내부의 new.target은 undefined가 됨

- new 연산자와 함께 생성자 함수에 의해 생성된 객체는 프로토타입에 의해 생성자 함수와 연결됨
- 이를 통해 new 연산자와 함께 호출되었는지 확인 가능 (19장 참고)
- 대부분의 빌트인 생성자 함수는 new 연산자와 함께 호출되었는지 확인한 후 값을 반환함
  - function, object 생성자 함수는 new 연산자 없이 호출해도 동일하게 동작함
  - String, Number, Boolean 생성자 함수는 new 연산자 없이 호출하면 각각 빌트인에 맞는 값으로 반환함 (이로 데이터 타입이 변환됨)
