## 14장 전역 변수의 문제점
- 변수는 선언에 의해 생성되고 할당을 통해 값을 갖는다.
- 변수는 자신이 선언된 위치에서 생성되고 소멸한다.
- 전역 변수의 생명 주기 == 애플리케이션의 생명 주기
- 지역 변수는 함수가 호출되면 생성되고 종료되면 소멸 (지역 변수 생명 주기 == 함수의 생명 주기)
- 참조되지 않을 경우 가비지 콜렉터에 의해 해제됨 (스코프도 동일)

<br/>

> ##### 💡 변수의 생명 주기 
메모리 공간 확보(스코프 등록) -> 메모리 공간이 해제되어 가용 메모리 풀에 반환되는 시점(스코프 소멸)

<br/>

### 전역 변수
- 전역 코드는 명시적인 호출 없이 실행 -> 코드 로드 시 곧바로 해석 및 실행
- 마지막 문이 실행되어 더 이상 실행할 문이 없을 때 종료
- var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다. (전역 변수의 생명 주기 == 전역 객체의 생명 주기)

<br/>

> ##### 📌 전역 객체
- 코드 실행 이전 단계에 JS 엔진에 의해 가장 먼저 생성되는 특수한 객체
- 클라이언트 사이드 환경에서는 window, 서버 사이드 환경에서는 global 객체를 의미
- 표준 빌트인 객체(Object, String, Number ...)와 환경에 따른 호스트 객체(클라이언트 API or Node.js 호스트 API, var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다.
- 전역 객체 window는 웹페이지를 닫기 전까지 유효

<br/>

### 전역 변수의 문제점
1. 암묵적 결합
- 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용한다.
- 변수의 유효 범위가 크면 클수록 코드의 가독성은 나빠지고 의도치 않은 상태 변경의 위험성이 높다.

<br/>

2. 긴 생명 주기
- 메모리 리소스도 오랜 기간 소비한다.
- 전역 변수의 상태를 변경할 시간도 길고 기회도 많다.

<br/>

3. 스코프 체인 상에서 종점에 존재
- 변수 검색 시 전역 변수가 가장 마지막에 검색된다. -> 검색 속도가 가장 느리다.

<br/>

4. 네임스페이스 오염
- JS는 파일이 분리되어도 하나의 전역 스코프를 공유한다.
- 다른 파일 내에서 동일한 이름의 전역 변수나 전역 함수가 존재하면 예상치 못한 오류가 발생할 수 있다.

<br/>

### 전역 변수 사용 억제
1. 지역 변수 사용 지향하기
2. 즉시 실행 함수 사용 (단 한 번만 호출)
3. 네임스페이스 객체
- 전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가
- 식별자 충돌 방지 효과가 있다.
- 유용한 방법은 아니다.
```
var MYAPP = {}; // 전역 네임스페이스 객체

MYAPP.name = 'LEE';

console.log(MYAPP.name) // LEE
```

<br/>

4. 모듈 패턴
- 관련 있는 변수와 함수를 모아 즉시 실행함수로 감싸 하나의 모듈을 만든다.
- 클로저 기반으로 작동
- 전역 변수 억제 및 캡슐화까지 구현 가능
- 전역 네임스페이스의 오염을 막는 기능과 한정적이긴 하지만 정보 은닉을 구현하기 위해 사용

<br/>

> 📌 캡슐화 - 객체의 상태를 나타내는 프로퍼티와 메서드를 하나로 묶는 것, 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용(은닉)

<br/>

5. ES6 모듈
- ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공
- var 키워드로 선언한 변수도 window 객체의 프로퍼티가 아니게 된다.
- script 태그에 type = "module" 어트리뷰트를 추가하면 모듈로서 동작하게 된다.
- 확장자는 mjs를 권장

 <br/><br/>
