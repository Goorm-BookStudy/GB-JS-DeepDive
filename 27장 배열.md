# 27장 배열
- 여러 개의 값을 순차적으로 나열한 자료구조
- 배열이 가지고 있는 값은 요소이고 JS의 모든 값은 요소가 될 수 있다. 요소는 배열에서 자신의 위치를 나타내는 0 이상의 정수인 인덱스를 갖는다. (요소에 접근할 때 사용) 접근 시 대괄호 표기법 사용
- 요소의 개수(길이)를 나타내는 length 프로퍼티를 갖는다.
- JS에는 배열 타입이 없다. (배열은 객체 타입)
- 배열의 프로토타입 객체는 Array.prototyp이며 배열을 위한 빌트인 메서드를 제공한다.

<br/>

## JS 배열
- 배열의 요소를 위한 각각의 메모리 공간은 동일한 크기를 갖지 않아도 되며 연속적으로 이어져 있지 않을 수도 있다. (희소 배열)
- 배열의 동작을 흉내 낸 특수한 객체다.
- JS 배열의 요소는 사실 프로퍼티 갑시다. 모든 값은 프로퍼티가 될 수 있기 때문에 어떤 타입의 값이라도 배열의 요소가 될 수 있다.
- 인덱스로 배열 요소에 접근하는 경우에 일반적인 배열보다 느리지만 특정 요소에 접근하거나 요소를 삽입 또는 삭제하는 경우에는 일반적인 배열보다 빠르다.

<br/>

### lenght 프로퍼티
- 배열에 요소를 추가하거나 삭제하면 자동 갱신된다.
- 임의의 숫자 값을 명시적으로 할당 가능하다. length 프로퍼티 값보다 작은 숫자 값을 할당하면 배열의 길이가 줄어든다. 단, 큰 값을 할당하면 값은 변경되나 실제 배열의 길이가 늘어나지는 않는다. ( 값 없이 비어있는 요소를 위해 메모리 공간을 확보하지 않는다. )

<br/>

### 희소 배열
- lenghth와 배열 요소의 개수가 일치하지 않는다.
- 희소 배열의 lenghth는 희소 배열의 실제 요소 개수보다 언제나 크다.
- 사용 권장 x - 기본적인 개념과 맞지 않고 성능에 악영향을 준다.

<br/>

## 배열 생성
### 배열 리러털
- 0개 이상의 요소를 쉼표로 구분하여 대괄호로 묶는다.
- 프로퍼티 키가 없고 값만 존재한다.
- 요소를 하나도 추가하지 않으면 배열의 길이가 0이 된다.
- 중간에 요소를 생략하면 희소 배열이 생성된다.

```
const arr = [1,2,3];
console.log(arr.length); // 3
```

<br/>

### Array 생성자 함수
- Array 생성자 함수를 통해 배열 생성
- 전달된 인수의 개수에 따라 다르게 동작하므로 주의 필요
- 전달 인수가 없는 경우 빈 배열을 생성
- Array 생성ㅈ아 함수 내부에서 new target을 확인하기 때문에 new 연산자 없이 호출 가능

```
const arr = new Array(10);

// 이때 생성된 배열은 희소 배열이다. 배열의 요소는 존재하지 않지만 length는 10
console.log(arr) // [empty * 10]
console.log(arr.lenghth); // 10
```

<br/>

### Array.of
- ES6에서 도입
- 전달된 인수를 요소로 갖는 배열 생성
- 전달된 인수가 1개이고 숫자이더라도 인수를 요소로 갖는 배열 생성

```
Array.of(1); // [1]

Array.of(1,2,3); // [1,2,3]

Array.of('string'); // ['string']
```

<br/>

### Array.from
- 유사 배열 객체 또는 이터러블 객체를 인수로 전달받아 배열로 변환하여 반환
- 두 번째 인수로 전달한 콜백 함수를 통해 값을 만들면서 요소를 채울 수 있다.두 번째 전달한 콜백 함수에 첫 번째 인수에 의해 생성된 배열의 요소값과 인덱스 순서를 순차적으로 전달하면서 호출하고 콜백 함수의 반환값으로 구성된 배열을 반환한다.

```
Array.from({length: 3}); // [undefiend, undefiend, undefiend]

Array.from({length: 3}), (_, i) => i); // [0, 1, 2]
```

<br/>

## 배열 요소의 참조
- 대괄호 표기법을 이용해 참조 대괄호에는 인덱스가 와야 한다.
- 존재하지 않는 값은 undefined 반환
- 인덱스를 나타내는 문자열을 플퍼티 키로 갖는 객체다.

```
arr[0]
arr[1]
arr[2]
```

<br/>

## 배열 요소의 추가와 갱신
- 배열에 요소도 동적 추가가 가능하다. 존재하지 않는 인덱스를 사용해 값을 할당하면 새로운 요소가 추가된다.
- 현재 배열의 length 프로퍼티 값보다 큰 인덱스로 새로운 요소를 추가하면 희소 배열이 된다.
- 이미 요소가 존재하는 요소에 값을 재할당하면 요소값이 갱신된다.
- 인덱스는 요소의 위치를 나타내므로 반드시 0 이상의 정수를 사용해야한다

```
const arr = [0];

arr[1] = 1;

console.log(arr); // [0, 1]
console.log(arr.length)l // 2
```

<br/>

## 배열 요소의 삭제
- 배열은 객체이기 때문에 특정 요소를 delete 연산자로 삭제 가능하다.
- 삭제되면 이 배열은 희소 배열이 되며 length 프로퍼티 값은 변하지 않는다.
- 완전 삭제를 위해서는 Array.prototype.splice 메서드를 사용하는 것이 좋다.

<br/>

## 배열 메서드
- Array 생성자 함수는 정적 메서드를 제공한다.
- Array.prototype은 프로토타입 메서드를 제공한다.
- 원본 배열을 변경하는 메서드는 외부 상태를 직접 변경하는 부수 효과가 발생하기 때문에 가급적 원본 배열을 직접 변경하지 않는 메서드를 사용하는 편이 좋다.

<br/>

### Array.isArray
- Array 생성자 함수의 정적 메서드로 전달된 인수가 배열이면 true, 아니면 false 반환

<br/>

### Array.prototype.indexOf
- 원본 배열에서 인수로 전달된 요소를 검색하여 인덱스를 반환
- ES7에 도입된 Array.prototype.includes 메서드를 사용하면 가독성이 더 좋다.

```
const arr = [1,2,2,3];

arr.indexOf(2); // 1
```

<br/>

### Array.prototype.push
- 인수로 전달받은 모든 값을 원본 배열의 마지막 요소로 추가하고 변경된 length 프로퍼티 값을 반환
- 원본 배열 직접 변경
- 성능 면에서 좋지 않다. length 프로퍼티를 사용하여 배열의 마지막 요소에 직접 추가하는 방식이 더 빠르다.

```
const arr = [1, 2];

arr[arr.length] = 3;
console.log(arr); // [1, 2, 3];
```

<br/>

### Array.prototype.pop
- 원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환
- 원본 배열이 빈 배열이면 undefiend 반환
- 원본 배열 직접 변경
- push와 pop 메서드를 사용하면 스택을 쉽게 구현할 수 있다. (Last In Frist Out)

<br/>

### Array.prototype.unshift
- 인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가
- 원본 배열을 직접 변경 하므로 ES6 스프레드 문법을 사용하는 편이 좋다

<br/>

### Array.prototype.shift
- 원본 배열에서 첫 번째 요소를 제거하고 그 요소를 반환
- 빈 배열이면 undefined 반환
- 원본 배열 직접 변경
- shift와 push 메서드를 사용하면 큐를 쉽게 구현 가능하다. (First In First Out)

<br/>

### Array.prototype.concat
- 인수로 전달된 값들을 배열의 마지막 요소로 추가한다.
- 새로운 배열을 반환한다.
- 인수로 전달한 값이 배열인 경우 배열을 해체하여 새로운 배열의 요소로 추가
- ES6 스프레드 문법으로 대체할 수 있다.

```
const arr1 = [1, 2];
const arr2 = [3, 4];

let result = arr1.concat(arr2);
console.log(result); // [1,2,3,4]

result = arr1.concat(3);
console.log(result); // [1,2,3]

result = arr1.concat(arr2, 5);
console.log(result); // [1,2,3,4,5]
```

<br/>

### Array.prototype.splice
- 원본 배열의 중간에 요소를 추가하거나 제거하는 경우 사용
- 3개의 매개변수가 있으며 원본 배열을 직접 변경한다.

```
const arr = [1, 2, 3, 4];

const result = arr.splice(1, 2, 20, 30);

console.log(result); // [2, 3]
// 원본 배열 직접 복사
console.log(arr); // [1, 20, 30, 4]
```

<br/>

### Array.prototype.slice
- 인수로 전달된 범위의 요소들을 복사하여 배열로 반환
- 원본 배열 변경 x
- 인수를 모두 생략하면 원본 배열의 복사본을 생성하여 반환(얕은 복사)

```
const arr = [1, 2, 3];

arr.slice(0,1); // [1]

arr.slice(1, 2) // [2]

console.log(arr); [1,2,3]

const arr = [1, 2, 3];

arr.slice(1); // [2,3]
```

<br/>

### Array.prototype.join
- 원본 배열의 모든 요소를 문자열로 변환후 인수로 전달받은 문자열, 즉 구분자로 연결한 문자열을 반환
- 구분자는 생략 가능하며 기본 구분자는 콤마(,)

<br/>

### Arry.prototype.reverse
- 원본 배열의 순서를 반대로 뒤집는다. ( 원본 배열 변경 )
- 반환값은 변경된 배열이다.

<br/>

### Array.prototype.fill
- 인수로 전달받은 값을 배열의 처음부터 끝까지 요소로 채운다.
- 원본 배열 변경

```
const arr = [1,2,3]

arr.fill(0);

console.log(arr); // [0, 0 , 0]

const arr = new Array(3);
console.log(arr); // [empty * 3]

const result = arr.fill(1);

console.log(arr); // [1, 1, 1]

console.log(result); [1, 1, 1]
```

<br/>

### Array.prototype.includes
- 배열 내에 특정 요소가 포함되어 있는지 확인하여 true or false를 반환
- 첫 번째 인수로 검색할 대상 지정
- 두 번째 인수로 검색을 시작할 인덱스를 전달 -> 생략 시 기본값 0, 음수 전달 시 lenght 프로퍼티 값과 음수 인덱스를 합산하여 검색

<br/>

### Array.porototype.flat
- 인수로 전달한 깊이만큼 재귀적으로 배열을 평탄화
- 중첩 배열을 평탄화할 깊이를 인수 생략 시 기본값 1 인수로 Infinity를 전달하면 중첩 배열을 모두 평탄화

```
[1, [2, 3, 4, 5]].flat(); // [1, 2, 3, 4, 5]
```


<br/>

## 배열 고차 함수
- 고차 함수는 함수를 인수로 전달받거나 함수를 반환하는 함수를 말한다.
- 외부 상태의 변경이나 가변 데이터를 피하고 불변성을 지향하는 함수형 프로그래망에 기반
- 함수형 프로그래밍 - 순수 함수와 보조 함수를 조합해 로직 내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하고 변수 사용을 억제하여 상태 변경을 피하는 프로그래밍 패러다임

<br/>

### Array.prototype.sort
- 배열의 요소를 정렬한다. 원본 배열 직접 변경
- 기본적으로 오름차순 요소 정렬
- 기본 정렬 순서는 유니코드 코드 포인트의 순서를 따른다. 배열의 요소를 일시적으로 문자열로 변환한 후 정렬하므로 ["10", "2"]를 기본 정렬할 경우에 [10, 2]이 되는 현상이 발생한다.
- 정렬 순서를 정의하는 비교 함수를 인수로 전달해야한다.

```
const points = [40, 100, 1, 5, 2, 25, 10];

points.sort((a,b) => a-b);
console.log(points); // [1, 2, 5, 10, 25, 40, 100]

// 객체를 요소로 갖는 배열 정렬
(a, b) => (a[key] > b[key] ? 1 : (a[key] < b[key] ? -1 : 0));
```

<br/>

### Array.prototype.forEach
- for 문을 대체할 수 있는 고차 함수다. 
- 자신을 호출한 배열을 순회하며 수행해야 할 처리를 콜백 함수로 전달받아 반복 호출
- forEach 메서드를 호출한 배열의 요소값과 인덱스, forEach 메서드를 호출한 배열(this)을 순차적으로 전달
- 반환 값은 언제나 undefiend
forEach 메서드의 콜백 함수는 일반 함수로 호출되므로 콜백 함수 내부의 this는 undefiend를 가리킨다. ( 암묵적으로 엄격 모드 적용 )
- this를 일치 시키려면 forEach 메서드의 두 번째 인수로 forEach 메서드의 콜백 함수 내부에서 this로 사용할 객체를 전달한다. ( ES6 화살표 함수를 사용하면 상위 스코프를 참조하기 때문에 더 간결하게 사용 가능하다.
- breack, continue 문 사용 불가 배열의 모든 요소를 빠짐 없이 모두 순회하기 때문에
- for 문에 비해 성능이 좋지는 않지만 가독성이 더 좋다.

```
[1,2,3].forEach((item, index, arr) => {
	console.log(`요소 값 ${item}, 인덱스: ${index}, this: ${JSON.stringify(arr)}`);
    });
    
    /*
    	요소값: 1, 인덱스: 0, tihs: [1,2,3]
       	요소값: 2, 인덱스: 1, tihs: [1,2,3]
       	요소값: 3, 인덱스: 2, tihs: [1,2,3]
    */
}
```

<br/>

### Array.prototype.map
- 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출
- 콜백 함수의 반환값들로 구성된 새로운 배열을 반환 원본 배열 변경 x
- 요소값을 다른 값으로 매핑한 새로운 배열을 생성하기 위한 고차 함수다.
- 생성하여 반환하는 새로운 배열의 length 프로퍼티 값은 map 매서드를 호출한 배열의 lenghth 프로퍼티 값과 반드시 일치한다. 메서드를 호출한 배열과 map 메서드가 생성하여 반환한 배열은 1:1 매핑
- map 메서드를 호출한 배열의 요소값과 인덱스 그리고 map 메서드를 호출한 배열(this)를 순차적으로 전달
- 두 번째 인수로 map 메서드의 콜백 함수 내부에서 this로 사용할 갹채룰 존달할 수 있음 -> 이 부분에서 화살표 함수가 더 용이하다.

### Array.prototype.filter
- 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출
- 콜백 함수의 반환값이 true인 요소들로만 구성된 새로운 배열을 반환
- 원본 배열 변경 x
- 생성하여 반환한 새로운 배열의 length 프로퍼티 값은 filter 메서드를 호출한 배열의 length 프로퍼티 값과 같거나 작다.
- 두 번째 인수에 this로 사용할 객체를 전달할 수 있다 -> 화살표 함수를 사용하는 것이 더 나은 방법
- 특정 요소를 제거할 경우 특정 요소가 중복되어 있다면 중복된 요소가 모두 제거된다.

<br/>

### Array.prototype.redue
- 자신을 호출한 배열을 모든 요소를 순회하며 인수로 전달받은 콜백 함수를 반복 호출
- 콜백 함수의 반환값을 다음 순회 시에 콜백 함수의 첫 번째 인수로 전달하면서 콜백 함수를 호출하여 하나의 결과값을 만들어 반환
- 원본 배열 변경 x
- 첫 번째 인수로 콜백 함수, 두 번째 인수로 초기값을 전달받는다. 콜백 함수에는 인수, 초기값 또는 콜백함수의 이전 반환값, reduce 메서드를 호출한 배열의 요소값과 인덱스, reduce 메서드를 호출한 배열 자체 즉 this가 전달
- 초기값과 배열의 첫 번째 요소값을 콜백함수에 인수로 전달하면서 호출하고 다음 순회에 콜백 함수의 반환값과 두 번째 요소값을 콜백 함수의 인수로 전달하며 호출 -> 이 과정에서 reduce 메서드는 하나의 결과값을 반환

```
const sum = [1, 2, 3, 4].reduce((acc, cur, index, array) => acc + cur, 0);

console.log(sum); // 10
```

<br/>

### Array.prototype.some
- 자신을 호출한 배열의 요소를 순회하면서 인수로 전달된 콜백 함수를 호출한다.
- 콜백 함수의 반환값이 단 한 번이라도 참이면 true 모두 거짓이면 false 반환
- 불리언 타입으로 결과를 반환하고 빈 배열인 경우 언제나 false
- some 메서드의 콜백 함수는 some 메서드를 호출한 요소값과 인덱스, some 메서드를 호출한 배열 자체, 즉 this를 순차적으로 전달받는다.

<br/>

### Array.prototype.every
- 자신을 호출한 배열의 요소를 순회하면서 인수로 전달된 콜백 함수를 호출
- 콜백 함수의 반환값이 모두 참이면 true, 단 한 번이라도 거짓이면 false 반환
- 결과를 불리언 타입으로 반환
- every 메서드의 콜백 함수는 every 메서드를 호출한 요소값과 인덱스, every 메서드를 호출한 배열 자체, 즉 this를 순차적으로 전달받는다.

<br/>

### Array.prototype.find
- 자신을 호출한 배열의 요소를 순회하면서 인수로 전달된 콜백 함수를 호출하여 반환값이 true인 첫 번째 요소를 반환
- 콜백 함수의 반환값이 true인 요소가 없다면 undedfiend 반환
- find 메서드의 콜백 함수는 find 메서드를 호출한 요소값과 인덱스, find 메서드를 호출한 배열 자체, 즉 this를 순차적으로 전달받는다.
- 결과가 true인 요소만 새로운 배열로 반환 배열의 형태가 아닌 해당 요소값

<br/>

### Array.prototype.findIndex
- 자신을 호출한 배열의 요소를 순회하면서 인수로 전달된 콜백 함수를 호출하여 반환값이 true인 첫 번째 요소의 인덱스를 반환
- 콜백 함수의 반환값이 true인 요소가 없다면 -1 반환
- findIndex 메서드의 콜백 함수는 findIndex 메서드를 호출한 요소값과 인덱스, findIndex 메서드를 호출한 배열 자체, 즉 this를 순차적으로 전달받는다.


<br/>

### Array.prototype.flatMap
- map 메서드를 통해 생성된 새로운 배열을 평탄화한다. map 메서드와 flat 메서드를 순차적으로 실행하는 효과가 있다.
- 평탄화의 깊이를 지정할 수 없고 1단계만 평탄화 가능하다.

<br/>
