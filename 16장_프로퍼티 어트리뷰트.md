# 16장 프로퍼티 어트리뷰트

### 1. 내부 슬롯과 내부 메서드

- 내부 슬롯과 내부 메서드는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메서드다. ECMAScript 사양에 등장하는 이중 대괄호([[]])로 감싼 이름들이 내부 슬롯과 내부 메서드다.

  [ECMAScript® 2020 Language Specification](https://262.ecma-international.org/11.0/#sec-object-internal-methods-and-internal-slots)

- 내부 슬롯과 내부 메서드는 ECMAScript 사양에 정의된 대로 구현되어 자바스크립트 엔진에서 실제로 동작 하지만 개발자가 직접 접근할 수 있도록 외부로 공개된 객체 프로퍼티는 아니다. 즉, 내부 슬롯과 내부 메서드는 자바스크립트 엔진의 내부 로직이므로 원칙적으로는 자바스크립트 내부 슬롯과 내부 메서드에 직접적으로 접근할 수 있는 방법을 제공하지 않는다.
  단, 일부 내부 슬롯과 내부 메서드에 한하여 간접적으로 접근할 수 있는 수단을 제공하기는 한다.

```jsx
const o = {};

o.[[Prototype]] // 내부 슬롯은 자바스크립트 엔진의 내부 로직이므로 접근할 수 없다.

o.__proto__  //단, 일부 내부 슬롯과 내부 메서드에 한하여 간접적으로 접근할 수 있는 수단을 제공한다.
// Object.prototype
```

### 2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

: 자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다.

⇒ 프로퍼티 상태란? 프로퍼티의 값, 값의 갱신 가능 여부, 여거 가능 여부, 재정의 가능 여부를 말한다.

- 프로퍼티 어트리뷰트는 자바스크립트 엔진에서 관리하는 내부 상태 값인 슬롯 **[[Value]], [[Writable]], [[Enumerable]], [[Configurable]]**이다.
  ⇒ 따라서 프로퍼티 어트리뷰트에 직접 접근할 수 없지만, Object.getOwnPropertyDescriptors 메서드를 사용하여 간접적으로 확인할 수는 있다.
  ```jsx
  const person = {
  	name: 'Lee'
  };

  console.log(Object.getOwnPropertyDescriptors(person, 'name'));

  // => 프로퍼티 어트리뷰터 정보를 제공하는 프로퍼티 디스크립터 객체를 반환한다.
  // {value: "Lee", writable: true, enumerable: true, configurable: true}

  <ES8부터 변경됨>

  const person = {
  	name: 'Lee',
  };

  person.age = 20;

  console.log(Object.getOwnPropertyDescriptors(person));
  /*
  {
  	name: {value: "Lee", writable: true, enumerable: true, configurable: true}
  	age: {value: 20, writable: true, enumerable: true, configurable: true}
  }
  */
  ```
  ⇒ 만약 존재하지 않는 프로퍼티나 상속받은 프로퍼티에 대한 디스크립터를 요구하면 undefined를 반환한다.
  ⇒ ES8부터 도입된 Object.getOwnPropertyDescriptors 메서드는 모든 프로퍼티의 프로퍼티 어트리뷰드 정보를 제공하는 프로퍼티 디스크립터 객체들을 반환한다.

### 3. 데이터 프로퍼티와 접근자 프로퍼티

- 프로퍼티는 데이터 프로퍼티와 접근자 프로퍼티로 구분할 수 있다.
  - 데이터 프로퍼티
    : 키와 값으로 구성된 일반적인 프로퍼티다. 지금까지 살펴본 모든 프로퍼티는 데이터 프로퍼티다.
  - 접근자 프로퍼티
    : 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티다.

### 3-1. 데이터 프로퍼티

<aside>
💡 데이터 프로퍼티

| 프로퍼티 어트리뷰트 | 프로퍼티 디스크립터 객체의 프로퍼티 | 설명                                                        |
| ------------------- | ----------------------------------- | ----------------------------------------------------------- |
| [[Value]]           | value                               | 프로퍼티 키를 통해 프로퍼티 값에 접근하면 반환되는 값이다.  |
| [[Writable]]        | writable                            | 프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 갖는다. |
| [[Enumerable]]      | enumerable                          | 프로퍼티 열거 가능 여부를 나타내는 불리언 값을 갖는다.      |
| [[Configurable]]    | configurable                        | 프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 갖는다.  |

</aside>

### 3-2. 접근자 프로퍼티

- 접근자 프로퍼티는 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티다.

<aside>
💡 접근자 프로퍼티

| 프로퍼티 어트리뷰트                                                                                                                              | 프로퍼티 디스크립터 객체의 프로퍼티 | 설명                                                                            |
| ------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------- | ------------------------------------------------------------------------------- |
| [[Get]]                                                                                                                                          | get                                 | 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수다.   |
| 즉, 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[Get]] 의 값, 즉 getter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환된다. |
| [[Set]]                                                                                                                                          | set                                 | 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수다. |
| 즉, 접근자 프로퍼티 키로 프로퍼티 값에 저장하면 프로퍼티 어트리뷰트 [[Set]] 의 값, 즉 setter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환된다. |
| [[Enumerable]]                                                                                                                                   | enumerable                          | 데이터 프로퍼티의 [[Enumerable]]와 같다.                                        |
| [[Configurable]]                                                                                                                                 | configurable                        | 데이터 프로퍼티의 [[Configurable]]와 같다.                                      |

</aside>

```jsx
const person = {
  firstName: 'Ungmo',
  lastName: 'Lee',

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },

  set fullName(name) {
    [this.firstName, this.lastName] = name.split(' ');
    //배열 구조분해 할당으로 값을 저장해줌
  },
};

console.log(person.firstName + ' ' + person.lastName); // Ungmo Lee

person.fullName = 'Heegun Lee';
console.log(person); // {fistName: "Heegun", lastName: "Lee"}

console.log(person.fiullName); // Heegun Lee
```

⇒ person 객체의 firstName과 lastName 프로퍼티는 일반적인 데이터 프로퍼티다.

⇒ 메서드 앞에 get, set이 붙은 메서드가 바로 getter, setter 함수이고, getter/setter 함수의 이름 fullName이 접근자 프로퍼티다. 접근자 프로퍼티는 자체적으로 값(프로퍼티 어트리뷰트 [[Value]]를 가지지 않으며 다만 데이터 프로퍼티 값을 읽거나 저장할 때 관여할 뿐이다.

- 접근자 프로퍼티와 데이터 프로퍼티를 구별하는 방법

```jsx
// 일반 객체의 __proto__는 접근자 프로퍼티다.
Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');
// {get: f, set: f, enumerable: true, configurable: true}

// 함수 객체의 prototype은 데이터 프로퍼티다.
Object.getOwnPropertyDescriptor(function () {}, '__proto__');
// {value: {...}, writable: true, enumerable: true, configurable: true}
```

### 4. 프로퍼티 정의

- Object.defineProperty 메서드를 사용하면 프로퍼티의 어트리뷰트를 정의할 수 있다. 인수로는 객체의 참조와 데이터 프로퍼티의 키인 문자열, 프로퍼티 디스크립터 객체를 전달한다.

```jsx
const person = {};

Object.defineProperty(person, 'firstName', {
	value: 'Ungmo',
	writable: true,
	enumerable: true,
	configurable: true
});

Object.defineProperty(person, 'lastName', {
	value: 'Lee',
	//디스크립터 객체의 프로퍼티를 누락시키면 undefined, false가 기본값이다.
});

let descriptor = Object.getOwnPropertyDescriptor(person, 'fistName');
console.log('fistName', descriptor);
// fistName {value: 'Ungmo', writable: true, enumerable: true, configurable: true}

descriptor = Object.getOwnPropertyDescriptor(person, 'lastName');
console.log('lastName', descriptor);
// lastName {value: 'Lee', writable: false, enumerable: false, configurable: false}

1. [[Enumerable]] 값이 false인 lastName 프로퍼티는 열거되지 않는다.
	  => for...in 문이나 Object.keys 등으로 열거할 수 없다.

console.log(Object.keys(person)); // ["firstName"]

2. [[Writable]] 값이 false인 lastName 프로퍼티는 변경할 수 없다.
	  => 변경하려고 하면 에러가 발생하지 않고 무시된다.

person.lastName = 'Kim';

3. [[Configurable]] 값이 false인 lastName 프로퍼티는 삭제할 수 없다.
		=> 삭제하려고 하면 에러가 발생하지 않고 무시된다.

delete person.lastName;
```

```jsx
Object.defineProperty(person, 'firstName', {

	get fullName() {
		return `${this.firstName} ${this.lastName}`;
	},

	set fullName(name) {
		[this.firstName, this.lastName] = name.split(' ');
	}
	enumerable: true,
	configurable: true
});
```

⇒ Object.defineProperty 메서드는 한번에 하나의 프로퍼티만 정의할 수 있다.

⇒ 하지만 Object.defineProperties 메서드를 사용하면 여러 개의 프로터피를 한번에 정의할 수 있다.

### 5. 객체 변경 방지

- 객체는 변경 가능한 값으로 재할당 없이 직접 변경할 수 있다. 즉, 프로퍼티를 추가하거나 삭제할 수 있고, 프로퍼티 값을 갱신할 수 있으며, Object.defineProperty 또는 Object.defineProperties 메서드를 사용하여 프로퍼티 어트리뷰트를 재정의할 수도 있다.
- 자바스크립트는 객체의 변경을 방지하는 다양한 메서드를 제공한다. (각 메서드들은 금지하는 강도에 따라 다르다.)
  | 구분           | 메서드                  | 프로퍼티 추가 | 프로퍼티 삭제 | 프로퍼티 값 읽기 | 프로퍼티 값 쓰기 | 프로퍼티 어트리뷰트 재정의 |
  | -------------- | ----------------------- | ------------- | ------------- | ---------------- | ---------------- | -------------------------- |
  | 객체 확장 금지 | Object.prenetExtensions | ❌            | ⭕️           | ⭕️              | ⭕️              | ⭕️                        |
  | 객체 밀봉      | Object.seal             | ❌            | ❌            | ⭕️              | ⭕️              | ❌                         |
  | 객체 동결      | Object.freeze           | ❌            | ❌            | ⭕️              | ❌               | ❌                         |
  - Object.prenetExtensions는 객체 확장을 금지한다.
    ⇒ Object.isExtensible 메서드로 확인 가능하다 (확장가능하면 true, 불가능하면 false)
  - Object.seal는 객체를 밀봉하여 읽기와 쓰기만 가능하다.
    ⇒ Object.isSealed 메서드로 확인 가능하다 (밀봉되어 있으면 true, 아니면 false)
  - Object.freeze는 객체를 동결한다. 동결된 객체는 읽기만 가능하다.
    ⇒ Object.isfrozen 메서드로 확인 가능하다 (동결되어 있으면 true, 아니면 false)

### 6. 불변 객체

- 위의 변경 방지 메서드들은 얕은 변경 방지로 직속 프로퍼티만 변경이 방지되고 중첩 객체까지는 영향을 주지 못한다. 따라서 Object.freeze 메서드로 객체를 동결하여도 중첩 객체까지 동결할 수 없다.
- 객체의 중첩 객체까지 동결하여 변경이 불가능한 읽기 전용의 불변 객체를 구현하려면 객체를 값으로 갖는 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메서드를 호출해야 한다.

```jsx
function deepFreeze(target) {
  if (target && typeof target === 'object' && !Object.isFrozen(target)) {
    Object.freeze(taget);

    Objcet.keys(target).forEach((key) => deepFreeze(target[key]));
  }
  return target;
}

const person = {
  name: 'Lee',
  address: { city: 'Seoul' },
};

deepFreeze(person);

console.log(Object.isfrozen(person)); // true
console.log(Object.isfrozen(person.address)); // true

person.address.city = 'Busan';
console.log(person); // {name: "Lee", address: {city: "Seoul"}} // 동결 방지 성공
```
