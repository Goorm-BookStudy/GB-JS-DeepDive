# ✏️ 45장 프로미스

- JS는 비동기 처리를 위해 콜백 함수를 사용한다.
- 전통적인 콜백 패턴은 콜백 헬로 가독성이 나쁘고 유지 보수 등에 어려움을 야기한다.
- ES6에서 도입된 프로미스는 이러한 단점을 보완하고 비동기 처리 시점을 명확히 표현하는 장점이 있다.

## 📌 45.1 비동기 처리를 위한 콜백 패턴의 단점

#### 1. 콜백 헬

```
// GET 요청을 위한 비동기 함수
const get = (url, callback) => {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.send();

  xhr.onload = () => {
    if (xhr.status === 200) {
      // 서버의 응답을 콜백 함수에 전달하면서 호출하여 응답에 대한 후속 처리를 한다.
      callback(JSON.parse(xhr.response));
    } else {
      console.error(`${xhr.status} ${xhr.statusText}`);
    }
  };
};

const url = 'https://jsonplaceholder.typicode.com';

// id가 1인 post의 userId를 취득
get(`${url}/posts/1`, ({ userId }) => {
  console.log(userId); // 1
  // post의 userId를 사용하여 user 정보를 취득
  get(`${url}/users/${userId}`, userInfo => {
    console.log(userInfo); // {id: 1, name: "Leanne Graham", username: "Bret",...}
  });
});
```

- 콜백 함수를 통해 비동기 처리 결과에 대한 후속 처리를 수행하는 비동기 함수가 비동기 처리 결과를 가지고, 또다시 비동기 함수를 호출해 콜백 함수가 중첩되고 복잡도가 높아지는 현상
- 비동기 함수는 비동기 처리 결과를 외부에 반환할 수 없고, 상위 스코프의 변수에도 할당할 수 없다.
- 따라서 비동기 함수의 처리 결과에 대한 후속 처리는 비동기 함수 내부에서 수행해야 한다.
- 비동기 함수를 범용적으로 쓰기 위해 비동기 함수에 비동기 처리 결과에 대한 후속 처리를 수행할 콜백 함수를 전달하는 게 일반적

#### 2. 에러 처리의 한계

- 에러는 호출자 방향으로 전파된다.

```
try {
  setTimeout(() => { throw new Error('Error!'); }, 1000);
} catch (e) {
  // 에러를 캐치하지 못함
  console.error('캐치한 에러', e)
}
```

- 비동기 함수인 setTimeout이 호출되면 실행 컨텍스트가 생성되어 콜 스택에 푸시되어 실행된다.
- 비동기 함수이므로 콜백 함수가 호출되는 것을 기다리지 않고 즉시 종료되어 콜 스택에서 제거된다.
- 이후 타이머가 만료되면 콜백 함수는 태스크 큐로 푸시, 콜 스택이 빌 때 이벤트 루프에 의해 콜 스택으로 푸시되어 실행된다.
- 콜백 함수가 실행될 때 이미 setTimemout 함수는 콜 스택에서 제거된 상태다. (콜백 함수를 호출한 함수가 setTimemout이 아님)
- 따라서 콜백 함수가 발생 시킨 에러는 catch블록에서 캐치되지 않는다.

## 📌 45.2 프로미스의 생성

- Promise 생성자 함수 + new 연산자로 프로미스를 생성한다.
- ES6에서 도입된 Promise는 ECMAScript 사양에 정의된 표준 빌트인 객체다.
- Promise 생성자 함수는 비동기 처리를 수행할 콜백 함수 (executor 함수)를 인수로 전달 받는다.
- 이 콜백 함수는 resolve와 reject 함수를 인수로 전달받는다.
- 비동기 처리가 성공하면 resolve 함수를 호출, 실패하면 reject 함수를 호출한다.

```
const promise = new Promise ((resolve, reject) => {
  // Promise 함수의 콜백 함수 내부에서 비동기 처리를 수행함
  if (/* 비동기 처리 성공 */) {
    resolve('result');
  } else { /* 비동기 처리 실패 */
  	reject('failure reason');
  }
});
```

- 프로미스는 비동기 처리가 어떻게 진행되고 있는지 나타내는 상태 정보를 갖는다.

![image](https://velog.velcdn.com/images/saiani1/post/cae4ab2f-3026-440d-af6b-06e806a960c5/image.png)

- 이처럼 프로미스의 상태는 resolve, reject 함수를 호출하는 것으로 결정된다.
- 생성된 직후의 프로미스는 기본적으로 pending 상태로, 비동기 처리 결과에 따라 프로미스의 상태가 변경된다.
- filfilled || rejected 상태를 settled 상태라고 한다. (fulfilled || rejected 상태와 무관하게 pending이 아닌 상태로 비동기 처리가 수행된 상태)
- pending 상태에서 settled 상태로 변화할 수 있지만 일단 settled 상태가 되면 더는 다른 상태로 변화할 수 없다.
- 즉 프로미스는 비동기 처리 상태와 처리 결과를 관리하는 객체다.

## 📌 45.3 프로미스의 후속 처리 메서드

- 프로미스의 비동기 처리 상태가 변화하면 후속 처리를 해야 한다. (fulfilled이면 처리 결과로, rejected면 에러 처리를)
- 따라서 후속 메서드 then, catch, finally를 제공한다.
- 모든 후속 처리 메서드는 프로미스를 반환하며 비동기로 동작한다.

#### 1. Promise.prototype.then

- then 메서드는 2개의 콜백 함수를 인수로 전달 받는다.
  - 1번째 콜백 함수: 프로미스가 fulfilled 상태가 되면 호출. 이때 콜백 함수는 프로미스의 비동기 처리 결과를 인수로 전달 받음
  - 2번째 콜백 함수: 프로미스가 rejected 상태가 되면 호출. 이때 콜백 함수는 프로미스의 에러를 인수로 전달 받음

```
// fulfilled
new Promise(resolve => resolve('fulfilled'))
  .then(v => console.log(v), e => console.error(e)); // fulfilled

// rejected
new Promise((_, reject) => reject(new Error('rejected')))
  .then(v => console.log(v), e => console.error(e)); // Error: rejected
```

- then 메서드는 언제나 프로미스를 반환한다.
- 콜백 함수가 프로미스가 아닌 값을 반환하면 그 값을 암묵적으로 resolve, reject해 프로미스를 생성해 반환한다.

#### 2. Promise.prototype.catch

- catch 메서드는 1개의 콜백 함수를 인수로 전달 받는다.
  - 프로미스가 rejected 상태인 경우만 호출된다.

```
new Promise((_, reject) => reject(new Error('rejected')))
  .catchh(e => console.log(e)); // Error: rejected
```

- catch 메서드는 then과 동일하게 동작하기에 언제나 프로미스를 반환한다.

#### 3. Promise.prototype.finally

- finally 메서드는 1개의 콜백 함수를 인수로 전달 받는다.
  - finally 메서드의 콜백 함수는 프로미스의 성공/실패와 상관 없이 무조건 한 번 호출된다.
  - 프로미스의 상태와 관련 없이 공통으로 수행할 처리 내용이 있을 때 유용하다.
  - 언제나 프로미스를 반환한다.

```
new Promise(() => {})
  .finally(() => console.log('finally')); // finally
```

```
const promiseGet = url => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.send();

    xhr.onload = () => {
      if (xhr.status === 200) {
        // 성공적으로 응답을 전달받으면 resolve 함수를 호출한다.
        resolve(JSON.parse(xhr.response));
      } else {
        // 에러 처리를 위해 reject 함수를 호출한다.
        reject(new Error(xhr.status));
      }
    };
  });
};

// promiseGet 함수는 프로미스를 반환한다.
promiseGet('https://jsonplaceholder.typicode.com/posts/1')
  .then(res => console.log(res))
  .catch(err => console.error(err))
  .finally(() => console.log('Bye!'));
```

## 📌 45.4 프로미스의 에러 처리

- 비동기 처리에서 발생한 에러는 then 메서드의 2번째 콜백 함수로, catch 메서드로도 처리할 수 있다.
- 단, 전자의 경우 에러를 캐치하지 못하고 코드가 복잡해지므로 catch 메서드에서 에러 처리하는 것을 권장한다.
- 또 catch 메서드를 모든 then 메서드 호출 이후 호출하면 비동기 처리 뿐만 아니라 then 메서드 내부의 에러까지 캐치할 수 있다.

## 📌 45.5 프로미스 체이닝

- then, catch, finally 후속 처리 메서드는 언제나 프로미스를 반환하므로 연속적으로 호출할 수 있다.
- 프로미스는 프로미스 체이닝을 통해 비동기 처리 결과를 전달 받아 후속 처리를 하기 때문에 콜백 헬이 발생하지는 않는다.
- 다만 프로미스도 콜백 패턴을 사용하므로 콜백 함수를 사용하지 않는 것은 아니다.
- 콜백 패턴은 가독성이 좋지 않다. 이는 ES8에서 도입된 asncy/await으로 해결할 수 있다.

```
const url = 'https://jsonplaceholder.typicode.com';

(async () => {
  // id가 1인 post의 userId를 취득
  const { userId } = await promiseGet(`${url}/posts/1`);

  // 취득한 post의 userId로 user 정보를 취득
  const userInfo = await promiseGet(`${url}/users/${userId}`);

  console.log(userInfo);
})();
```

## 📌 45.6 프로미스의 정적 메서드

- Promise는 주로 생성자 함수로 사용되지만 함수도 객체이므로 메서드를 가질 수 있다.
- 총 5가지 정적 메서드를 제공한다.

#### 1. Promise.resolve / Promise.reject

- 이미 존재하는 값을 래핑해 프로미스를 생성하기 위해 사용한다.
- resolve 메서드는 인수로 전달받은 값을 resolve하는 프로미스를 생성한다.
- reject 메서드는 인수로 전달받은 값을 reject하는 프로미스를 생성한다.

```
// 배열을 resolve하는 프로미스 생성
const resolvedPromise = Promise.resolve([1, 2, 3]);
resolvedPromise.then(console.log); // [1, 2, 3]

// 에러 객체를 reject하는 프로미스 생성
const rejectedPromise = Promise.reject(new Error('Error!'));
rejectedPromise.catch(console.log); // Error: Error!
```

#### 2. Promise.all

- 여러 개의 비동기 처리를 모두 병렬 처리할 때 사용한다.

```
const requestData1 = () => new Promise(resolve => setTimeout(() => resolve(1), 3000));
const requestData2 = () => new Promise(resolve => setTimeout(() => resolve(2), 2000));
const requestData3 = () => new Promise(resolve => setTimeout(() => resolve(3), 1000));

// 세 개의 비동기 처리를 순차적으로 처리
const res = [];
requestData1()
  .then(data => {
    res.push(data);
    return requestData2();
  })
  .then(data => {
    res.push(data);
    return requestData3();
  })
  .then(data => {
    res.push(data);
    console.log(res); // [1, 2, 3] => 약 6초 소요
  })
  .catch(console.error);

// Promise.all을 사용하는 경우

const requestData1 = () => new Promise(resolve => setTimeout(() => resolve(1), 3000));
const requestData2 = () => new Promise(resolve => setTimeout(() => resolve(2), 2000));
const requestData3 = () => new Promise(resolve => setTimeout(() => resolve(3), 1000));

Promise.all([requestData1(), requestData2(), requestData3()])
  .then(console.log) // [1, 2, 3] => 약 3초 소요
  .catch(console.error);
```

- 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달 받는다.
- 전달받은 모든 프로미스가 모두 fulfilled 상태가 되면 모든 처리 결과를 배열에 저장해 새로운 프로미스를 반환한다.
- 인수로 전달받은 모든 프로미스가 fulfilled 상태가 되면 종료한다.
- 처리 순서가 보장된다.
- 단 인수로 전달받은 배열의 프로미스가 하나라도 rejected 상태라면 나머지 프로미스를 기다리지 않고 즉시 종료한다.
- 인수로 전달 받은 이터러블의 요소가 프로미스가 아니라면 resolve 메서드로 프로미스로 래핑한다.

#### 3. Promise.race

- 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달 받는다.
- 가장 먼저 fulfilled 상태가 된 프로미스의 처리 결과를 resolve하는 새로운 프로미스를 반환한다.
- 하나라도 프로미스가 rejected 상태가 되면 에러를 reject하는 새로운 프로미스를 즉시 반환한다.

```
Promise.race([
  new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
  new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
  new Promise(resolve => setTimeout(() => resolve(3), 1000)), // 3
])
  .then(console.log) // 3
  .catch(console.log);
```

#### 4. Promise.allSettled

- 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달 받는다.
- 전달받은 프로미스가 모두 settled 상태가 되면 처리 결과를 배열로 반환한다.
- 프로미스가 fulfilled 상태라면 비동기 처리 상태를 나타내는 status 프로퍼티와 처리 결과를 나타내는 value 프로퍼티를 갖는다.
- 프로미스가 rejected 상태라면 비동기 처리 상태를 나타내는 status 프로퍼티와 에러를 나타내는 reason 프로퍼티를 갖는다.

```
Promise.allSettled([
  new Promise(resolve => setTimeout(() => resolve(1), 2000)),
  new Promise((_, reject) => setTimeout(() => reject(new Error('Error')), 1000)),
]).then(console.log);
```

```
Promise.allSettled([
  new Promise(resolve => setTimeout(() => resolve(1), 2000)),
  new Promise((_, reject) => setTimeout(() => reject(new Error('Error!')), 1000))
]).then(console.log);
/*
[
  {status: "fulfilled", value: 1},
  {status: "rejected", reason: Error: Error! at <anonymous>:3:54}
]
*/
```

## 📌 45.7 마이크로태스크 큐

- 태스크 큐와 별도의 큐로 프로미스의 후속 처리 메서드의 콜백 함수가 일시 저장된다.
- 그외 비동기 함수의 콜백 함수나 이벤트 핸들러는 태스크 큐에 일시 저장된다.
- 마이크로태스크 큐는 태스크 큐보다 우선 순위가 높다.
- 이벤트 루프는 콜 스택이 비면 먼저 마이크로태스크 큐에서 대기하는 함수를 가져와 실행한다.
- 이후 마이크로태스크 큐가 비면 태스크 큐에서 대기하는 함수를 가져와 실행한다.

## 📌 45.8 fetch

- HTTP 요청 전송 기능을 제공하는 클라이언트 사이드 Web API
- 프로미스를 지원하고 사용법이 간단하다.
- fetch 함수는 HTTP 응답을 나타내는 Response 객체를 래핑한 Promise 객체를 반환한다.
- fetch함수에는 HTTP 요청을 전송할 URL과 HTTP 요청 메서드, HTTP 요청 헤더, 페이로드 등을 설정한 객체를 전달한다.

```
const promise = fetch(url, [, options])
```

- HTTP 응답을 나타내는 Response 객체를 래핑한 Promise 객체를 반환한다.
- fetch 함수가 반환하는 프로미스는 HTTP 에러가 발생해도 에러를 reject하지 않고 불리언 타입의 상태를 false로 설정한 Response 객체를 resolve한다. 즉 네트워크 장애나 CORS에 의해 요청이 완료되지 못한 경우만 프로미스를 reject한다.
- 따라서 명시적으로 에러를 처리할 필요가 있다.
- axios는 모든 HTTP 에러를 reject하는 프로미스를 반환한다.
  - 또한 인터셉터, 요청 설정 등 다양한 기능을 지원한다.
