# 19장 프로토타입

- 자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어이다.

# 19.1 객체지향 프로그래밍

- 객체지향 프로그래밍: 프로그램을 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍의 절차지향적 관점에서 벗어나 여러 개의 독립적 단위, 즉 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임
- 추상화: 다양한 속성 중에서 프로그램에 필요한 속성만 간추려 내어 표현하려는 것

```jsx
// 이름과 주소 속성을 갖는 객체 -> 프로그래머는 이름과 주소 속성으로 표현된 객체인 person을 다른 객체와 구별하여 인식 가능
const person = {
name: 'Lee',
address: 'Seoul',
};
```

- 속성을 통해 여러개의 값을 하나의 단위로 구성한 복합적인 자료구조 → 객체
- 객체지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임

```jsx
const circle = {
	radius: 5,
	getDiameter() {
		return 2 * this.radius;
	},
}
```

- 원을 객체로 만들어봤을 때, 원에는 반지름이라는 속성이 있고 이 반지름을 가지고 원의 지름을 구할 수 있다. 이때 반지름은 원의 상태를 나타내는 데이터, 원의 지름을 구하는 것은 동작.
- 객체는 상태 데이터(프로퍼티)와 동작(메서드)을 하나의 논리적인 단위로 묶은 복합적인 자료구조.
- 객체는 다른 객체의 상태 데이터나 동작을 상속받아 사용하기도 함.

# 19.2 상속과 프로토타입

- 상속: 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것
- 자바스크립트는 프로토타입을 기반으로 상속 구현, 불필요한 중복 제거 → 기존의 코드 재사용 → 개발 비용 현저히 줄일 수 있음

```jsx
// 생성자 함수
function Circle(radius) {
	this.radius = radius;
	this.getArea = function() {
		return Math.PI * this.radius ** 2;
	};
}

const circle1 = new Circle(1);
const circle2 = new Circle(2);

console.log(circle1.getArea === circle2.getArea); // false
```

- 위의 코드에서 getArea메서드는 모든 인스턴스가 동일한 내용의 메서드를 사용하므로 단 하나만 생성하며 모든 인스턴스가 공유해서 사용학는것이 바람직. 하지만 위에선 인스턴스 생성할 때 마다 getArea 메서드를 중복 생성하고 모든 인스턴스가 중복 소유
- 동일한 생성자 함수에 의해 생성된 모든 인스턴스가 동일한 메서드를 중복 소유하는 것은 메모리를 불필요하게 낭비, 퍼포먼서에도 악영항
- → 상속을 통해 중복 제거! 자바스크립트는 프로토타입을 기반으로 상속 구현

```jsx
// 생성자 함수
function Circle(radius) {
	this.radius = radius;
}

// Circle 생성자 함수가 생성한 모든 인스턴스가 getArea 메서드를 공유해서 사용할 수 있도록 프로토타입에 추가
// 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩 되어있다.
Circle.prototype.getArea = function () {
	return Math.PI * this.radius ** 2;
};

// Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는
// 프로토타입 Circle.prototype으로부터 getArea 메서드를 상속받는다.
// 즉, Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메서드를 공유한다.
console.log(circle1.getArea === circle2.getArea); // true
```

- getArea 메서드는 단 하나만 생성되어 프로토타입인 Circle.prototype의 메서드로 할당되어 있다. 따라서 Circle 생성자 함수가 생성하는 모든 인스턴스는 getArea 메서드를 상속받아 사용 가능
- 상속은 코드의 재사용이란 관점에서 매우 유용

# 19.3 프로토타입 객체

- 프로토타입 객체(=프로토타입): 객체 간 상속을 구현하기 위해 사용. 어떤 객체의 상위 객체의 역할을 하는 객체로서 다른 객체의 공유 프로퍼티(메서드 포함)를 제공. 프로토타입을 상속받은 하위 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용 가능
- 모든 객체는 [[Prototype]] 이라는 내부 슬롯을 가진다.
    - = 프로토타입의 참조값(null인 경우도 있음)
    - [[Prototype]] 에 저장되는 프로토타입은 객체 생성 방식 에 의해 결정
        - ex) 객체 리터럴( { } )로 생성된 객체의 프로토타입 → Object.prototype
        - 생성자 함수에 의해 생성된 객체의 프로토타입 → 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체
    - 모든 객체는 하나의 프로토타입을 갖는다.
        - 모든 프로토타입은 생성자 함수와 연결 되어 있다.
        - 즉, 객체 - 프로토타입 - 생성자 함수는 연결되어 있다.
    - [[Prototype]] 내부슬롯에 직접 접근은 못하지만 __prototype__접근자 프로퍼티를 통해 [[Prototype]] 내부슬록시 가리키는 프로토타입에 간접적으로 접근 가능.
    - 프로토타입은 constructor 프로퍼티를 통해 생성자 함수에 접근 가능, 생성자 함수는 자신의 prototype 프로퍼티를 통해 프로토타입에 접근 가능.

### 1) __proto_ 접근자 프로퍼티

- 모든 객체는 __proto__ 접근자 프로퍼티 를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 간접적으로 접근 할수 있다.
1. **__proto__ 는 접근자 프로퍼티다.**
    - 원칙적으로 내부슬롯과 내부 메서드는 직접적으로 접근, 호출 x
    - 일부 내부 슬롯과 내부 메서드에 한하여 , 간접적으로 접근할 수 있는 수단을 제공
        - __proto__ 는 접근자 프로퍼티 이며, [[Prototype]] 내부 슬롯의 값, 즉 프로토타입에 접근할 수 있다.
        - __proto__ 가 접근자 프로퍼티이므로, getter/setter 접근자 함수 를 통해, 프로토타입을 취득하거나 할당할 수 있는 것.
    
    ```jsx
    const obj = {};
    const parent = { x: 1 };
    
    // __proto__ 접근자 프로퍼티의 getter 접근자 함수로 **obj 객체의 프로토타입 객체 취득**
    console.log(obj.__proto__); // [Object: null prototype] {}
    
    // __proto__ 접근자 프로퍼티의 setter 접근자 함수로 **obj 객체의 프로토타입에 값 할당**
    obj.__proto__ = parent;
    console.log(obj.__proto__); // { x: 1 }
    ```
    
2. **__proto__ 접근자 프로퍼티 는 상속을 통해 사용된다.**
    - __proto__ 접근자 프로퍼티 는 객체가 직접 소유하고 있는 프로퍼티가 아닌, Object.prototype 의 프로퍼티다.
    - 즉, 모든 객체는 상속을 통해 Object.prototype.__proto__ 접근자 프로퍼티 를 사용할 수 있다.
    
    ```jsx
    const obj = {};
    
    // obj 객체는 __proto__ 접근자 프로퍼티를 직접 소유하지는 않는다.
    // Object.prototype 에 __proto__ 프로퍼티를 상속받아 사용하는 것.
    console.log(obj.hasOwnProperty("__proto__")); // false
    
    // __proto__ 접근자 프로퍼티는 모든 객체의 프로토타입 객체인 Object.protoype의 접근자 프로퍼티다.
    console.log(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__"));
    /*
    {
      get: f,
      set: f,
      enumerable: false,
      configurable: true
    }
    */
    
    // 모든 객체는 Object.prototype의 접근자 프로퍼티 __proto__를 상속받아 사용할 수 있다.
    console.log(obj.__proto__ === Object.prototype); // true
    ```
    
3. **__proto__ 접근자 프로퍼티 를 통해 프로토타입에 접근하는 이유**
    - 상호 참조 에 의해 프로토타입 체인(참조 루프)이 생성되는 것을 방지하기 위해서.
        - 프로토타입 체인은 **단방향 연결 리스트로 구현** 되어야 한다. = 프로퍼티 식별자 검색 방향 한쪽 방향 으로만 흘러야 함.
        - 아무런 체크 없이 프로토타입을 교체할 수 없도록 __proto_접근자 프로퍼티를 통해 프로토타입에 접근, 교체하도록 구현
    
    ```
    const parent = {};
    const child = {};
    
    child.__proto__ = parent;
    parent.__proto__ = child; // TypeError: Cyclic __proto__ value
    ```
    
4. **__proto__ 접근자 프로퍼티 를 코드 내에서 직접 사용하는 것은 권장하는 않는다.**
    - 모든 객체가 __proto__ 접근자 프로퍼티를 사용할 수 있는 것이 아니기 때문 → 직접 상속(Object.prototype 상속받지 않는 객체 생성)
    - 따라서, __proto__ 접근자 프로퍼티를 사용하는 대신
        - 프로토타입 취득에 경우 → Object.getPrototypeOf 메서드
        - 프로토타입 교체에 경우 → Object.setPrototypeOf 메서드 권장
    
    ```jsx
    const obj = {};
    const parent = { x: 1 };
    
    // Object.getPropertyOf 메서드로 obj 객체의 프로토타입 취득
    console.log(Object.getPrototypeOf(obj)); // [Object: null prototype] {}
    
    // Object.setPrototypeOf 메서드롤 obj 객체의 프로토타입을 교체
    Object.setPrototypeOf(obj, parent);
    
    // obj 객체의 __proto__ 접근자 프로퍼티로 obj 객체의 프로토타입 변경사항을 조회
    console.log(obj.__proto__); // { x: 1 }
    ```
    

## 2) 함수 객체의 __proto_ 접근자 프로퍼티

- 함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 (객체)인스턴스의 프로토타입을 가리킨다.
- 생성자 함수로서 호출할 수 없는 non-constructor 인 화살표 함수, ES6 메서드 축약 표현으로 정의한 메서드 는 prototype 프로퍼티를 소유하지 않고, 프로토타입도 생성하지 않는다.

```jsx
// 함수 객체는 protoype 프로퍼티를 가진다.
console.log(function () {}.hasOwnProperty("prototype")); // true

// 일반 객체는 prototype 프로퍼티를 가지지 않는다.
console.log({}.hasOwnProperty("prototype")); // false
```

- 모든 객체가 가지고 있는 __proto__ 접근자 프로퍼티 와 함수 객체만이 가지고 있는 prototype 프로퍼티 는 동일한 프로토타입을 가리킨다.

```jsx
function Person(name) {
  this.name = name;
}

const me = new Person("WI");

// Person 생성자 함수의 prototype 프로퍼티와 me 객체(인스턴스)의 __proto__ 접근자 프로퍼티가 가리키는 것은 동일한 프로토타입이다.
console.log(me.__proto__ === Person.prototype); // true
```

- 다만, 사용하는 주체가 다르다.

| 구분 | 소유 | 값 | 사용 주체 | 사용 목적 |
| --- | --- | --- | --- | --- |
| __proto__ 접근자 프로퍼티 | 모든 객체 | 프로토타입의 참조값 | 모든 객체 | 객체가 자신의 프로토타입에 접근 또는 교체하기위해 사용 |
| prototype 프로퍼티 | constructor | 프로토타입의 참조값 | 생성자 함수 | 생성자 함수가 자신이 생성할 객체(인스턴스)의 프로토타입을 할당하기 위해 사용 |

**3) 프로토타입의 constructor 프로퍼티와 생성자 함수**

- 모든 프로토타입은 constructor 프로퍼티 를 갖는다.
- 이는, 자신을 참조하고 있는 생성자 함수를 가리킨다.
- 이 연결은 생성자 함수가 생성될 때, 즉 함수 객체가 생성될 때 이뤄진다.

```jsx
function Person(name) {
  this.name = name;
}

const me = new Person("WI");

// me 객체의 생성자 함수는 Person
// me 객체의 constructor 프로퍼티(정확히는 me 객체의 프로토타입인 Person.prototype 에 constructor 프로퍼티)
console.log(me.constructor === Person); // true
```

# 19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

- 리터럴 표기법( { } ) 으로 생성된 객체의 프로토타입의 경우, constructor 프로퍼티 가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수가 아닐 수 있다.

```jsx
// 객체 리터럴로 obj 객체 생성
const obj = {};

// obj 객체의 생성자 함수는 Object 생성자 함수다.
console.log(obj.constructor === Object); // true
```

- ECMAScript의 OrdinaryObjectCreate 추상연산 호출에 의한 객체 생성
    - 추상연산 : ECMAScript 내부 동작의 구현 알고리즘을 의미. 함수와 유사한 의사 코드
    - OrdinaryObjectCreate 를 호출하면, 기본적으로 Object.prototype 을 프로토타입으로 갖는 빈 객체를 생성
    - Object 생성자 함수 호출과 객체 리터럴의 평가는 OrdinaryObjectCreate를 호출 해서 빈 객체를 생성하는다는 점은 동일
        - 다만, new.target 의 확인, 프로퍼티 추가하는 처리 등 세부 처리에서 차이가 있다.
        - 따라서, 객체 리터럴에 의해 생성된 객체 ≠ Object 생성자 함수가 생성한 객체
    - Function 생성자 함수 호출 →렉시컬 스코프 만들지 않고 전역 함수인 것처럼 스코프 생성, 클로저 생성x
        - 따라서 함수 선언문, 함수 표현식으로 함수 객체 생성 ≠ Function 생성자 함수
- 프로토타입과 생성자 함수 는 언제나 쌍(pair)으로 존재
    - 리터럴 표기법에 의해 생성된 객체도 상속을 위해선 프로토타입 필요. → 가상적인 생성자 함수 갖는다.
    - 프로토타입은 생성자 함수와 같이 생성.
    - 프로포타입의 constructor 프로퍼티를 통해 연결되어 있는 생성자 함수를 리터럴 표기법으로 생성한 객체를 생성한 생성자 함수로 생각해도 크게 무리 없음.
        
        
        | 리터럴 표기법 | 생성자 함수 | 프로토타입 |
        | --- | --- | --- |
        | 객체 리터럴 | Object | Object.prototype |
        | 함수 리터럴 | Function | Function.prototype |
        | 배열 리터럴 | Array | Array.prototype |
        | 정규 표현식 리터럴 | RegExp | RegExp.prototype |

# 19. 5 프로토타입의 생성 시점

- 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.
- 생성자 함수는 **사용자 정의 생성자 함수** 와 자바스크립트가 기본 제공하는 **빌트인 생성자 함수** 로 구분된다.

### 1) 사용자 정의 생성자 함수와 프로토타입 생성 시점

- 생성자 함수로 호출할 수 있는 constructor는 함수 정의가 평가 되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성

```jsx
// 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입 더불어 생성
// 함수 호이스팅 적용
console.log(Person.prototype); // { constructor: f }

// 생성자 함수
function Person(name) {
  this.name = name;
}
```

- 생성된 프로토타입은 Person 생성자 함수의 prototype 프로퍼티에 바인딩된다.
- 생성된 프로토타입은 **오직 constructor 프로퍼티 만을 갖는 객체**이다.
- 프로토타입도 객체이며, 모든 객체는 프로토타입을 가진다.
- 그러므로, 프로토타입도 자신의 프로토타입을 가진다.
    - 생성된 프로토타입의 프로토타입은 **Object.prototype**

### 2) 빌트인 생성자 함수와 프로토타입 생성 시점

- 빌트인 생성자 함수는 빌트인 생성자 함수가 생성되는 시점에 프로토타입이 생성
- 모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성
- 생성된 프로토타입은 빌트인 생성자 함수의 prototype 프로퍼티에 바인딩

⇒ 이처럼 객체가 생성되기 이전에 생성자 함수와 프로토타입은 이미 객체화되어 존재.

⇒ 이후 생성자 함수 또는 리터럴 표기법으로 객체 생성시 프로토타입은 생성된 객체의 [[Prototype]]내부 슬롯에 할당. 이로써 생성된 객체는 프로토타입을 상속받는다.