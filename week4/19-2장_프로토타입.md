# ✏️ 19장 프로토타입

## 📌 19.8 오버라이딩과 프로퍼티 섀도잉

프로토타입이 소유한 프로퍼티를 프로토타입 프로퍼티, 인스턴스가 소유한 프로퍼티를 인스턴스 프로퍼티라고 한다.

- 이 때 프로토타입 프로퍼티와 동명의 프로퍼티를 인스턴스에 추가하면 프로토타입 체인을 따라 올라가 기존에 있는 프로토타입 프로퍼티에 덮어 씌우는 것이 아니라, 인스턴스 프로퍼티로 추가한다.
- 288p의 예제처럼 인스턴스 메서드 sayHello가 프로토타입 프로퍼티 sayHello를 오버라이딩 해 프로토타입 메서드는 가려지게 된다.
- 이처럼 상속 관계에 의해 프로퍼티가 가려지는 것을 프로퍼티 섀도잉이라고 한다.
- 프로퍼티를 삭제하는 경우에도 프로토타입 메서드가 아닌 인스턴스 메서드가 삭제된다.
- 하위 객체를 통해 프로토타입 체인을 따라 올라가 상위의 프로토타입 메서드는 삭제할 수 없다.
- 따라서 프로토타입 프로퍼티를 변경/삭제 하려면 하위 객체를 통해 접근할 수 없고, 직접 프로토타입에 접근해 변경해야 한다. (delete와 같이 직접 접근)

**[참고]**
오버라이딩: 상위 클래스가 가진 메서드를 하위 클래스가 재정의해 사용하는 방식
오버로드: 함수 이름은 동일하지만 매개변수 타입 또는 개수가 다른 메서드를 구현하고, 매개변수에 의해 메서드를 구별해 호추하는 방식 (JS는 지원하지 않음 + arguments 객체로 구현은 가능)

## 📌 19.9 프로토타입의 교체

프로토타입은 임의의 다른 객체로 변경할 수 있다.

- 이는 상위 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다.
- 이를 통해 객체 간의 상속 관계를 동적으로 변경할 수 있다.
- 프로토타입은 생성자 함수 또는 인스턴스에 의해 교체될 수 있다.

##### 1. 생성자 함수에 의한 프로토타입 교체

```
const Person = (function () {
    // 생성자 함수 정의
    function Person(name) {
        this.name = name;
    }

    // 생성자 함수의 프로토타입 객체 재정의
    // Person.prototype 객체를 객체 리터럴로 덮어씀
    Person.prototype = {
        sayHello() {
            console.log(`Hi! My name is ${this.name}`);
        }
    };
    return Person;
}());

const me = new Person('Hwang');
```

- 프로토타입으로 교체한 객체 리터럴에는 constructor 프로퍼티가 없다. (프로토타입 체인을 타고 올라가 Object 생성자 함수를 가리킨다.)
- constructor 프로퍼티는 JS 엔진이 프로토타입을 생성할 때 암묵적으로 추가하는 프로퍼티다.
- me 객체의 생성자 함수를 검색하면 Object가 나온다. (덮어 씌웠기 때문에 Person 생성자 함수의 프로토타입이 사라지고 객체 리터럴이 프로토타입이 됨)

##### 2. 인스턴스에 의한 프로토타입의 교체

프로토타입은 생성자 함수의 prototype 프로퍼티 뿐만 아니라 인스턴스의 **proto** 접근자 프로퍼티를 통해 접근할 수 있다.

- 인스턴스의 **proto** 접근자 프로퍼티로 프로토타입을 교체할 수 있다.
- 이는 이미 생성된 객체의 프로토타입을 교체하는 것이다.
- 1과 2의 차이는 294쪽 참고
- 프로토타입 교체를 통해 객체 간의 상속 관계를 동적으로 변경하는 것은 복잡하고 번거로우므로 지양하는 것이 좋다.
- 인위적으로 설정하고 싶다면 직접 상속이나 클래스를 사용하는 것을 추천한다.

## 📌 19.10 instanceof 연산자

```
객체 instanceof 생성자 함수
```

이항 연산자로서 좌변에 객체를 가리키는 식별자, 우변에 생성자 함수를 가리키는 식별자를 피연산자로 받는다.

- 우변의 피연산자가 함수가 아니라면 타입 에러가 발생한다.
- 우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변 객체의 프로토타입 체인에 존재하면 true, 그렇지 않으면 false가 된다.
- instanceof 연산자는 생성자 함수의 prototype에 바인딩된 객체가 프로토타입 체인 상에 존재하는지 존재 여부를 확인한다.

## 📌 19.11 직접 상속 (**이해 안됨**)

##### 1. Object.create에 의한 직접 상속

해당 메서드는 명시적으로 프로토타입을 지정해 새로운 객체를 생성한다.

- 해당 메서드도 다른 객체 생성 방식과 동일하게 추상 연산 OrdinaryObjectCreate를 호출한다.
- 첫 번째 매개변수에 생성할 객체의 프로토타입으로 지정할 객체, 두 번째 매개변수에 생성할 객체의 프로퍼티 키와 프로퍼티 디스크립터 객체로 이뤄진 객체를 전달한다. (두 번째 생략 가능)
- 첫 번째 매개변수에 전달한 객체의 프로토타입 체인에 속하는 객체를 생성한다. (객체 생성과 동시에 상속 구현)
- new 연산자 없이 객체 생성 & 프로토타입을 지정하면서 객체 생성 & 객체 리터럴에 의해 생성된 객체도 상속 가능

##### 2. 객체 리터럴 내부에서 **proto**에 의한 직접 상속 (**이해 안됨**)

1은 여러 장점이 있지만 두 번째 인자를 정의하는 것이 번거롭다.
p.302처럼 접근자 프로퍼티로 상속을 할 수도 있다.

## 📌 19.12 정적 프로퍼티/메서드

생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메서드

- 정적 프로퍼티/메서드는 생성자 함수가 생성한 인스턴스로는 참조/호출할 수 없다.
- 생성자 함수로 생성된 인스턴스는 자신의 프로토타입 체인에 속한 객체의 프로퍼티/메서드에 접근할 수 있다.
- 하지만 정적 프로퍼티/메서드는 인스턴스의 프로토타입 체이네 속한 객체의 프로퍼티/메서드가 아니라서 접근할 수 없다.
- 인스턴스/프로토타입 메서드에서 this를 사용하지 않으면 그 메서드는 정적 메서드로 변경할 수 있다. (**이해 안됨**)

```
// 정적 프로퍼티
class Math {
    static PI = 3.141592653589793;
}

console.log(Math.PI); // 3.141592653589793

// 정적 메서드
const values = [1, 2, 3];
const array = Array.from(values);
console.log(array); // [1, 2, 3]
```

## 📌 19.13 프로퍼티 존재 확인

##### 1. in 연산자

```
key in object
```

객체 내에 특정 프로퍼티의 존재 여부 확인

- in 연산자는 확인 대상 객체의 프로퍼티 뿐만 아니라 확인 대상 객체가 상속 받은 모든 프로토타입의 프로퍼티를 확인하므로 주의해야 한다.
- ES6의 Reflect.has 메서드를 사용할 수도 있다. (동일한 기능)

##### 2. Object.prototype.hasOwnProperty 메서드

```
console.log(person.hasOwnProperty('name')); // true
```

인수로 전달 받은 프로퍼티 키가 객체 고유의 프로퍼티 키일 때만 true를 반환한다.
상속 받은 경우는 false로 반환한다.

## 📌 19.14 프로퍼티 열거

##### 1. for...in 문

```
for (변수 선언문 in 객체) {...}
```

객체의 모든 프로퍼티를 순회하며 열거할 때 사용한다.

- 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중 프로퍼티 어트리뷰트 [[Enumerable]] 값이 true인 프로퍼티를 순회하며 열거한다.
- 상속 받은 프로퍼티를 제외하고 객체 자신만의 프로퍼티를 열거하려면 Object.prototype.hasOwnProperty 메서드로 객체 자신의 프로퍼티인지 확인해야 한다.
- 순서를 보장하지 않는다. (지만 함)

##### 2. Object.keys/values/entries 메서드

객체 고유의 프로퍼티만 열거하기 위해서는 1보다 2를 권장한다.

1. Object.keys는 객체 자신의 열거 가능한 프로퍼티 키를 배열로 반환한다.
2. Object.values는 객체 자신의 열거 가능한 프로퍼티 값을 배열로 반환한다.
3. Object.entries는 객체 자신의 열거 가능한 프로퍼티 키와 값의 쌍의 배열을 배열에 담아 반환한다.
