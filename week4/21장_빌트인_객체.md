# ✏️ 21장 빌트인 객체

## 📌 21.1 JS 객체의 분류

1. 표준 빌트인 객체: ECMAScript 사양에 정의된 객체. JS의 실행 환경과 무관하게 언제나 사용할 수 있으며, 표준 빌트인 객체는 전역 객체의 프로퍼티로 제공된다. 따라서 별도 선언 없이 전역 변수처럼 언제나 참조할 수 있다.
2. 호스트 객체: ECMAScript 사양에 정의되어 있지는 않지만, JS 실행 환경에서 추가로 제공하는 객체를 말한다. 브라우저 환경에서는 DOM, Canvas, Ajax... 와 같은 클라이언트 사이드 Web API를 호스트 객체로 제공하고, Node.js 환경에서는 Node.js의 API(http 모듈, FS 모듈 등)를 호스트 객체로 제공한다.
3. 사용자 정의 객체: 사용자가 직접 정의한 객체

## 📌 21.2 표준 빌트인 객체

JS는 40여 개의 표준 빌트인 객체를 제공한다.

- Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체다.
- 예를 들어 표준 빌트인 객체인 String, Number, Boolean, Function, Array, Date는 생성자 함수로 호출해 인스턴스를 만들 수 있다.
- 생성자 함수 객체인 표준 빌트인 객체는 프로토타입 메서드과 정적 메서드를 제공한다. (ex. String의 substring & String.fromCharCode() 같은 정적 메서드)
- 생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메서드만 제공한다. (ex. Math.random 등)

## 📌 21.3 원시값과 래퍼 객체

원시값이 있는데도 문자열, 숫자, 불리언 객체를 생성하는 표준 빌트인 생성자 함수가 존재하는 이유

- 표준 빌트인 생성자 함수는 원시값을 감싸는 객체 래퍼 역할을 한다.
- 객체 래퍼란 문자열, 숫자, 불리언에 객체처럼 접근하면 생성되는 임시 객체를 말한다.
- 래퍼 객체는 원시값을 객체처럼 다룰 수 있게 하고, 특정 메서드와 속성을 사용할 수 있게 한다. (ex. string의 length처럼 원시값인 문자열이 프로퍼티와 메서드를 가진 객체처럼 행동)
- 타입을 강제 변환할 수도 있다.

```
const numStr = "42";
const num = Number(numStr);
console.log(num); // 42 (숫자)
```

- 래퍼 객체의 처리가 종료되면 래퍼 객체의 내부 슬롯에 할당된 원시값으로 원래 상태, 원시 값을 갖도록 되돌리고 래퍼 객체는 가비지 컬렉션의 대상이 된다.
- 문자열, 숫자, 불리언, 심벌 외의 원시값인 null, undefined는 래퍼 객체를 생성하지 않는다.

## 📌 21.4 전역 객체

코드가 실행되기 이전 JS 엔진에 의해 어떤 객체보다도 먼저 생성된 특수한 객체

- 어떤 객체에도 속하지 않는 최상위 객체
- JS 환경에 따라 지칭하는 이름이 제각각이다. (브라우저 환경에서는 window, Node.js 환경에서는 global)
- globalThis가 표준 사양으로 도입되었음
- 전역 객체는 개발자가 의도적으로 생성할 수 없다. (생성자 함수가 제공되지 않음)
- 전역 객체의 프로퍼티를 참조할때는 지칭하는 이름을 생략할 수 있다.
- var 키워드로 선언한 전역 변수와 암묵적 전역, 전역 함수는 전역 객체의 프로퍼티가 된다. (p. 327 참고)

#### 1. 빌트인 전역 프로퍼티

전역 객체의 프로퍼티

1. Infinity 프로퍼티: 무한대를 나타내는 숫자값을 갖는다.
2. NaN 프로퍼티: 숫자가 아님을 나타내는 숫자값을 갖는다.
3. undefined 프로퍼티: 원시 타입 undefined을 값으로 갖는다.

#### 2. 빌트인 전역 함수

애플리케이션 전역에서 호출할 수 있는 빌트인 함수 === 전역 객체의 메서드

1. eval: 문자열로 표현된 JS 코드를 실행하는데 사용된다. eval 함수를 호출하면 전달된 문자열이 JS 코드로 해석되고 실행된다.

- 표현식이라면 평가하여 값을 생성하고, 표현식이 아니라면 런타임에 실해한다.
- 객체 리터럴, 함수 리터럴은 반드시 괄호로 감싸준다.
- 문자열 코드가 여러 개의 문이라면 모든 문을 실행하고 마지막 값을 반환한다.
- 자신이 호출된 위치에 해당하는 기존의 스코프를 런타임에 동적으로 수정한다.
- 단 보안에 취약하며 JS 엔진에 의한 최적화가 이뤄지지 않기에 처리 속도가 느려 사용하지 말아야 한다.

2. isFinite: 전달 받은 인수가 유한수인지 검사해 true를 반환한다.

- 숫자 타입이 아니라면 타입 변환 후 검사를 수행한다.
- NaN으로 평가되는 값이라면 false를 반환한다.
- null은 true로 반환하는데, 숫자 타입으로 변환하면 0이 되기 때문이다.

3. isNaN: 전달 받은 인수가 NaN인지 확인해 불리언 타입으로 결과를 반환한다.

- 숫자 타입이 아니라면 타입 변환 후 검사를 수행한다.

4. parseFloat: 전달 받은 문자열 인수를 부동 소수점 숫자, 실수로 해석해 반환한다.
5. parseInt: 전달 받은 문자열 인수를 정수로 해석해 반환한다.

- 두 경우 모두 전달 받은 인수가 문자열이 아니라면 문자열로 반환 후 해석한다.
- 두 번째 인수로 진법을 나타내는 기수를 전달할 수 있다.
- 이렇게 하면 첫 번째 인수로 전달된 문자열을 해당 기수의 숫자로 해석해 반환한다. (10진수가 디폴트)
- 반대로 10진수 숫자를 해당 기수의 문자열로 반환하고 싶을 때는 toString()을 사용한다.
- 진수 및 인수에 대한 특이사항은 p.335 참고

6. encodeURI / decodeURI

- encodeURI: 완전한 URI를 문자열로 전달 받아 이스케이프 처리를 위해 인코딩한다.
  - 인코딩: URI의 문자들을 이스케이프 처리하는 것
  - 이스케이프 처리: 네트워크를 통해 정보를 공유할 때 어떤 시스템에서도 읽을 수 있는 아스키 문자 셋으로 변환하는 것
  - 해야 하는 이유: 문자 제약(일부 문자나 특수 문자는 포함할 수 있지만 다른 문자는 사용할 수 없음) & 안전한 전송(공백의 경우 %20처럼 왜곡됨) & 보안
- decodeURI: 인코딩된 URI를 인수로 전달 받아 이스케이프 처리 전으로 디코딩한다.

7. encodeURIComponet / decodeURIComponet (p.339 참고)

- encodeURIComponet: URI 구성 요소를 인수로 전달 받아 인코딩한다.
  - 인수로 전달된 문자열을 URI의 구성 요소인 쿼리 스트링의 일부로 간주해 = ? &까지 인코딩한다.
- decodeURIComponet: 매개변수로 전달된 URI 구성 요소를 디코딩한다.
  - 매개변수로 전달된 문자열을 완전한 URI 전체라고 간주해 쿼리 스트링 구분자를 인코딩하지 않는다.

#### 3. 암묵적 전역

변수를 선언하지 않고 값을 할당할 때 해당 변수는 전역 스코프에서 암묵적으로 선언된 것으로 간주한다.

- 이런 경우 전역 객체의 프로퍼티가 되어 전역 변수처럼 행동하지만, 변수가 아니다.
- 따라서 전역 변수와 달리 호이스팅이 발생하지 않는다.
