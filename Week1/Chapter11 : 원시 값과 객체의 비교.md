### 원시 타입과 객체 타입의 차이점

1. 원시타입 : 변경 불가능한 값 / 객체(참조)타입의 값 => 객체 : 변경 가능한 값
2. 원시값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장된다. / 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조값이 저장 된다.
3. 원시값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. => 값에 의한 전달 (pass by value)
4. 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달된다. => 참조에 의한 전달 (pass by reference)

#### 원시값

=> 원시타입의 값 / 변경 불가능한 값 => 읽기 전용

=> 변경 불가능하다는 말은 변수에 대한것이 아니라 값에 대한 의미 이다. => 값 자체를 변경할 수 없는 것이지 변수 값을 변경 할 수 없다는 말이 아니다.

=> 변수는 언제든지 재할당을 통해 변수 값을 변경(교체) 할 수 있다. / but 상수는 재할당이 금지된 변수 이다.

=> 상수와 변경 불가능한 값을 동일시 하면 안된다. 상수는 재할당(변수개념에서)이 금지된 변수이다.

=> const 키워드를 사용해 선언한 변수에 할당한 객체는 변경 할 수 있다.

=> 원시 값을 할당한 변수에 새로운 원시값을 재할당 하면 메모리 공간에 저장되어있는 재할당 이전의 원시값을 변경하는것이 아니라 새로운 메모리 공간을 확보하고 재할당한 원시 값을 저장한 후 변수는 새롭게 재할당한 원시 값을 가리킨다. 이 때 변수가 참조하던 메모리 공간의 주소가 바뀐다.

#### 변수가 참조하던 메모리 공간의 주소가 변경된 이유는 변수에 할당된 원시 값이 변경 불가능한 값이기 떼문이다.

=> 만약 원시값이 변경 가능한 값이라면 변수에 새로운 원시값을 할당 했을 때 변수가 가리키던 메모리 주소의 공간을 바꿀 필요없이 원시값 자체를 바꾸면 그만이다. => 메모리 주소는 안바뀐다.

#### => 불변성 (Immutability) : 불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.

#### 문자열과 불변성 

원시값을 저장하려면 먼저 확보해야하는 메모리 공간의 크기를 결정해야 한다.

=> ECMAScript 사양에 문자열 타입(2바이트)와 숫자 타입(8바이트) 이외의 원시 타입은 크기를 명확히 규정하고 있지는 않아서 브라우저 제조사의 구현에 따라 원시 타입의 크기는 다를 수 있다.

#### 원시값인 문자열의 독특한 특징

- 문자열은 0개 이상의 문자로 이루어진 집합을 의미하고 , 1개의 문자는 2바이트의 메모리 공간에 저장된다.
- 문자열은 몇개의 문자로 이루어졌냐에 따라서 필요한 메모리 공간의 크기가 결정된다.
- 숫자는 1도 , 1000000도 동일한 8바이트가 필요하지만 문자열의 경우 문자열에 포함된 문자의 개수가 필요한 공간의 크기를 결정한다.
- C에서는 하나의 문자를 위한 char타입만 있을 뿐 문자열타입은 존재하지 않고 문자열을 문자의 배열로 처리한다.
- Java에서는 문자열을 String 객체로 처리한다.
- 문자열은 유사 배열 객체이면서 이터러블(순회 가능한) 이므로 배열과 유사하게 각 문자에 접근할 수 있다.

#### 유사 배열 객체 : 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length프로퍼티를 갖는 객체를 말한다.

=> 원시 값은 문자열은 객체처럼 동작한다. => 원시 값을 객체처럼 사용하면 원시값을 감싸는 래퍼 객체로 자동 변환된다.

=> 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용하여 각 문자에 접근할 수 있다. 하지만 문자열은 원시값이므로 변경할 수 없다. 이 때 문제가 이것을 위배해도 결과값에 영향을 미치지 못하는데 에러가 발생하지 않는다.

#### 값에 의한 전달 : 변수와 변수간에 각각 다른 메모리 공간에 저장된 별개의 값이 된다. 변수의 값을 변경해도 다른 변수의 값에는 어떠한 영향도 주지 않는다.

#### 값에 의한 전달도 사실은 값을 전달하는 것이아니라 메모리 주소를 전달한다. 단, 전달된 메모리 주소를 통해 메모리공간에 접근하면 값을 참조할 수 있다.

=> 단지 서로 다른 메모리주소값(reference)을 가지므로 (value)값의 변경에는 간섭할 수 없다는 의미

### 객체

=> 객체는 프로퍼티 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 있다.
=> 프로퍼티의 값에도 제약이 없다.
=> 객체는 원시값과 같이 확보해야할 메모리 공간의 크기를 사전에 정해 둘 수 없다.

#### 자바스크립트의 객체 관리 방식

- 자바스크립트 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블 이라고 생각할 수 있다. 대부분의 자바스크립트 엔진은 해시테이블과 유사하지만 높은 성능을 위해 일반 해시테이블보다 나은 방법으로 객체를 구현한다.
- 자바, C++ 같은 클래스 기반 객체지향 프로그래밍 언어에서는 사전에 정의된 클래스를 기반으로 객체를 생성한다. => 객체를 생성하기 전에 이미 프로퍼티와 메서드가 정해져있다. => 객체를 생성한 후에 프로퍼티를 삭제하거나 추가할 수 없다.
- 자바스크립트는 클래스 없이 객체를 생성할 수 있으며, 객체가 생성된 이후라도 동적으로 프로퍼티와 메서드를 추가할 수 있다.
- 이 방법은 사용하기 매우 편리하지만 사실 성능면에서는 이론적으로 클래스기반 객체지향 프로그래밍언어의 객체보다 생성과 프로퍼티 접근에 비용이 더 많이 드는 비효율적인 방식이다.
- 그래서 V8 엔진에서는 프로퍼티에 접근하기 위해 동적탐색(dynamic lookup) 대신 히든 클래스(hidden class) 방식을 사용해 C++객체의 프로퍼티에 접근하는 정도의 성능을 보장한다.

  #### 객체는 변경 가능한 값이다.

  객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 값(value) 대신 참조값(reference value)에 접근할 수 있다. 참조 값은 생성된 객체가 저장된 메모리공간의 주소 그 자체이다.

  => 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있다.

  => 재할당 없이 프로퍼티를 동적으로 추가할 수 있고, 프로퍼티 값을 갱신할 수도 있으며, 프로퍼티 자체를 삭제할 수도 있다.

  #### 객체는 메모리 사용의 효율성과 성능을 위해 어느정도의 구조적인 단점을 감안해 설계되었는데 그 단점이 원시값과는 다르게 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다.

  #### 얕은 복사 & 깊은 복사

  1. 얕은 복사 : 객체를 프로퍼티 값으로 갖는 객체일 경우 한 단계 까지만 복사하는 것
 
  2. 깊은 복사 : 객체에 중첩 되어 있는 객체 까지 모두 복사하는 것
 
  => 얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체다. (참조값이 다르다.)

  => 그러나 얕은 복사는 객체에 중첩되어있는 객체의 경우 참조값을 복사하고 깊은복사는 중첩되어있는 객체까지 모두 복사해서 원시값처럼 완전한 복사본을 만든다는 차이가 있다.

  #### 참조에 의한 전달 : 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달 된다.

  이렇게 될 경우 여러개의 식별자가 하나의 객체를 공유하게 되는 문제가 발생하게 된다. 어느 한쪽에서 객체를 수정,삭제 하는것이 모두에게 영향을 미친다.

  #### '값에의한 전달'과 '참조에 의한 전달'은 식별자가 기억하는 메모리공간에 저장되어 있는 값을 복사해서 전달한다는 공통점을 가지고 있지만 변수에 저장되어 있는 값이 원시값이냐 참조값이냐의 차이이다.

  #### 따라서 자바스크립트에는 "참조에 의한 전달"은 존재하지 않고 "값에 의한 전달"만이 존재한다고 할 수 있다.

  #### 자바스크립트에서는 포인터(pointer)가 존재하지 않아서 포인터가 존재하는 다른 언어의 참조에 의한 전달과 의미가 정확히 일치하지 않는다.

  

  
-  





