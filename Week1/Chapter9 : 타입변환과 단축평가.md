### 타입 변환

=> 자바스크립트의 모든 값은 타입이 있는데 이 타입을 변경하는 것이다.

#### 타입 변환의 종류

- 명시적 타입 변환(Explicit Coercion) 또는 (타입 캐스팅(Type Casting)) : 개발자가 의도적으로 값의 타입을 변환하는 것 (코드에 변경의지가 드러남)

=> 원본의 값과 타입을 변경시키는 것이 아니라 기존의 원시값을 사용해 새로운 타입을 가진 새로운 원시값을 생성한다.
=> 새로운 메모리 주소를 참조한다는 것.

- 암묵적 타입 변환(Implicit Coercion) 또는 (타입 강제 변환(Type Coercion)) : 개발자의 의도와는 상관없이 표현식을 평가하는 도중에 암묵적으로 타입이 자동 변환되는 것

=> 암묵적 타입 변환 역시 기존 변수값을 활용은 하지만 기존 변수값을 재할당하여 변경 하지는 않고 새로운 타입을 가진 새로운 원시값을 생성한다.
=> 새로운 메모리 주소를 참조한다는 것.

#### 자바스크립트는 자바스크립트 엔진에서 표현식을 평가하는 도중에 암묵적으로 타입을 자동 변환 시킨다.

#### 자신이 작성한 코드에서 암묵적 타입변환이 발생하는지, 
#### 발생한다면 어떤 타입으로 변환되는지,
#### 타입 변환된 값으로 표현식이 어떻게 평가될 것인지 예측 가능해야 한다. => 이것들을 실패하면 오류를 생산할 가능성이 높아진다.

#### 자바스크립트 엔진은 평가 과정에서 웬만하면 에러를 발생시키고 싶어하지 않아서 암묵적 타입변환을 통해 표현식을 평가하는데 이것이 결국은 개발자의 의도와 일치하지 않게 타입이 변환되면 예상치 못한 오류가 생기게 되는 원인이 될 수 있다.

### 암묵적 타입 변환 하는 방법

#### 문자열 타입으로의 변환 : + 연산자가 문자열 연결 연산자로 동작할 경우 (+ 연산자 사이의 피연산자중에 하나가 문자열일 경우)

=> 연산자 표현식의 피연산자만이 암묵적 타입변환의 대상이 되는것이 아니고 평가 결과 역시 대상이 될 수 있다. ex) 템플릿 리터럴의 문자열화

#### p111 참고 => 문자열 타입의 암묵적 변환 예시

#### 숫자 타입으로의 변환 : + 이항 연산자를 제외한 산술 연산자를 사용하면 숫자 값으로 계산 / 비교 연산자도 값을 비교해야 하기 때문에 숫자 값으로 변환시킴
#### + 단항 연산자 역시 숫자타입으로 변환 시킨다.

#### p112~p113 참고 => 숫자 타입의 암묵적 변환 예시

#### 불리언 타입으로 변환 : if문의 조건식에서는 모두 boolean타입으로 변환됨.

=> Falsy 값 : false, undefined, null, -0, +0, NaN, ''(빈문자열)
=> Truthy 값 : Falsy값을 제외한 값들

### 명시적 타입 변환 하는 방법

- 표준 빌트인 생성자 함수(String, Number, Boolean)을 new 연산자 없이 호출하는 방법
- 빌트인 메서드를 사용하는 방법
- 암묵적 타입 변환을 이용하는 방법

#### 문자열 타입으로 변환

- String 생성자 함수를 new 연산자 없이 호출하기 ex) String(1); => '1'
- Object.prototype.toString 메서드를 사용하는 방법
- 문자열 연결 연산자를 이용하는 방법

#### 숫자 타입으로 변환

- Number 생성자 함수를 new연산자 없이 호출하기 ex) Number(true); => 1
- parseInt(정수로), parseFloat(실수로) 함수를 사용하는 방법 (문자열만 숫자 타입으로 변환 가능)
- (+) 단항 산술 연산자를 이용하는 방법
- (*) 산술 연산자를 이용하는 방법

#### 불리언 타입으로 변환

- Boolean 생성자 함수를 new연산자 없이 호출하기 ex) Boolean('x'); => true
- (!) 부정 논리 연산자를 두 번 사용하는 방법 ex) !!0; => false 

### 단축 평가

=> 논리합(&&) 논리곱(||) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다.

=> &&은 논리 연산의 결과를 결정하는 두번째 피연산자를 그대로 결과값으로 반환한다.
  - 논리곱은 모든 값이 true여야 true를 반환할 수 있기 때문에 2번째 피연산자를 확인해야 비로소 true라고 할수 있다. 그래서 연산의 결과를 결정하는 것은 두번째 피연산자의 값이다.

=> ||은 논리 연산의 결과를 결정한 첫번째 피연산자를 그대로 결과값으로 반환한다.
  - 논리합은 값중에 하나만 true여도 true를 반환 할 수 있다. 그래서 첫번째 값만 확인해도 true 이다. 그래서 연산의 결과를 결정하는 것은 첫번째 피연산자의 값이다.

#### 중요한 핵심은 연산의 결과를 결정할 수 있는 피연산자의 값을 반환한다는 것이다.

#### 단축평가를 사용하면 if문을 대체 할 수 있다.

- 어떤 조건이 Truthy값일 때 무언가를 해야한다면 논리곱 연산자 표현식으로 대체 가능
- 어떤 조건이 Falsy값일 때 무언가를 해야한다면 논리합 연산자 표현식으로 대체 가능

#### 단축 평가의 유용한 활용 패턴

- 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때
- 함수 매개변수에 기본 값을 설정 할 때

### 옵셔널 체이닝 연산자

=> ES11(ECMAScript2020)에서 도입됨.
=> (?.) 좌항의 피연산자가 null 또는 undefined인 경우, undefined를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.
=> 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때 유용하다.

### null 병합 연산자

=> ES11(ECMAScript2020)에서 도입됨.
=> (??) 좌항의 피연산자가 null 또는 undefined일 경우, 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.
=> 변수에 기본값을 설정할 때 유용하다.
=> 논리합을 이용한 단축평가에서 Falsy한 값이면 우항의 피연산자를 반환하는데 이때 Falsy한 값중에 0이나 ''도 기본값으로서 유효한 상황이면 예상치 못한 동작이 발생할 수 있는데 이것을 방지해준다.



