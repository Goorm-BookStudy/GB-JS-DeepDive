### 스코프 : 식별자가 유효한 범위 / 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙

#### 자바스크립트의 스코프는 다른 언어의 스코프와 구별되는 특징이 있어서 주의가 필요하다.

#### var키워드로 선언한 변수의 스코프와 let 또는 const 키워드로 선언한 변수의 스코프도 다르게 동작한다.

### 모든 식별자(변수이름, 함수 이름, 클래스 이름 등)은 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효범위가 결정된다.

#### 식별자 결정 : 자바스크립트 엔진은 이름이 같은 두 개의 변수 중에서 어떤 변수를 참조해야할지를 결정해야 한다.

#### 렉시컬 환경 : 코드가 어디서 실행되며 주변에 어떤 코드가 있는지를 나타내는 말

#### 실행 컨텍스트 : 렉시컬 환경을 구현한 것 / 모든 코드는 실행 컨텍스트에서 평가되고 실행 된다. => 스코프는 실행컨텍스트와 깊은 관련이 있다.

#### 프로그래밍 언어에서는 스코프(유효범위)를 통해 식별자인 변수 이름의 충동을 방지하여 같은 이름의 변수를 사용할 수 있게 한다.
#### 스코프 내에서 식별자는 유일해야 하지만 다른 스코프에는 같은 이름의 식별자를 사용할 수 있다.

- var 키워드 : 같은 스코프에서 중복 선언이 허용된다. 이는 의도치 않게 변수 값이 재할당되어 변경되는 부작용을 발생시킨다.
- let, const 키워드 : 같은 스코프 내에서 중복 선언을 허용하지 않는다.

#### 스코프의 종류 : 변수는 자신이 선언된 위치에 의해 자신이 유효한 범위인 스코프가 결정된다.

- 전역 : 코드의 가장 바깥 영역 => 전역 스코프 => 전역 변수는 어디서든지 참조할 수 있다.
- 지역 : 함수 몸체 내부 => 지역 스코프 => 지역 변수는 자신이 선언된 지역과 하위 지역(중첩함수) 에서만 참조할 수 있다.

#### 스코프 체인 : 스코프는 함수의 중첩에 의해 계층적 구조를 갖는다. / 외부 함수의 지역 스코프 = 중첩 함수의 상위 스코프 => 스코프가 계층적으로 연결된 것

#### 변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색 한다.

#### 스코프 체인은 물리적인 실체로 존재한다. 

=> 자바스크립트 엔진은 코드를 실행하기에 앞서 렉시컬 환경을 실제로 생성한다. 변수 선언이 실행되면 변수 식별자가 렉시컬 환경의 키(key)로 등록되고, 변수 할당이 일어나면 이 자료구조의 변수 식별자에 해당하는 값을 변경한다. 변수의 검색도 이 자료구조 상에서 일어난다.

#### 자바스크립트 엔진은 스코프 체인을 따라 변수를 참조하는 코드의 스코프에서 시작해서 상위 스코프로 방향을 이동하며 선언된 변수를 찾을 때까지 검색한다.
#### 절대 하위스코프로 내려가서 식별자를 검색하는 일은 없다. 

#### => 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다.

#### 함수 레벨 스코프 : 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다.

#### var 키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정한다.

#### 렉시컬 스코프 : 상위스코프가 동적으로 변하지 않고 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정된다.

#### 자바스크립트를 비롯한 대부분의 프로그래밍언어는 렉시컬 스코프를 따른다.

#### 자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 호출했는지가 아니라 함수를 어디서 정의했는지에 따라 상위스코프를 결정한다.

#### 함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다. => 함수의 상위스코프는 언제나 자신이 정의된 스코프이다.

#### 렉시컬 스코프는 클로저와 깊은 관계가 있다.

- 동적 스코프 : 함수를 정의하는 시점에는 함수가 어디서 호출될지 알 수 없어서 함수가 호출되는 시점에 동적으로 상위 스코프를 결정해야한다.

