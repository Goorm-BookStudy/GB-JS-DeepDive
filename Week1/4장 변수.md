# 모던 자바스크립트

# 04장 - 변수

## 4.1 변수란 무엇인가? 왜 필요한가?

- 변수(variable):
  - 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
  - 프로그래밍 언어에서 값을 저장하고 참조하는 메커니즘
  - 값의 위치를 가르키는 상징적인 이름
  - 메모리 공간에 저장된 값을 다시 읽어 들여 재사용 할 수 있도록 값이 저장된 메모리 공간에 상징적인 이름을 붙인 것
  - 프로그래밍 언어의 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행
  - 따라서 개발자는 변수를 통해 안전하게 값에 접근가능!(직접 메모리 주소를 통해 값을 저장하고 참조할 필요 없음)

```jsx
// 변수는 하나의 값을 저장하기 위한 수단
var userId = 1;
var userName = "Lee";

// 객체나 배열 같은 자료구조를 사용하면 여러 개의 값을 하나로 그룹화 해서 하나의 값처럼 사용
var user = { id: 1, name: "Lee" };

var users = [
  { id: 1, name: "Lee" },
  { id: 2, name: "Kim" },
];
```

userId → 변수 이름 , 1 → 변수 값

할당(대입, 저장) : 변수에 값을 저장하는 것

참조 : 변수에 저장된 값을 읽어 들이는 것

변수는 프로그래밍 언어에서 데이터를 관리하기 위한 핵심개념

계산과 기억

- 사람
  - 두뇌
- 컴퓨터
  - CPU : 연산
  - 메모리 : 데이터를 기억

메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체

- 셀 하나의 크기 1byte(8bit)
- 메모리 셀의 크기 즉 1바이트 단위로 데이터를 저장하거나 읽어 들인다.

각 셀은 고유의 메모리 주소(메모리 공간의 위치, 0부터 시작해서 메모리의 크기만큼 정수로 표현)를 갖는다.

모든 데이터를 2진수로 처리(데이터의 종류에 상관 없이)

메모리 주소를 통해 값에 직접 접근하는 것은 치명적 오류를 발생시킬 수 있다.

운영체제가 사용하고 있는 값을 변경하면 시스템을 멈추게 하는 오류를 발생할 수도 있어 JS는 개발자의 직접적인 메모리 제어를 허용하지 않는다.

## 4.2 식별자(변수 이름)

- 어떤 값을 구별해서 식별할 수 있는 고유한 이름
- 메모리 주소에 붙인 이름
- 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름

식별자는 값이 아니라 메모리 주소를 기억하고 있다.

## 4.3 변수 선언(변수를 생성하는 것)

변수를 사용하려면 반드시 선언이 필요!(var, let, const 키워드를 사용하여!)

```jsx
var score; // 변수 선언(변수 선언문)
// 변수이름을 등록 + 값을 저장할 메모리 공간을 확보
// (JS 엔진에 의해) undefined라는 값이 암묵적으로 할당되어 초기화-> JS만의 독특한 특징
```

JS 엔진의 변수선언

1. 선언단계
   변수 이름을 등록해서 JS 엔진에 변수의 존재를 알린다.
2. 초기화 단계
   값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화

—> 동시에 진행

—> 선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러)가 발생

<img width="458" alt="Untitled 1" src="https://github.com/charmingGyu/banana/assets/133394457/545adf57-bc60-4be1-bbf4-442661aeb6bb">

<img width="428" alt="Untitled" src="https://github.com/charmingGyu/banana/assets/133394457/0f1734a2-688a-4015-b125-a54584cdb87b">

: 식별자를 통해 값을 참조하려 했지만 JS 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러

변수이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록!

변수 이름과 값은 실행 컨텍스트 내에 Key / value 형식인 객체로 등록되어 관리

\*\* 실행 컨텍스트 : JS엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역. JS엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리.

## 4.4 변수 선언의 실행 시점과 변수 호이스팅

```jsx
// 호이스팅

console.log(score);

var score;
```

- 변수 호이스팅 : 변수선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 JS고유의 특징

* 변수 선언뿐 아니라 var, let, const, function, function\*, class 키워드를 사용해서 선언하는 모든 식별자(변수, 함수, 클래스 등)는 호이스팅 된다.

→ 참조에러 발생 X

→ 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 이전 단계에서 먼저 실행

> JS엔진은 소스코드를 한줄 씩 순차적으로 실행하기에 앞서 먼저 소스코드의 평가과정을 거치면서 소스코드를 실행하기 위한 준비 → 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내 먼저 실행 → 평가과정이 끝나면 변수선언을 포함한 모든 선언문을 제외하고 소스코드를 한줄 씩 순차적으로 실행

: 변수선언의 위치에 상관없이 먼저실행 따라서 어디서든지 변수를 참조할 수 있음

## 4.5 값의 할당(”=”)

```jsx
var score; // 변수 선언
score = 80; // 값의 할당
_________________;
var score = 80; // 동시에!
```

```jsx
console.log(score); // undefined // 변수선언과 동시에 초기화

var score; // 변수선언
score = 80; // 값의 할당
___________or____________;
var score = 80; // 동시에!

console.log(score); // 80;
```

변수선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행

값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행!

→ undefined 가 저장되어있던 메모리 공간을 지우고 그 메모리 공간에 80을 새롭게 저장하는 것 X

→ 새로운 메모리 공간을 확보하고 그곳에 할당 값 80을 저장하는 것.

```jsx
console.log(score); // undefined
score = 80;
var score;
console.log(score); // 80; // 이 시점에 값이 할당?
```

## 4.6 값의 재할당

```jsx
var score = 80;
score = 90; // 현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 것
```

처음에 값을 할당 하는 것도 어찌보면 재할당(undefined → x)

값을 재할당 할 수 없으면 변수가 아니라 상수라고 한다.(const, constant)

const 키워드는 재할당 금지!

<img width="709" alt="Untitled 2" src="https://github.com/charmingGyu/banana/assets/133394457/af00c9ab-0484-423b-8752-dee57de96051">

→ 자바스크립트에서의 변수에 데이터를 재할당 하는 작업은, 해당 메모리 공간을 지우고, 그 메모리 공간에 재할당 값을 저장하는 것이 아닌, 새로운 메모리 공간을 확보 후 그 메모리에 재할당하는 데이터를 기록후 식별자, 즉 변수의 이름을 새로 할당 해 준다.

\*\*가비지 콜렉터(garbage collector)

- 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더이상 사용되지 않는 메모리(어떤 식별자도 참조하지 않는 메모리 공간)를 해제하는 기능
- JS → 가비지 콜렉터를 내장(매니지드 언어), 메모리 누수 방지

\*\* 언매니지드 언어 vs 매니지드 언어 —> 메모리 관리 방식에 따른 분류

- 언매니지드 언어 : 메모리 제어를 개발자가 주도 할 수 있음. 따라서 개발자의 역량에 따라 최적의 성능을 확보할 수 있지만 치명적 오류 발생 가능성도 있음 ( 예 : C언어)
- 매니지드 언어 : 개발자가 관여 X , 개발자의 역량에 의존하는 부분이 상대적으로 작아져 어느정도 일정한 생산성을 보장할 수 있다. 하지만 성능면에서 어느정도의 손실은 감수해야함

## 4.7 식별자 네이밍 규칙

- 특수문제를 제외한 문자, 숫자, 언더스코어(\_), 달러 기호($)를 포함O
- 숫자로 시작하는 것은 허용 X
- 예약어는 식별자 사용 X

| await       | break    | case         | catch   | class     | const      |
| ----------- | -------- | ------------ | ------- | --------- | ---------- |
| continue    | debugger | default      | delete  | do        | else       |
| enum        | export   | extends      | false   | finally   | for        |
| function    | if       | implements\* | import  | in        | instanceof |
| interface\* | let\*    | new          | null    | package\* | private\*  |
| protected\* | public\* | return       | super   | static\*  | switch     |
| this        | throw    | true         | try     | typeof    | var        |
| void        | while    | with         | yield\* |           |            |

- - : 식별자로 사용 가능하나 strict mode에서는 사용 불가(implements, interface, let, package, private, protected, public, static, yield)

변수는 쉼표(,)로 구분해 하나의 문에서 여러개를 한번에 선언할 수 있다.(But 가독성이 떨어짐)

```jsx
var person, $elem, _name, first_name, val1;
```

대소분자 구별

```jsx
var firstname;
var firstName;
var FIRSTNAME;
// 각각 별개의 변수
```
