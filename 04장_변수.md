# 04장 변수

- 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름을 **변수 이름**(또는 **변수명**)이라 한다.
- 그리고 변수 저장된 값을 **변수 값**이라고 한다.
- 변수 값을 저장하는 것을 **할당**(대입, 저장)이라 하고, 변수에 저장된 값을 읽어 들이는 것을 **참조** 한다.
  ⇒ 사람이 이해할 수 있는 언어로 명명한 변수 이름을 통해 변수에 저장된 값의 의미를 명확히 할 수 있다. 따라서 좋은 이름, 즉 변수에 저장된 값의 의미를 파악할 수 있는 변수 이름은 가독성을 높이는 부수적인 효과도 있다.
  ⇒ 코드는 컴퓨터에게 내리는 명령이지만 개발자를 위한 문서이기도 하다. 개발자의 의도를 나타내는 명확한 네이밍은 코드를 이해하기 쉽게 만들며, 이는 협업과 품질 향상에 도움을 준다. 그러므로 변수 이름은 심사숙고하여 지어야 한다.

### 4.2 식별자

- 변수 이름을 **식별자**라고도 한다. 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다. 사람을 이름으로 구별해서 식별하는 것처럼 값도 식별자로 구별해서 식별할 수 있다.
- **식별자는 값이 아니라 메모리 주소를 기억하고 있다.**
- 변수, 함수, 클래스 들의 이름과 같은 식별자는 네이밍 규칙을 준수해야 하며, 선언에 의해 자바스크립트 엔진에 식별자의 존재를 알린다.

### 4.3 변수 선언

- 변수 선언이란 변수를 생성하는 것을 말한다.
  1. 변수를 사용하려면 반드시 선언이 필요하다.
  2. 변수를 선언할 때는 let, const, ~~var~~ 키워드를 사용한다.
  ```jsx
  let score; // 변수 선언 후 아직 값을 할당하지 않아 undefined라는 값이 암묵적으로 할당

  1. 선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
  2. 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화
  ```
    <aside>
    💡 만약 선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러)가 발생한다
    
    </aside>


### 4.4 변수 선언의 실행 시점과 변수 호이스팅

```jsx
console.log(score); // undefined

let score; // 변수 선언문
```

- 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문에 ReferenceError가 발생하지 않고 undefined이 출력된다.
- 자바스크립트 엔진은 변수 선언문을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 소스코드에서 찾아내 먼저 실행한다.
  ⇒ 그리고 소스코드의 평가 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 소스 코드를 한 줄씩 순차적으로 실행한다.
- 이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 **변수 호이스팅**이라 한다.

### 4.5 값의 할당

- 변수는 값을 할당할 때 할당 연산자(=)를 사용한다.

```jsx
let score; // 변수 선언
score = 10; // 값의 할당
```

```jsx
변수의 선언과 값을 할당을 하나의 문으로 단축 표현할 수 있다.

let score = 10;

=> 자바스크립트 엔진은 변수 선언과 값의 할당을 하나의 문으로 단축 표현해도 변수 선언과 값의 할당
	 2개의 문으로 나누어 각각 실행한다.
```

- 변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.

```jsx
console.log(score); // undefined

let score; // 변수 선언 => 런타임 이전에 실행
score = 10; // 값의 할당 => 런타임에 실행

console.log(score); // 10
```

```jsx
console.log(score); // undefined

let score = 10; // 변수 선언 => 런타임 이전에 실행 , 값의 할당 => 런타임에 실행
// => 따로따로 실행됨

console.log(score); // 10
```

### 4.6 값의 재할당

```jsx
let score = 80; // 변수 선언과 값의 할당
score = 60; // 값의 재할당
```

현재 score 변수의 값을 60이다. 이전 score의 변수 값이 undefined와 80은 어떤 변수도 값으로 갖고 있지 않다. 다시 말해, 어떤 식별자와도 연결되어 있지 않다.

⇒ 이러한 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제된다. 단, 메모리에서 언제 해제될지는 예측할 수 없다.

### 4.7 식별자 네이밍 규칙

- 식별자는 어떤 값을 구별해서 식별해낼 수 있는 고유한 이름을 말한다. 식별자는 다음과 같은 네이밍 규칙을 준수해야 한다.
  - 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(\_), 달러기호($)를 포함할 수 있다.
  - 단, 식별자는 특수문자를 제외한 문자, 언더스코러(\_), 달러기로($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.
  - 예약어는 식별자로 사용할 수 없다.
    | 자바스크립트의 예약어 |            |              |
    | --------------------- | ---------- | ------------ |
    | abstract              | float      | public       |
    | boolean               | for        | return       |
    | break                 | function   | short        |
    | case                  | if         | static       |
    | catch                 | implements | super        |
    | char                  | import     | switch       |
    | class                 | in         | synchronized |
    | const                 | instanceof | this         |
    | continue              | int        | throw        |
    | default               | interface  | throws       |
    | goto                  | byte       |              |
  - 네이밍 컨벤션
    1. 기본 변수명 : 자체 설명적이어야 함
    ```jsx
    // bad
    const value = 'Robin';
    const val = 'Robin';

    // good
    const firstName = 'Robin';
    ```
    **camelCase, PascalCase를 사용**
    1. Arrays : 변수 이름에 복수, 단수 표현하기
    ```jsx
    // bad
    const fruit = ['apple', 'banana', 'cucumber'];
    // okay
    const fruitArr = ['apple', 'banana', 'cucumber'];
    // good
    const fruits = ['apple', 'banana', 'cucumber'];

    // great
    const fruitNames = ['apple', 'banana', 'cucumber'];
    const fruits = [
      { name: 'apple', genus: 'malus' },
      { name: 'banana', genus: 'musa' },
      { name: 'cucumber', genus: 'cucumis' },
    ];
    ```
    1. Booleans : is, has, can로 시작하여 변수의 타입을 암시하기
    ```jsx
    // bad
    const open = true;
    const write = true;
    const fruit = true;
    const equal = true;
    const visible = true;

    // good
    const isOpen = true;
    const canWrite = true;
    const hasFruit = true;
    const areEqual = true;
    const isVisible = true;
    ```
    만약 함수의 return값이 boolean이라면?
    : 함수명을 check나 get으로 시작하기
    ```jsx
    const user = { fruits: ['apple'] };
    const checkHasFruit = (user, fruitName) => user.fruits.includes(fruitName);
    const hasFruit = checkHasFruit(user, 'apple');

    checkTodoData();
    ```
    1. Numbers : 변수명에 maximum, minimum, total 포함하기
    ```jsx
    // bad
    const pugs = 3;

    // good
    const minPugs = 1;
    const maxPugs = 5;
    const totalPugs = 3;
    ```
    1. Functions : 동사를 사용하여 명명하기
    ```jsx
    // bad
    userData(userId);
    userDataFunc(userId);
    totalOfItems(items);
    elementValidator(elements);

    // good
    getUser(userId);
    calculateTotal(items);
    validateElement(elements);
    ```
    반복문 안에서의 변수는 단수형으로 사용하기
    ```jsx
    // bad
    const newFruits = fruits.map((x) => {
      return doSomething(x);
    });

    // good
    const newFruits = fruits.map((fruit) => {
      return doSomething(fruit);
    });
    ```
    1. Components & Class : 컴포넌트는 클래스와 같이 대문자로
    ```jsx
    // bad
    function userProfile(user) {
      return (
        <div>
          <span>First Name: {user.firstName}</span>
          <span>Last Name: {user.lastName}</span>
        </div>
      );
    }

    // good
    function UserProfile(user) {
      return (
        <div>
          <span>First Name: {user.firstName}</span>
          <span>Last Name: {user.lastName}</span>
        </div>
      );
    }
    ```
    1. Constatnt : 대문자에 \_를 사용
    ```jsx
    var SECONDS = 60;
    var MINUTES = 60;
    var HOURS = 24;
    var DAY = SECONDS * MINUTES * HOURS;
    var DAYS_UNTIL_TOMORROW = 1;
    ```
  - 그외 클린 코드 규칙들
    1. **Object Lookup Table**

       : 다수의 switch-case문은 JSON table화 하기

       ```jsx
       BAD;

       function getUserType(type) {
         switch (key) {
           case 'ADMIN':
             return '관리자';
           case 'INSTRUCTOR':
             return '강사';
           case 'STUDENT':
             return '학생';
           default:
             return '해당 없음';
         }
       }

       GOOD;

       function getUserType(type) {
         const USER_TYPE = {
           ADMIN: '관리자',
           INSTRUCTOR: '강사',
           STUDENT: '수강생',
         };

         return USER_TYPE[type] || '해당 없음';
       }
       ```

    1. **긍정 우선 코드**

       ```jsx
       BAD

       if(!(typeof data === 'string')){ ... }
       ```

    1. **조건문엔 함수 : 어떤 연산을 위한 조건문인지 알아보기 쉬움**

       ```jsx
       BAD

       if(n % 1 === 0) { ... }
       GOOD

       if(isInt(n)) { ... }
       ```

    1. **중첩 그냥 두지말기**

       ```jsx
       BAD

       for (let i = range - 1; i < d.length; i++) {
         let sum = 0;
         for (let j = i - range + 1; j <= i; j++) {
           sum += d[j];
         }
         result.push(sum);
       }

       GOOD

       for(let i=0; i<range; i++) {
       	sum += d[i];
       }

       for(let k 1-i; j < d.length; j++) {
       	if(j === (range-1)) {
       		console.log(sum);
       		continue;
       	}
       	let start = j - range;
       	sum += d[j] - d[start];
       	console.log(sum);
       }
       ```

    1. **복잡한 것 숨기기 : 재사용되는 건 덤**

       ```jsx
       BAD;

       const validEmail =
         /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9+\.)+[a-zA-z]{2,}))$/.test(
           str
         );

       GOOD;

       const validEmail = isValidEmail(eMail);
       ```

    1. **short circuiting 대신 default parameters 사용**

       : 주의할 것은 undefined만 default parameters가 적용됩니다. 즉, falsy 값인 ‘’, ””, false, null, 0, NaN은 defalut value로 대체되지 않습니다.

       ```jsx
       BAD;

       function createMicrobrewery(name) {
         const breweryName = name || 'Hipster Brew Co.';
         // ...
       }
       GOOD;

       function createMicrobrewery(name = 'Hipster Brew Co.') {
         // ...
       }
       ```

    1. **function parameters는 2개로 제한하기**

       ```jsx
       BAD;

       function createMenu(title, body, buttonText, cancellable) {
         // ...
       }

       createMenu('Foo', 'Bar', 'Baz', true);

       GOOD;

       function createMenu({ title, body, buttonText, cancellable }) {
         // ...
       }

       createMenu({
         title: 'Foo',
         body: 'Bar',
         buttonText: 'Baz',
         cancellable: true,
       });
       ```

    1. **함수는 한가지 일만 수행하기**

       ```jsx
       BAD;

       function emailClients(clients) {
         clients.forEach((client) => {
           const clientRecord = database.lookup(client);
           if (clientRecord.isActive()) {
             email(client);
           }
         });
       }

       GOOD;

       function emailActiveClients(clients) {
         clients.filter(isActiveClient).forEach(email);
       }

       function isActiveClient(client) {
         const clientRecord = database.lookup(client);
         return clientRecord.isActive();
       }
       ```

    1. **함수는 하나의 개념으로 추상화하기**

       ```jsx
       BAD;

       function parseBetterJSAlternative(code) {
         const REGEXES = [
           // ...
         ];

         const statements = code.split(' ');
         const tokens = [];
         REGEXES.forEach((REGEX) => {
           statements.forEach((statement) => {
             // ...
           });
         });

         const ast = [];
         tokens.forEach((token) => {
           // lex...
         });

         ast.forEach((node) => {
           // parse...
         });
       }

       GOOD;

       function parseBetterJSAlternative(code) {
         const tokens = tokenize(code);
         const syntaxTree = parse(tokens);
         syntaxTree.forEach((node) => {
           // parse...
         });
       }

       function tokenize(code) {
         const REGEXES = [
           // ...
         ];

         const statements = code.split(' ');
         const tokens = [];
         REGEXES.forEach((REGEX) => {
           statements.forEach((statement) => {
             tokens.push(/* ... */);
           });
         });

         return tokens;
       }

       function parse(tokens) {
         const syntaxTree = [];
         tokens.forEach((token) => {
           syntaxTree.push(/* ... */);
         });

         return syntaxTree;
       }
       ```

    1. \***\*Object.assign으로 object deafult value 설정\*\***

       ```jsx
       BAD;

       const menuConfig = {
         title: null,
         body: 'Bar',
         buttonText: null,
         cancellable: true,
       };

       function createMenu(config) {
         config.title = config.title || 'Foo';
         config.body = config.body || 'Bar';
         config.buttonText = config.buttonText || 'Baz';
         config.cancellable = config.cancellable !== undefined ? config.cancellable : true;
       }

       createMenu(menuConfig);

       GOOD;

       const menuConfig = {
         title: 'Order',
         // User did not include 'body' key
         buttonText: 'Send',
         cancellable: true,
       };

       function createMenu(config) {
         let finalConfig = Object.assign(
           {
             title: 'Foo',
             body: 'Bar',
             buttonText: 'Baz',
             cancellable: true,
           },
           config
         );
         return finalConfig;
         // config now equals: {title: "Order", body: "Bar", buttonText: "Send", cancellable: true}
         // ...
       }

       createMenu(menuConfig);
       ```

    1. \***\*flag를 함수의 매개변수로 사용하지 말기\*\***

       ```jsx
       BAD;

       function createFile(name, temp) {
         if (temp) {
           fs.create(`./temp/${name}`);
         } else {
           fs.create(name);
         }
       }

       GOOD;

       function createFile(name) {
         fs.create(name);
       }

       function createTempFile(name) {
         createFile(`./temp/${name}`);
       }
       ```

    1. **조건문 캡슐화**

       ```jsx
       BAD;

       if (fsm.state === 'fetching' && isEmpty(listNode)) {
         // ...
       }

       GOOD;

       function shouldShowSpinner(fsm, listNode) {
         return fsm.state === 'fetching' && isEmpty(listNode);
       }

       if (shouldShowSpinner(fsmInstance, listNodeInstance)) {
         // ...
       }
       ```

    1. \***\*에러 무시하지 말기\*\***

       ```jsx
       BAD;

       try {
         functionThatMightThrow();
       } catch (error) {
         console.log(error);
       }

       GOOD;

       try {
         functionThatMightThrow();
       } catch (error) {
         // One option (more noisy than console.log):
         console.error(error);
         // Another option:
         notifyUserOfError(error);
         // Another option:
         reportErrorToService(error);
         // OR do all three!
       }
       ```

    1. \***\*에러를 catch 하기\*\***

       ```jsx
       BAD;

       getdata()
         .then((data) => {
           functionThatMightThrow(data);
         })
         .catch((error) => {
           console.log(error);
         });

       getdata()
         .then((data) => {
           functionThatMightThrow(data);
         })
         .catch((error) => {
           // One option (more noisy than console.log):
           console.error(error);
           // Another option:
           notifyUserOfError(error);
           // Another option:
           reportErrorToService(error);
           // OR do all three!
         });
       ```

    1. \***\*함수 호출자와 피호출자는 가까이 두기\*\***

       ```jsx
       BAD;

       class PerformanceReview {
         constructor(employee) {
           this.employee = employee;
         }

         lookupPeers() {
           return db.lookup(this.employee, 'peers');
         }

         lookupManager() {
           return db.lookup(this.employee, 'manager');
         }

         getPeerReviews() {
           const peers = this.lookupPeers();
           // ...
         }

         perfReview() {
           this.getPeerReviews();
           this.getManagerReview();
           this.getSelfReview();
         }

         getManagerReview() {
           const manager = this.lookupManager();
         }

         getSelfReview() {
           // ...
         }
       }

       const review = new PerformanceReview(employee);
       review.perfReview();

       GOOD;

       class PerformanceReview {
         constructor(employee) {
           this.employee = employee;
         }

         perfReview() {
           this.getPeerReviews();
           this.getManagerReview();
           this.getSelfReview();
         }

         getPeerReviews() {
           const peers = this.lookupPeers();
           // ...
         }

         lookupPeers() {
           return db.lookup(this.employee, 'peers');
         }

         getManagerReview() {
           const manager = this.lookupManager();
         }

         lookupManager() {
           return db.lookup(this.employee, 'manager');
         }

         getSelfReview() {
           // ...
         }
       }

       const review = new PerformanceReview(employee);
       review.perfReview();
       ```

       <aside>
       💡 **reference**

       https://hackernoon.com/the-art-of-naming-variables-52f44de00aad

       https://www.robinwieruch.de/javascript-naming-conventions/

       https://github.com/ryanmcdermott/clean-code-javascript

       https://speakerdeck.com/nigayo/uahan-jabaseukeuribteu-gaebal

       </aside>
